发送一个事务消息需要实现生产者和`TransactionListener`接口，如：
```java
// 生产者
public class TransactionProducer {
    public static void main(String[] args) throws MQClientException, InterruptedException {
        TransactionListener transactionListener = new TransactionListenerImpl();
        TransactionMQProducer producer = new TransactionMQProducer("please_rename_unique_group_name");
        ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(2000), new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                Thread thread = new Thread(r);
                thread.setName("client-transaction-msg-check-thread");
                return thread;
            }
        });

        producer.setExecutorService(executorService);
        producer.setTransactionListener(transactionListener);
        producer.setNamesrvAddr("127.0.0.1:9876");
        producer.start();

        String[] tags = new String[] {"TagA", "TagB", "TagC", "TagD", "TagE"};
        for (int i = 0; i < 10; i++) {
            try {
                Message msg =
                    new Message("TopicTest1234", tags[i % tags.length], "KEY" + i,
                        ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
                SendResult sendResult = producer.sendMessageInTransaction(msg, null);
                System.out.printf("%s%n", sendResult);

                Thread.sleep(10);
            } catch (MQClientException | UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        }

        for (int i = 0; i < 100000; i++) {
            Thread.sleep(1000);
        }
        producer.shutdown();
    }
}

// TransactionListener接口实现类
public class TransactionListenerImpl implements TransactionListener {
    private AtomicInteger transactionIndex = new AtomicInteger(0);

    private ConcurrentHashMap<String, Integer> localTrans = new ConcurrentHashMap<>();

    @Override
    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
        int value = transactionIndex.getAndIncrement();
        int status = value % 3;
        localTrans.put(msg.getTransactionId(), status);
        return LocalTransactionState.UNKNOW;
    }

    @Override
    public LocalTransactionState checkLocalTransaction(MessageExt msg) {
        Integer status = localTrans.get(msg.getTransactionId());
        if (null != status) {
            switch (status) {
                case 0:
                    return LocalTransactionState.UNKNOW;
                case 1:
                    return LocalTransactionState.COMMIT_MESSAGE;
                case 2:
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                default:
                    return LocalTransactionState.COMMIT_MESSAGE;
            }
        }
        return LocalTransactionState.COMMIT_MESSAGE;
    }
}
```

`TransactionListener`接口的作用是实现本地事务和事务消息的状态回查，关于rocketmq的事务消息的介绍可以看官方文档[RocketMQ事务消息流程概要](https://github.com/apache/rocketmq/blob/master/docs/cn/design.md#51-rocketmq%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A6%81)

下面分析rocektmq中事务消息的实现。

事务消息的生产者实现类`TransactionMQProducer`继承自普通的消息生产者实现类`DefaultMQProducer`，`TransactionMQProducer`只是增加了一个线程池的设置，代码如下：
```java
public class TransactionMQProducer extends DefaultMQProducer {
    private TransactionCheckListener transactionCheckListener;
    private int checkThreadPoolMinSize = 1;
    private int checkThreadPoolMaxSize = 1;
    private int checkRequestHoldMax = 2000;

    private ExecutorService executorService;

    private TransactionListener transactionListener;

    public TransactionMQProducer() {
    }

    public TransactionMQProducer(final String producerGroup) {
        this(null, producerGroup, null);
    }

    public TransactionMQProducer(final String namespace, final String producerGroup) {
        this(namespace, producerGroup, null);
    }

    public TransactionMQProducer(final String producerGroup, RPCHook rpcHook) {
        this(null, producerGroup, rpcHook);
    }

    public TransactionMQProducer(final String namespace, final String producerGroup, RPCHook rpcHook) {
        super(namespace, producerGroup, rpcHook);
    }

    @Override
    public void start() throws MQClientException {
        // 如果没有设置线程池，则初始化一个线程池
        this.defaultMQProducerImpl.initTransactionEnv();
        super.start();
    }

    @Override
    public void shutdown() {
        super.shutdown();
        // 关闭线程池
        this.defaultMQProducerImpl.destroyTransactionEnv();
    }

    /**
    * This method will be removed in the version 5.0.0, method <code>sendMessageInTransaction(Message,Object)</code>}
    * is recommended.
    */
    @Override
    @Deprecated
    public TransactionSendResult sendMessageInTransaction(final Message msg,
        final LocalTransactionExecuter tranExecuter, final Object arg) throws MQClientException {
        if (null == this.transactionCheckListener) {
            throw new MQClientException("localTransactionBranchCheckListener is null", null);
        }

        msg.setTopic(NamespaceUtil.wrapNamespace(this.getNamespace(), msg.getTopic()));
        return this.defaultMQProducerImpl.sendMessageInTransaction(msg, tranExecuter, arg);
    }

    @Override
    public TransactionSendResult sendMessageInTransaction(final Message msg,
        final Object arg) throws MQClientException {
        if (null == this.transactionListener) {
            throw new MQClientException("TransactionListener is null", null);
        }

        msg.setTopic(NamespaceUtil.wrapNamespace(this.getNamespace(), msg.getTopic()));
        // 事务消息的发送最终是由DefaultMQProducerImpl实现的
        return this.defaultMQProducerImpl.sendMessageInTransaction(msg, null, arg);
    }

    public TransactionCheckListener getTransactionCheckListener() {
        return transactionCheckListener;
    }

    /**
    * This method will be removed in the version 5.0.0 and set a custom thread pool is recommended.
    */
    @Deprecated
    public void setTransactionCheckListener(TransactionCheckListener transactionCheckListener) {
        this.transactionCheckListener = transactionCheckListener;
    }

    public int getCheckThreadPoolMinSize() {
        return checkThreadPoolMinSize;
    }

    /**
    * This method will be removed in the version 5.0.0 and set a custom thread pool is recommended.
    */
    @Deprecated
    public void setCheckThreadPoolMinSize(int checkThreadPoolMinSize) {
        this.checkThreadPoolMinSize = checkThreadPoolMinSize;
    }

    public int getCheckThreadPoolMaxSize() {
        return checkThreadPoolMaxSize;
    }

    /**
    * This method will be removed in the version 5.0.0 and set a custom thread pool is recommended.
    */
    @Deprecated
    public void setCheckThreadPoolMaxSize(int checkThreadPoolMaxSize) {
        this.checkThreadPoolMaxSize = checkThreadPoolMaxSize;
    }

    public int getCheckRequestHoldMax() {
        return checkRequestHoldMax;
    }

    /**
    * This method will be removed in the version 5.0.0 and set a custom thread pool is recommended.
    */
    @Deprecated
    public void setCheckRequestHoldMax(int checkRequestHoldMax) {
        this.checkRequestHoldMax = checkRequestHoldMax;
    }

    public ExecutorService getExecutorService() {
        return executorService;
    }

    public void setExecutorService(ExecutorService executorService) {
        this.executorService = executorService;
    }

    public TransactionListener getTransactionListener() {
        return transactionListener;
    }

    public void setTransactionListener(TransactionListener transactionListener) {
        this.transactionListener = transactionListener;
    }
}
```

发送事务消息的方法是`TransactionMQProducer`类的`sendMessageInTransaction()`方法，改方法的实现是调用`DefaultMQProducerImpl`类的`sendMessageInTransaction()`方法完成事务消息发送逻辑，`DefaultMQProducerImpl`类的`sendMessageInTransaction()`方法代码：
```java
public TransactionSendResult sendMessageInTransaction(final Message msg,
    final LocalTransactionExecuter localTransactionExecuter, final Object arg)
    throws MQClientException {
    // 获取用户编写的TransactionListener实现类
    TransactionListener transactionListener = getCheckListener();
    if (null == localTransactionExecuter && null == transactionListener) {
        throw new MQClientException("tranExecutor is null", null);
    }

    // ignore DelayTimeLevel parameter
    // 事务消息不支持延时
    if (msg.getDelayTimeLevel() != 0) {
        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);
    }

    // 检查message的属性是否合法
    Validators.checkMessage(msg, this.defaultMQProducer);

    SendResult sendResult = null;
    // 标识这是个事务消息
    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, "true");
    // 保存消息的生产者组
    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());
    try {
        // 像普通消息一样同步发送
        sendResult = this.send(msg);
    } catch (Exception e) {
        throw new MQClientException("send message Exception", e);
    }

    LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;
    Throwable localException = null;
    switch (sendResult.getSendStatus()) {
        case SEND_OK: { // 发送成功
            try {
                if (sendResult.getTransactionId() != null) {
                    msg.putUserProperty("__transactionId__", sendResult.getTransactionId());
                }
                // 获取事务ID
                String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);
                if (null != transactionId && !"".equals(transactionId)) {
                    msg.setTransactionId(transactionId);
                }
                // 执行本地事务
                if (null != localTransactionExecuter) {
                    localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);
                } else if (transactionListener != null) {
                    log.debug("Used new transaction API");
                    localTransactionState = transactionListener.executeLocalTransaction(msg, arg);
                }
                // 如果没有执行结果，则设置为UNKNOWN
                if (null == localTransactionState) {
                    localTransactionState = LocalTransactionState.UNKNOW;
                }

                if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {
                    log.info("executeLocalTransactionBranch return {}", localTransactionState);
                    log.info(msg.toString());
                }
            } catch (Throwable e) {
                log.info("executeLocalTransactionBranch exception", e);
                log.info(msg.toString());
                localException = e;
            }
        }
        break;
        case FLUSH_DISK_TIMEOUT: // 这几个发送结果都是发送失败，此时设置事务状态为rollback
        case FLUSH_SLAVE_TIMEOUT:
        case SLAVE_NOT_AVAILABLE:
            localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;
            break;
        default:
            break;
    }

    try {
        this.endTransaction(sendResult, localTransactionState, localException);
    } catch (Exception e) {
        log.warn("local transaction execute " + localTransactionState + ", but end broker transaction failed", e);
    }

    // 返回发送结果，TransactionSendResult类继承自SendResult，在SendResult的基础上加了LocalTransactionState属性
    TransactionSendResult transactionSendResult = new TransactionSendResult();
    transactionSendResult.setSendStatus(sendResult.getSendStatus());
    transactionSendResult.setMessageQueue(sendResult.getMessageQueue());
    transactionSendResult.setMsgId(sendResult.getMsgId());
    transactionSendResult.setQueueOffset(sendResult.getQueueOffset());
    transactionSendResult.setTransactionId(sendResult.getTransactionId());
    transactionSendResult.setLocalTransactionState(localTransactionState);
    return transactionSendResult;
}
```

`sendMessageInTransaction()`方法首先设置消息的`MessageConst.PROPERTY_TRANSACTION_PREPARED`属性为true，表示这是个half消息，之后同步发送消息给broker，如果发送成功，再通过`TransactionListener`的实现类完成本地事务逻辑，最后传入发送结果和事务状态到`endTransaction()`方法执行，`endTransaction()`方法会将本地事务的执行结果发送给broker，代码：
```java
public void endTransaction(
    final SendResult sendResult,
    final LocalTransactionState localTransactionState,
    final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException {
    final MessageId id;
    // 解码消息的MessageId或者UniqKey，获取消息的位移
    if (sendResult.getOffsetMsgId() != null) {
        id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());
    } else {
        id = MessageDecoder.decodeMessageId(sendResult.getMsgId());
    }
    // 获取事务id
    String transactionId = sendResult.getTransactionId();
    final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());
    EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();
    requestHeader.setTransactionId(transactionId);
    requestHeader.setCommitLogOffset(id.getOffset());
    // 根据事务状态设置请求的commitOrRollback属性
    switch (localTransactionState) {
        case COMMIT_MESSAGE:
            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);
            break;
        case ROLLBACK_MESSAGE:
            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);
            break;
        case UNKNOW: // 本地事务执行失败或者本地事务执行后返回null，则localTransactionState为unknown
            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);
            break;
        default:
            break;
    }

    // 设置生产者组
    requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());
    // half发送的队列中保存了多少条消息
    requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());
    requestHeader.setMsgId(sendResult.getMsgId());
    // 记录本地事务执行的异常信息
    String remark = localException != null ? ("executeLocalTransactionBranch exception: " + localException.toString()) : null;
    // 发送RequestCode.END_TRANSACTION请求
    this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,
        this.defaultMQProducer.getSendMsgTimeout());
}
```

这里先看`sendMessageInTransaction()`方法发送half消息后broker对half消息的处理，处理逻辑在`SendMessageProcessor`类的`sendMessage()`方法：
```java
private RemotingCommand sendMessage(final ChannelHandlerContext ctx,
                                    final RemotingCommand request,
                                    final SendMessageContext sendMessageContext,
                                    final SendMessageRequestHeader requestHeader) throws RemotingCommandException {

    // 略...                                

    Map<String, String> oriProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());
    // 检查是否是事务消息
    String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);
    if (traFlag != null && Boolean.parseBoolean(traFlag)
        && !(msgInner.getReconsumeTimes() > 0 && msgInner.getDelayTimeLevel() > 0)) { //For client under version 4.6.1
        if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {
            response.setCode(ResponseCode.NO_PERMISSION);
            response.setRemark(
                "the broker[" + this.brokerController.getBrokerConfig().getBrokerIP1()
                    + "] sending transaction message is forbidden");
            return response;
        }
        // 否则按照事务消息处理
        putMessageResult = this.brokerController.getTransactionalMessageService().prepareMessage(msgInner);
    } else {
        // 保存消息
        putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner);
    }

    // 根据消息的保存结果返回响应
    return handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);

}
```

`sendMessage()`方法的实现在笔记[如何处理发送消息的请求](../broker/如何处理发送消息的请求.md)中已经分析过了，这里直接看关于事务消息的处理，`sendMessage()`方法通过`TransactionalMessageServiceImpl`类的`prepareMessage()`方法处理事务消息：
```java
@Override
public PutMessageResult prepareMessage(MessageExtBrokerInner messageInner) {
    return transactionalMessageBridge.putHalfMessage(messageInner);
}

// 上面调用的TransactionalMessageBridge类的putHalfMessage方法
public PutMessageResult putHalfMessage(MessageExtBrokerInner messageInner) {
    return store.putMessage(parseHalfMessageInner(messageInner));
}
```

`TransactionalMessageBridge`类为处理事务消息提供了一些方法，具体实现在碰到的时候分析，从上面的代码可以看出，`TransactionalMessageServiceImpl`类的`prepareMessage()`方法最终调用的是`DefaultMessageStore`类的`putMessage()`方法保存事务消息，在保存事务消息之前，调用了`TransactionalMessageBridge`类的`parseHalfMessageInner()`对事务消息做了一些处理，代码：
```java
private MessageExtBrokerInner parseHalfMessageInner(MessageExtBrokerInner msgInner) {
    // 保存事务消息真正的topic
    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());
    // 保存事务消息正在的队列id
    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,
        String.valueOf(msgInner.getQueueId()));
    msgInner.setSysFlag(
        MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));
    // 设置消息的topic为RMQ_SYS_TRANS_HALF_TOPIC，即专门保存half消息的topic
    msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());
    // RMQ_SYS_TRANS_HALF_TOPIC这个topic只有一个队列
    msgInner.setQueueId(0);
    // 保存消息属性
    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));
    return msgInner;
}
```

`TransactionalMessageBridge`类在通过`DefaultMessageStore`类保存事务消息之前，会保存事务消息真正的topic，并更新topic为`RMQ_SYS_TRANS_HALF_TOPIC`，同时设置队列id为0，这个实现方式和延时消息的实现很像，只不过延时消息的队列不止一个。

在更新事务消息的topic和队列id后，由`DefaultMessageStore`类的`putMessage()`方法保存消息，这个过程和普通消息是一样的，可以看笔记[如何实现消息存储](../broker/如何实现消息存储.md)，这里不再赘述。

在事务消息保存到broker后，回到生产者，如果消息保存成功，生产者就能够执行本地事务，并且在执行完成之后，生产者会向broker发送执行结果，执行发送的逻辑在上面分析过的`endTransaction()`方法，该方法会发送`RequestCode.END_TRANSACTION`请求到broker，请求中包含本地事务的执行结果，该请求在broker中的处理方法是`EndTransactionProcessor`类的`processRequest()`方法，该方法代码：
```java
@Override
public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws
    RemotingCommandException {
    final RemotingCommand response = RemotingCommand.createResponseCommand(null);
    final EndTransactionRequestHeader requestHeader =
        (EndTransactionRequestHeader)request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);
    LOGGER.debug("Transaction request:{}", requestHeader);
    // slave节点不处理事务消息
    if (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) {
        response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);
        LOGGER.warn("Message store is slave mode, so end transaction is forbidden. ");
        return response;
    }

    // 表示当前的请求是否是由broker向生产者查询事务状态后生产者发送过来的
    if (requestHeader.getFromTransactionCheck()) {
        switch (requestHeader.getCommitOrRollback()) {
            case MessageSysFlag.TRANSACTION_NOT_TYPE: { // 如果生产者检查事务状态出现异常或者返回值为空，即事务状态未知
                LOGGER.warn("Check producer[{}] transaction state, but it's pending status."
                        + "RequestHeader: {} Remark: {}",
                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),
                    requestHeader.toString(),
                    request.getRemark());
                return null;
            }

            case MessageSysFlag.TRANSACTION_COMMIT_TYPE: {
                LOGGER.warn("Check producer[{}] transaction state, the producer commit the message."
                        + "RequestHeader: {} Remark: {}",
                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),
                    requestHeader.toString(),
                    request.getRemark());

                break;
            }

            case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: {
                LOGGER.warn("Check producer[{}] transaction state, the producer rollback the message."
                        + "RequestHeader: {} Remark: {}",
                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),
                    requestHeader.toString(),
                    request.getRemark());
                break;
            }
            default:
                return null;
        }
    } else {
        switch (requestHeader.getCommitOrRollback()) {
            case MessageSysFlag.TRANSACTION_NOT_TYPE: { // 如果生产者检查事务状态出现异常或者返回值为空，即事务状态未知
                LOGGER.warn("The producer[{}] end transaction in sending message,  and it's pending status."
                        + "RequestHeader: {} Remark: {}",
                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),
                    requestHeader.toString(),
                    request.getRemark());
                return null;
            }

            case MessageSysFlag.TRANSACTION_COMMIT_TYPE: {
                break;
            }

            case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: {
                LOGGER.warn("The producer[{}] end transaction in sending message, rollback the message."
                        + "RequestHeader: {} Remark: {}",
                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),
                    requestHeader.toString(),
                    request.getRemark());
                break;
            }
            default:
                return null;
        }
    }
    OperationResult result = new OperationResult();
    // 如果是提交事务
    if (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) {
        // 通过TransactionalMessageServiceImpl执行消息提交，实际上只是执行根据消息位移返回消息
        result = this.brokerController.getTransactionalMessageService().commitMessage(requestHeader);
        // 如果消息查询成功
        if (result.getResponseCode() == ResponseCode.SUCCESS) {
            // result.getPrepareMessage()就是请求中的消息位移对应的消息，这里对消息获取到的消息和请求中的消息属性做对比，判断
            // 是否匹配
            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);
            if (res.getCode() == ResponseCode.SUCCESS) {
                // 根据查询到的消息，恢复事务消息原来的属性，如topic、队列id
                MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());
                msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));
                // 设置消息在队列中的位置
                msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());
                // 设置half消息的位移
                msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());
                msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());
                // 清除消息的事务标识
                MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_TRANSACTION_PREPARED);
                // 此时msgInner就是个普通消息了，这里通过DefaultMessageStore保存消息
                RemotingCommand sendResult = sendFinalMessage(msgInner);
                if (sendResult.getCode() == ResponseCode.SUCCESS) {
                    // 保存成功时，创建一个op消息保存到RMQ_SYS_TRANS_OP_HALF_TOPIC这个topic
                    this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());
                }
                return sendResult;
            }
            return res;
        }
    } else if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) { // 如果是回滚事务
        // 获取事务消息
        result = this.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);
        // 下面的处理过程和提交事务时的处理过程唯一的区别是，下面没有恢复事务消息并保存到DefaultMessageStore中，相当于消息直接被忽略了
        if (result.getResponseCode() == ResponseCode.SUCCESS) {
            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);
            if (res.getCode() == ResponseCode.SUCCESS) {
                this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());
            }
            return res;
        }
    }
    response.setCode(result.getResponseCode());
    response.setRemark(result.getResponseRemark());
    return response;
}
```

`processRequest()`方法对于提交事务请求和回滚事务请求的处理差别不大，处理过程都是先根据请求中的消息位移获取事务消息，之后调用`TransactionalMessageServiceImpl`类的`deletePrepareMessage()`方法为事务消息创建一个op消息，只不过对于提交事务的请求，`processRequest()`方法会先根据事务消息恢复本来的消息内容，即恢复消息的topic和队列id等属性，之后将恢复的消息保存到`DefaultMessageStore`类，这样消费者就能够消费这条消息了，回滚事务请求的处理过程没有这一步，相当于事务消息本来的消息被忽略了。

下面再看看`TransactionalMessageServiceImpl`类的`deletePrepareMessage()`方法是如何创建op消息的，代码：
```java
@Override
public boolean deletePrepareMessage(MessageExt msgExt) {
    if (this.transactionalMessageBridge.putOpMessage(msgExt, TransactionalMessageUtil.REMOVETAG)) {
        log.debug("Transaction op message write successfully. messageId={}, queueId={} msgExt:{}", msgExt.getMsgId(), msgExt.getQueueId(), msgExt);
        return true;
    } else {
        log.error("Transaction op message write failed. messageId is {}, queueId is {}", msgExt.getMsgId(), msgExt.getQueueId());
        return false;
    }
}

public boolean putOpMessage(MessageExt messageExt, String opType) {
    MessageQueue messageQueue = new MessageQueue(messageExt.getTopic(),
        this.brokerController.getBrokerConfig().getBrokerName(), messageExt.getQueueId());
    if (TransactionalMessageUtil.REMOVETAG.equals(opType)) {
        return addRemoveTagInTransactionOp(messageExt, messageQueue);
    }
    return true;
}

private boolean addRemoveTagInTransactionOp(MessageExt messageExt, MessageQueue messageQueue) {
    // 创建一条topic为RMQ_SYS_TRANS_OP_HALF_TOPIC的op消息，消息内容是当前消息在RMQ_SYS_TRANS_HALF_TOPIC这个topic下的队列的
    // 位置（数组位置）
    Message message = new Message(TransactionalMessageUtil.buildOpTopic(), TransactionalMessageUtil.REMOVETAG,
        String.valueOf(messageExt.getQueueOffset()).getBytes(TransactionalMessageUtil.charset));
    writeOp(message, messageQueue);
    return true;
}

private void writeOp(Message message, MessageQueue mq) {
    MessageQueue opQueue;
    if (opQueueMap.containsKey(mq)) {
        opQueue = opQueueMap.get(mq);
    } else {
        // 创建一个和mq属性一摸一样的MessageQueue对象
        opQueue = getOpQueueByHalf(mq);
        MessageQueue oldQueue = opQueueMap.putIfAbsent(mq, opQueue);
        if (oldQueue != null) {
            opQueue = oldQueue;
        }
    }
    if (opQueue == null) {
        opQueue = new MessageQueue(TransactionalMessageUtil.buildOpTopic(), mq.getBrokerName(), mq.getQueueId());
    }
    // makeOpMessageInner方法创建一个op消息对象，putMessage方法将该消息到DefaultMessageStore
    putMessage(makeOpMessageInner(message, opQueue));
}

public boolean putMessage(MessageExtBrokerInner messageInner) {
    PutMessageResult putMessageResult = store.putMessage(messageInner);
    if (putMessageResult != null
        && putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) {
        return true;
    } else {
        LOGGER.error("Put message failed, topic: {}, queueId: {}, msgId: {}",
            messageInner.getTopic(), messageInner.getQueueId(), messageInner.getMsgId());
        return false;
    }
}
```

`deletePrepareMessage()`方法的实现是创建一个topic为`RMQ_SYS_TRANS_OP_HALF_TOPIC`的op消息并保存到`DefaultMessageStore`类，到了这里关于提交和回滚事务的请求处理过程已经结束了，这个过程涉及到了两个broker内部的topic：`RMQ_SYS_TRANS_HALF_TOPIC`和`RMQ_SYS_TRANS_OP_HALF_TOPIC`，下面再看看broker内部是如何处理这两个topic的消息的。

broker中有一个线程实现类`TransactionalMessageCheckService`，代码如下：
```java
public class TransactionalMessageCheckService extends ServiceThread {
    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.TRANSACTION_LOGGER_NAME);

    private BrokerController brokerController;

    public TransactionalMessageCheckService(BrokerController brokerController) {
        this.brokerController = brokerController;
    }

    @Override
    public String getServiceName() {
        return TransactionalMessageCheckService.class.getSimpleName();
    }

    @Override
    public void run() {
        log.info("Start transaction check service thread!");
        // 默认每分钟执行一次
        long checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();
        while (!this.isStopped()) {
            this.waitForRunning(checkInterval);
        }
        log.info("End transaction check service thread!");
    }

    @Override
    // 每次waitForRunning方法等待结束都会调用下面的方法
    protected void onWaitEnd() {
        long timeout = brokerController.getBrokerConfig().getTransactionTimeOut();
        // checkMax表示一个op消息被check的最大次数，默认15次
        int checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();
        long begin = System.currentTimeMillis();
        log.info("Begin to check prepare message, begin time:{}", begin);
        this.brokerController.getTransactionalMessageService().check(timeout, checkMax, this.brokerController.getTransactionalMessageCheckListener());
        log.info("End to check prepare message, consumed time:{}", System.currentTimeMillis() - begin);
    }

}
```

该类会每60s调用一次`TransactionalMessageServiceImpl`类的`check()`方法，该方法代码：
```java
@Override
public void check(long transactionTimeout, int transactionCheckMax,
    AbstractTransactionalMessageCheckListener listener) {
    try {
        String topic = MixAll.RMQ_SYS_TRANS_HALF_TOPIC;
        // 获取RMQ_SYS_TRANS_HALF_TOPIC这个topic下的所有队列
        Set<MessageQueue> msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);
        if (msgQueues == null || msgQueues.size() == 0) {
            log.warn("The queue of topic is empty :" + topic);
            return;
        }
        log.debug("Check topic={}, queues={}", topic, msgQueues);
        // 遍历RMQ_SYS_TRANS_HALF_TOPIC这个topic下的所有队列
        for (MessageQueue messageQueue : msgQueues) {
            long startTime = System.currentTimeMillis();
            // 创建这个队列对应的op队列
            MessageQueue opQueue = getOpQueue(messageQueue);
            // 获取当前队列已经被消费的消息的最大消费位移（相当于在队列中的数组位置）
            long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);
            // 获取op队列已经被消费的消息的最大消费位移
            long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);
            log.info("Before check, the queue={} msgOffset={} opOffset={}", messageQueue, halfOffset, opOffset);
            if (halfOffset < 0 || opOffset < 0) {
                log.error("MessageQueue: {} illegal offset read: {}, op offset: {},skip this queue", messageQueue,
                    halfOffset, opOffset);
                continue;
            }

            List<Long> doneOpOffset = new ArrayList<>();
            HashMap<Long, Long> removeMap = new HashMap<>();
            // fillOpRemoveMap方法会从opQueue的opOffset位置开始获取消息，并将已经check过的事务消息的op消息在队列中的数组位置保存到doneOpOffset，
            // 还未check但是已经有了op消息的事务消息放到removeMap，map的key是事务消息在其队列中的数组位置，value为op消息在其队列中的数组位置
            // 通过数组位置查询consumequeue就能找到对应的消息索引，从而在commitlog文件中找到消息
            PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);
            if (null == pullResult) {
                log.error("The queue={} check msgOffset={} with opOffset={} failed, pullResult is null",
                    messageQueue, halfOffset, opOffset);
                continue;
            }
            // single thread
            // 查询事务消息失败后重试的次数
            int getMessageNullCount = 1;
            long newOffset = halfOffset;
            long i = halfOffset;
            while (true) {
                // 超过最大处理时间不再处理
                if (System.currentTimeMillis() - startTime > MAX_PROCESS_TIME_LIMIT) {
                    log.info("Queue={} process time reach max={}", messageQueue, MAX_PROCESS_TIME_LIMIT);
                    break;
                }
                // i的初始值是事务消息被消费的进度（数组位置），如果removeMap包含i，说明当前事务消息已经存在对应的op消息，不需要再check
                // 了，直接添加到doneOpOffset中
                if (removeMap.containsKey(i)) {
                    log.info("Half offset {} has been committed/rolled back", i);
                    Long removedOpOffset = removeMap.remove(i);
                    doneOpOffset.add(removedOpOffset);
                } else {
                    // 获取messageQueue这个队列的第i条消息，原理是找到messageQueue对应的consumequeue文件，并获取该文件的
                    // 第i个消息索引，再根据消息索引返回消息
                    GetResult getResult = getHalfMsg(messageQueue, i);
                    MessageExt msgExt = getResult.getMsg();
                    if (msgExt == null) {
                        if (getMessageNullCount++ > MAX_RETRY_COUNT_WHEN_HALF_NULL) { // 获取失败并超过最大重试次数时退出循环
                            break;
                        }
                        if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) { // 没有可以消费的消息时退出循环
                            log.debug("No new msg, the miss offset={} in={}, continue check={}, pull result={}", i,
                                messageQueue, getMessageNullCount, getResult.getPullResult());
                            break;
                        } else {
                            log.info("Illegal offset, the miss offset={} in={}, continue check={}, pull result={}",
                                i, messageQueue, getMessageNullCount, getResult.getPullResult());
                            i = getResult.getPullResult().getNextBeginOffset();
                            newOffset = i;
                            continue;
                        }
                    }

                    // 判断是否超过了check的次数，默认15次，或者判断是否op消息存在的时间超过了设定的保留时间，默认72小时
                    if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {
                        // 创建一个topic为TRANS_CHECK_MAX_TIME_TOPIC的消息并保存到DefaultMessageStore
                        listener.resolveDiscardMsg(msgExt);
                        // 更新需要处理的消息位移
                        newOffset = i + 1;
                        i++;
                        // 继续处理下一条消息，当前消息被忽略了，也不会再被check
                        continue;
                    }
                    if (msgExt.getStoreTimestamp() >= startTime) {
                        log.debug("Fresh stored. the miss offset={}, check it later, store={}", i,
                            new Date(msgExt.getStoreTimestamp()));
                        break;
                    }

                    // 计算事务消息存在的时间
                    long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();
                    // transactionTimeout表示事务的过期时间，也就是什么时间后才开始进行事务回查，在transactionTimeout
                    // 时间内，不执行事务回查，给本地事务留下了执行时间
                    long checkImmunityTime = transactionTimeout;
                    // CHECK_IMMUNITY_TIME_IN_SECONDS属性为用户属性，可以覆盖transactionTimeout的值
                    String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS);
                    if (null != checkImmunityTimeStr) {
                        checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);
                        // 如果还没到需要回查的时间，为了推进check的进度，将当前消息重新保存一次到DefaultMessageStore，并且
                        // 增加newOffset的值，相当于忽略当前事务消息，该事务消息的副本已经被重新保存到最新的位置了
                        if (valueOfCurrentMinusBorn < checkImmunityTime) {
                            if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) {
                                newOffset = i + 1;
                                i++;
                                continue;
                            }
                        }
                    } else {
                        // 如果当前事务消息的创建时间比当前check方法执行时间要晚，则直接break，下次再check
                        if ((0 <= valueOfCurrentMinusBorn) && (valueOfCurrentMinusBorn < checkImmunityTime)) {
                            log.debug("New arrived, the miss offset={}, check it later checkImmunity={}, born={}", i,
                                checkImmunityTime, new Date(msgExt.getBornTimestamp()));
                            break;
                        }
                    }
                    List<MessageExt> opMsg = pullResult.getMsgFoundList();
                    // 如果op消息列表为空并且到了check的时间，或者获取到的op消息的最大创建时间减去开始时间超过了事务超时时间，则需要发送
                    // 事务回查，什么时候会出现(opMsg != null && (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout))
                    // 呢，看下面isNeedCheck为true时的处理可以发现，每次回查消息前，都会将事务消息重新保存到DefaultMessageStore，
                    // 之后会异步发送事务消息回查请求，既然是异步发送，如何知道回查结果呢，答案是不需要知道结果，当生产者收到消息回查请求后，
                    // 会检查本地事务并再次发送提交或回滚事务消息的请求，可能发送成功，也可能发送失败，也可能还不知道事务状态，如果是
                    // 成功发送提交或回滚事务的请求，则会有对应的op消息被保存，也这是fillOpRemoveMap方法实现的原因，该方法需要根据op
                    // 消息对当前正在check的事务消息去重，避免重复回查事务状态；另外如果生产者没有返回本地事务的状态，或者还不知道本地
                    // 事务的状态也没关系，下面在回查之前会调用putBackHalfMsgQueue方法重新保存一个事务消息到DefaultMessageStore，
                    // 所以当前的事务消息在发送回查请求后会被认为已经处理，在之后这个事务消息还有机会再次被check。
                    boolean isNeedCheck = (opMsg == null && valueOfCurrentMinusBorn > checkImmunityTime)
                        || (opMsg != null && (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout))
                        || (valueOfCurrentMinusBorn <= -1);

                    // 如果需要回查
                    if (isNeedCheck) {
                        // 根据msgExt创建一个新的消息对象并保存到DefaultMessageStore，所以每次回查前消息都会被重新保存一次到DefaultMessageStore
                        if (!putBackHalfMsgQueue(msgExt, i)) {
                            continue;
                        }
                        // 向生产者发送回查事务状态请求
                        listener.resolveHalfMsg(msgExt);
                    } else {
                        // 不需要回查的消息，则再获取一批op消息，重新开始循环，出现这个情况可能是查询op消息返回空，此时重新查询一次op消息，
                        // 也可能是op消息不为空，但是不满足(opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout)
                        // 即查到的op消息的创建时间和循环开始时间的差都小于事务超时时间，op消息创建的时间肯定是大于其对应的事务消息的创建
                        // 时间的，所以这就相当于这些op消息的事务消息都还没有到达事务超时时间，什么时候会这样呢，这是因为fillOpRemoveMap
                        // 方法一次最多只查询32条op消息，所以当前事务消息对应的op消息很可能还在后面，所以需要再调用fillOpRemoveMap方法，并
                        // 从pullResult.getNextBeginOffset()位置之后开始查
                        pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);
                        log.debug("The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}", i,
                            messageQueue, pullResult);
                        continue;
                    }
                }
                // 更新下一次需要处理的消息位移
                newOffset = i + 1;
                i++;
            }
            // 如果有消息被成功处理了，提交事务消息队列的消费位移
            if (newOffset != halfOffset) {
                transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);
            }
            // 返回连续的doneOffset元素的最大值 + 1，关键要是连续的
            long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);
            if (newOpOffset != opOffset) {
                // 提交op队列的消费位移
                transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
        log.error("Check error", e);
    }

}
```

`check()`方法会获取所有`RMQ_SYS_TRANS_HALF_TOPIC`这个topic下的队列并遍历（实际上就一个队列），遍历过程是先调用`fillOpRemoveMap()`方法获取事务消息已经消费的进度和op消息已经消费的进度，之后从op消息所在的队列获取还没有确认消费的op消息，同时解析op消息的内容，`fillOpRemoveMap()`方法代码：
```java
private PullResult fillOpRemoveMap(HashMap<Long, Long> removeMap,
    MessageQueue opQueue, long pullOffsetOfOp, long miniOffset, List<Long> doneOpOffset) {
    // 从op队列的pullOffsetOfOp位置开始获取最多32条消息进行消费
    PullResult pullResult = pullOpMsg(opQueue, pullOffsetOfOp, 32);
    if (null == pullResult) {
        return null;
    }
    if (pullResult.getPullStatus() == PullStatus.OFFSET_ILLEGAL
        || pullResult.getPullStatus() == PullStatus.NO_MATCHED_MSG) { // 如果消费的位移不合法，则更新消费的位移
        log.warn("The miss op offset={} in queue={} is illegal, pullResult={}", pullOffsetOfOp, opQueue,
            pullResult);
        transactionalMessageBridge.updateConsumeOffset(opQueue, pullResult.getNextBeginOffset());
        return pullResult;
    } else if (pullResult.getPullStatus() == PullStatus.NO_NEW_MSG) { // 如果没有可以消费的消息
        log.warn("The miss op offset={} in queue={} is NO_NEW_MSG, pullResult={}", pullOffsetOfOp, opQueue,
            pullResult);
        return pullResult;
    }
    List<MessageExt> opMsg = pullResult.getMsgFoundList();
    if (opMsg == null) {
        log.warn("The miss op offset={} in queue={} is empty, pullResult={}", pullOffsetOfOp, opQueue, pullResult);
        return pullResult;
    }
    // 遍历从op队列获取到的等待消费的消息
    for (MessageExt opMessageExt : opMsg) {
        // 解码op消息内容，op消息的内容是其对应的事务消息在队列中的位置（数组位置），根据这个位置能够从consumequeue文件查询消息
        Long queueOffset = getLong(new String(opMessageExt.getBody(), TransactionalMessageUtil.charset));
        log.debug("Topic: {} tags: {}, OpOffset: {}, HalfOffset: {}", opMessageExt.getTopic(),
            opMessageExt.getTags(), opMessageExt.getQueueOffset(), queueOffset);
        // op消息的tag都是TransactionalMessageUtil.REMOVETAG
        if (TransactionalMessageUtil.REMOVETAG.equals(opMessageExt.getTags())) {
            if (queueOffset < miniOffset) { // 小于miniOffset说明该op消息对应的事务消息已经check过了
                // 保存op消息在其队列中的数组位置到doneOpOffset
                doneOpOffset.add(opMessageExt.getQueueOffset());
            } else {
                // queueOffset >= miniOffset时，说明当前op消息对应的事务消息还没有被check，但是已经有了op消息，说明事务状态
                // 已经确定了，此时也没必要再check了，这里将这种消息保存到removeMap中，map的key为事务消息在队列中的数组位置，value为
                // op消息在队列中的数组位置
                removeMap.put(queueOffset, opMessageExt.getQueueOffset());
            }
        } else {
            log.error("Found a illegal tag in opMessageExt= {} ", opMessageExt);
        }
    }
    log.debug("Remove map: {}", removeMap);
    log.debug("Done op list: {}", doneOpOffset);
    return pullResult;
}
```
op消息的内容是其对应的事务消息在其队列中的位移，`fillOpRemoveMap()`方法将事务消息的位移小于`miniOffset`的保存到`doneOpOffset`中，`miniOffset`的值是已经被确认消费的事务消息的位置，所以满足`queueOffset < miniOffset`条件说明该op消息对应的事务消息已经被确认消费了，不需要再执行事务回查了。如果不满足`queueOffset < miniOffset`，说明事务消息已经存在了对应的op消息，但是事务消息还没有被确认消费，此时将事务消息的位移和op消息的位移保存到`removeMap`这个map中。初看`fillOpRemoveMap()`方法的实现可能对这种处理方式不理解，这个在后面继续分析`check()`方法的执行逻辑时就能理解了。

回到`check()`方法，在获取到一批等待消费的op消息后（注意`fillOpRemoveMap()`方法一次最大获取32条op消息），`check()`方法从事务消息被确认消息的位置开始继续获取事务消息，判断获取到的事务消息是否超过了check次数的上限（默认15次），获取超过了存在时间，如果是则将事务消息保存到`TRANS_CHECK_MAX_TIME_TOPIC`这个topic并更新继续获取下一条事务消息，相当于忽略该事务消息。如果事务消息不满足被忽略的条件，则判断事务消息是否到了应该被执行事务回查的时间，默认60s，在这段时间内broker不会回查指定的事务消息，相当于给本地事务的执行提供时间。如果到了事务执行的时间，则执行如下语句：
```java
List<MessageExt> opMsg = pullResult.getMsgFoundList();
// 如果op消息列表为空并且到了check的时间，或者获取到的op消息的最大创建时间减去开始时间超过了事务超时时间，则需要发送
// 事务回查，什么时候会出现(opMsg != null && (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout))
// 呢，看下面isNeedCheck为true时的处理可以发现，每次回查消息前，都会将事务消息重新保存到DefaultMessageStore，
// 之后会异步发送事务消息回查请求，既然是异步发送，如何知道回查结果呢，答案是不需要知道结果，当生产者收到消息回查请求后，
// 会检查本地事务并再次发送提交或回滚事务消息的请求，可能发送成功，也可能发送失败，也可能还不知道事务状态，如果是
// 成功发送提交或回滚事务的请求，则会有对应的op消息被保存，也这是fillOpRemoveMap方法实现的原因，该方法需要根据op
// 消息对当前正在check的事务消息去重，避免重复回查事务状态；另外如果生产者没有返回本地事务的状态，或者还不知道本地
// 事务的状态也没关系，下面在回查之前会调用putBackHalfMsgQueue方法重新保存一个事务消息到DefaultMessageStore，
// 所以当前的事务消息在发送回查请求后会被认为已经处理，在之后这个事务消息还有机会再次被check。
boolean isNeedCheck = (opMsg == null && valueOfCurrentMinusBorn > checkImmunityTime)
    || (opMsg != null && (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout))
    || (valueOfCurrentMinusBorn <= -1);

// 如果需要回查
if (isNeedCheck) {
    // 根据msgExt创建一个新的消息对象并保存到DefaultMessageStore，所以每次回查前消息都会被重新保存一次到DefaultMessageStore
    if (!putBackHalfMsgQueue(msgExt, i)) {
        continue;
    }
    // 异步向生产者发送回查事务状态请求
    listener.resolveHalfMsg(msgExt);
} else {
    // 不需要回查的消息，则再获取一批op消息，重新开始循环，出现这个情况可能是查询op消息返回空，此时重新查询一次op消息，
    // 也可能是op消息不为空，但是不满足(opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout)
    // 即查到的op消息的创建时间和循环开始时间的差都小于事务超时时间，op消息创建的时间肯定是大于其对应的事务消息的创建
    // 时间的，所以这就相当于这些op消息的事务消息都还没有到达事务超时时间，什么时候会这样呢，这是因为fillOpRemoveMap
    // 方法一次最多只查询32条op消息，所以当前事务消息对应的op消息很可能还在后面，所以需要再调用fillOpRemoveMap方法，并
    // 从pullResult.getNextBeginOffset()位置之后开始查
    pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);
    log.debug("The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}", i,
        messageQueue, pullResult);
    continue;
}

// 上面用到的listener.resolveHalfMsg(msgExt)方法
public void resolveHalfMsg(final MessageExt msgExt) {
    // 异步执行事务消息的回查，不考虑发送结果
    executorService.execute(new Runnable() {
        @Override
        public void run() {
            try {
                sendCheckMessage(msgExt);
            } catch (Exception e) {
                LOGGER.error("Send check message error!", e);
            }
        }
    });
}
```

上面的逻辑在注释中已经说明了什么时候执行事务回查，简单来说，`check()`方法获取op消息（存在op消息说明对应的事务消息的状态已经确认了，没必要回查了），之后从之前消费的位置开始获取事务消息，判断事务消息是否到了回查时间，如果是，则将事务消息重新保存到broker并发送事务消息回查请求给生产者，推进事务消息的消费进度，这样当前事务消息被认为消费了，该事务消息的副本被重新保存，使得该事务有机会在之后再次被check。生产者在收到broker发送的事务回查请求后，会回查本地事务状态并返回事务状态给broker，broker收到事务状态后会创建事务对应的op消息，这也是为什么`fillOpRemoveMap()`方法会记录op消息的消费位移和其事务消息对应的位移，目的是防止已经存在op消息的事务重复执行事务回查，同时通过`doneOpOffset`变量推进op消息的消费进度。

下面通过官方的图来说明事务消息的运行过程：

![事务消息](../resources/事务消息.png)

上面的图的箭头关联了op消息和事务消息，但是这种关联会让上面的图所表示的场景比较简单，下面利用这个图分析事务消息的运行过程，但是忽略图中的箭头，举一些比较复杂的例子：
- 一开始事务消息和op消息的队列都是空的
- 生产者发送事务消息1、2、3，同时事务消息对应的commit请求也到达了broker，此时broker会保存op消息1、2、3。
- `TransactionalMessageCheckService`执行`check()`方法，从0位置获取op消息1、2、3，同时遍历事务消息队列中的消息，从0开始遍历，由于存在op消息1、2、3，但是事务消息的消费进度是0，所以`fillOpRemoveMap()`会将op消息1、2、3对应的事务消息的位移1、2、3保存到`removeMap`变量中作为key，同时op消息自己的位移作为value。
- `check()`方法处理事务消息1时发现`removeMap`变量中存在其位置0这个key，将其位置保存到`doneOpOffset`中，之后`newOffset`变量更新为i + 1，即更新为1，之后继续循环，后面的事务消息2、3也是这个处理过程，最终`newOffset`的值为3（从位置0开始计算），`newOpOffset`的值为3，这两个值分别会被更新为事务消息的消费进度和op消息的消费进度（即下次消费时的起始位置）。
- 事务消息4到达broker，但是op消息没到，60s后`TransactionalMessageCheckService`执行`check()`方法，此时op消息队列的消费进度为3，没有需要消费的op消息，同时事务消息4到了回查时间，`check()`方法将消息4重新保存到broker并发送事务回查请求（这个例子会导致存在两条事务消息4，但是上图只显示了一个，这里这么举例只是说明事务回查的逻辑，假设上图存在两条事务消息4吧）。
- 生产者收到回查请求后发送检查事务状态并返回给broker，broker收到后创建op消息，60s后`check()`方法执行，和上面的逻辑一样，更新事务消息和op消息的消费进度为4（实际上有两个事务消息4，所以事务消息的消费进度是5，但是这里简单起见，不在意这个细节，后面的分析就假设事务消息4不需要回查，直接收到了commit请求了）。
- 生产者发送事务消息5、6、7，broker收到了事务消息7的commit请求，创建对应的op消息，没有收到5和6的。60s后`check()`方法执行，op消息从位置4开始获取，最终获取到了7，之后从位置4开始消费事务消息，从消息5开始消费，由于事务消息的消费进度为4，所以`fillOpRemoveMap()`方法执行完后`doneOpOffset`为空，`removeMap`中保存了[6, 4]（6是事务消息7在队列中的位置），此时事务消息5到了回查时间，保存事务消息5到broker并发送回查请求，再更新`newOffset`的值推进事务消息的消费进度，之后的事务消息6也是这个处理过程。到了消费事务消息7时，发现`removeMap`中保存了其位置，将其对应的op消息在队列中的位置保存到`doneOpOffset`变量中，更新`newOffset`的值推进事务消息的消费进度，此时`newOffset`的值为7（事务消息7后面那个位置）。`check()`方法将`newOffset`的值作为事务消息的消费进度，同时op消息的消费进度也被更新为5，即op消息7被认为已经消费了，最终事务消息的消费进度被推进到了事务消息7后面一个位置，op消息的消费进度被推进到了事务消息7的op消息后面一个位置。
- 生产者收到了事务消息5、6的回查请求，返回事务状态，broker收到后创建op消息。60s后`check()`方法执行，获取到了op消息5、6，并从事务消息7后面一个位置开始消费事务消息，此时最开始遍历的事务消息实际上是事务消息5，因为事务消息5在回查之前重新保存了一次，这样事务消息5、6由于存在对应的op消息，不需要回查了，消费进度也被更新了。
- 之后的处理过程也都大同小异，根据上面的描述举一反三吧。

上面是broker中事务消息的回查逻辑，关键在于事务消息5、6、7的处理，通过这种实现，broker能够在不需要关系之前事务消息的状态，也不需要关系事务消息回查请求是否能够返回的情况下，推荐事务消息和op消息的消费进度，同时限制了事务消息的回查次数，做了一个兜底，防止事务消息无限回查。

以上是rocketmq中事务消息的实现。