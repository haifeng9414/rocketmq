rocketmq提供了3种消息查询方式：           
- 按照Message Key查询：消息的key是生产者自己指定的，通常会把具有业务含义，区分度高的字段作为消息的key，如用户id，订单id等。
- 按照Unique Key查询：rocketmq生产者客户端在发送发送消息之前，会自动生成一个UNIQ_KEY，设置到消息的属性中，从逻辑上唯一代表一条消息。
- 按照Message Id查询：Message Id是消息发送后，在Broker端生成的，其包含了Broker的地址，和在CommitLog中的偏移信息，并会将Message Id作为发送结果的一部分进行返回。Message Id中属于精确匹配，可以唯一定位一条消息，不需要使用哈希索引机制，查询效率更高。

rocketmq有意弱化Unique Key与Message Id的区别，对外都称之为Message Id。在通过rocketmq的命令行工具或管理平台进行查询时，二者可以通用。在根据Unique Key进行查询时，是有可能查询到多条消息的（因为消息可以通过`mqadmin queryMsgById`命令重新发送到topic，此时消息的Unique Key不变），但是查询工具会进行过滤，只会返回一条消息。

下面先看看通过`mqadmin`命令行工具查询消息的命令：
```
$ mqadmin
The most commonly used mqadmin commands are:
    # 略...
    queryMsgById         Query Message by Id
    queryMsgByKey        Query Message by Key
    queryMsgByUniqueKey  Query Message by Unique key
    queryMsgByOffset     Query Message by offset
    # 略...
```
`mqadmin`命令有4个子命令能够查询消息，前3个子命令对应的就是开始说的3种查询方式，最后一个`queryMsgByOffset`子命令顾名思义是根据消息位移查询消息的，实现原理很简单，创建一个`DefaultMQPullConsumer`对象执行一个`pull()`方法查询指定位移的消息即可，这里就不分析该查询方式的实现了，下面看看另外3中查询方式的实现。

笔记[mqadmin命令的实现](../../tools/mqadmin命令的实现.md)对`mqadmin`命令行工具的实现做了介绍，下面介绍已经看过该笔记，对`mqadmin`命令行工具相关实现不再赘述。

## queryMsgByKey
`queryMsgByKey`子命令根据消息的key查询消息，消息的key是生产者在发送消息时设置的，如：
```java
Message msg = new Message("TopicTest" /* Topic */,
        "TagA" /* Tag */,
        ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */
);
msg.setKeys("test-key");
```

这里先看看`setKeys()`方法对`Message`对象的影响，`setKeys()`方法代码如下：
```java
public void setKeys(String keys) {
    this.putProperty(MessageConst.PROPERTY_KEYS, keys);
}

// setKeys方法也接受集合类型的参数，即能够为消息设置多个key，每个key以空格分割
public void setKeys(Collection<String> keys) {
    StringBuffer sb = new StringBuffer();
    for (String k : keys) {
        sb.append(k);
        sb.append(MessageConst.KEY_SEPARATOR);
    }

    this.setKeys(sb.toString().trim());
}
```

`setKeys()`方法将key保存到消息的属性中，属性名为`MessageConst.PROPERTY_KEYS`，即`KEYS`，当消息发送到broker，对KEYS属性的处理在`ReputMessageService`类的`doReput()`方法：
```java

```