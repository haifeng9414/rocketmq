rocketmq提供了3种消息查询方式：           
- 按照Message Key查询：消息的key是生产者自己指定的，通常会把具有业务含义，区分度高的字段作为消息的key，如用户id，订单id等。
- 按照Unique Key查询：rocketmq生产者客户端在发送发送消息之前，会自动生成一个UNIQ_KEY，设置到消息的属性中，从逻辑上唯一代表一条消息。
- 按照Message Id查询：Message Id是消息发送后，在Broker端生成的，其包含了Broker的地址，和在CommitLog中的偏移信息，并会将Message Id作为发送结果的一部分进行返回。Message Id中属于精确匹配，可以唯一定位一条消息，不需要使用哈希索引机制，查询效率更高。

rocketmq有意弱化Unique Key与Message Id的区别，对外都称之为Message Id。在通过rocketmq的命令行工具或管理平台进行查询时，二者可以通用。在根据Unique Key进行查询时，是有可能查询到多条消息的（因为消息可以通过`mqadmin queryMsgById`命令重新发送到topic，此时消息的Unique Key不变），但是查询工具会进行过滤，只会返回一条消息。

下面先看看通过`mqadmin`命令行工具查询消息的命令：
```
$ mqadmin
The most commonly used mqadmin commands are:
    # 略...
    queryMsgById         Query Message by Id
    queryMsgByKey        Query Message by Key
    queryMsgByUniqueKey  Query Message by Unique key
    queryMsgByOffset     Query Message by offset
    # 略...
```
`mqadmin`命令有4个子命令能够查询消息，前3个子命令对应的就是开始说的3种查询方式，最后一个`queryMsgByOffset`子命令顾名思义是根据消息位移查询消息的，实现原理很简单，创建一个`DefaultMQPullConsumer`对象执行一个`pull()`方法查询指定位移的消息即可，这里就不分析该查询方式的实现了，下面看看另外3中查询方式的实现。

笔记[mqadmin命令的实现](../../tools/mqadmin命令的实现.md)对`mqadmin`命令行工具的实现做了介绍，下面介绍已经看过该笔记，对`mqadmin`命令行工具相关实现不再赘述。

## queryMsgByKey
`queryMsgByKey`子命令根据消息的key查询消息，消息的key是生产者在发送消息时设置的，如：
```java
Message msg = new Message("TopicTest" /* Topic */,
        "TagA" /* Tag */,
        ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */
);
msg.setKeys("test-key");
```

这里先看看`setKeys()`方法对`Message`对象的影响，`setKeys()`方法代码如下：
```java
public void setKeys(String keys) {
    this.putProperty(MessageConst.PROPERTY_KEYS, keys);
}

// setKeys方法也接受集合类型的参数，即能够为消息设置多个key，每个key以空格分割
public void setKeys(Collection<String> keys) {
    StringBuffer sb = new StringBuffer();
    for (String k : keys) {
        sb.append(k);
        sb.append(MessageConst.KEY_SEPARATOR);
    }

    this.setKeys(sb.toString().trim());
}
```

`setKeys()`方法将key保存到消息的属性中，属性名为`MessageConst.PROPERTY_KEYS`，即`KEYS`，当消息发送到broker后，broker会将消息持久化到commitlog文件，并通过后台线程创建commitlog文件中消息的索引，这个后台线程就是`ReputMessageService`类，`ReputMessageService`类会遍历没有构建过索引的消息，并通过`CommitLogDispatcherBuildIndex`类为每个消息构建索引，关于`ReputMessageService`类的实现和`CommitLogDispatcherBuildIndex`类构建消息索引的过程，可以看笔记[如何实现消息存储](../broker/如何实现消息存储.md)，这里不再赘述。

这里分析`queryMsgByKey`子命令的执行过程，对于的处理方法是`QueryMsgByKeySubCommand`类的`execute()`方法：
```java
@Override
public void execute(CommandLine commandLine, Options options, RPCHook rpcHook) throws SubCommandException {
    DefaultMQAdminExt defaultMQAdminExt = new DefaultMQAdminExt(rpcHook);

    defaultMQAdminExt.setInstanceName(Long.toString(System.currentTimeMillis()));

    try {
        final String topic = commandLine.getOptionValue('t').trim();
        final String key = commandLine.getOptionValue('k').trim();

        this.queryByKey(defaultMQAdminExt, topic, key);
    } catch (Exception e) {
        throw new SubCommandException(this.getClass().getSimpleName() + " command failed", e);
    } finally {
        defaultMQAdminExt.shutdown();
    }
}

private void queryByKey(final DefaultMQAdminExt admin, final String topic, final String key)
    throws MQClientException, InterruptedException {
    admin.start();

    QueryResult queryResult = admin.queryMessage(topic, key, 64, 0, Long.MAX_VALUE);
    System.out.printf("%-50s %4s %40s%n",
        "#Message ID",
        "#QID",
        "#Offset");
    for (MessageExt msg : queryResult.getMessageList()) {
        System.out.printf("%-50s %4d %40d%n", msg.getMsgId(), msg.getQueueId(), msg.getQueueOffset());
    }
}
```

上面的逻辑很简单，直接调用`DefaultMQAdminExt`类的`queryMessage()`方法获取查询结果，`DefaultMQAdminExt`类的`queryMessage()`方法代码：
```java
@Override
public QueryResult queryMessage(String topic, String key, int maxNum, long begin,
    long end) throws MQClientException,
    InterruptedException {
    return defaultMQAdminExtImpl.queryMessage(topic, key, maxNum, begin, end);
}
```

又调用了`DefaultMQAdminExtImpl`类的`queryMessage()`方法：
```java
@Override
public QueryResult queryMessage(String topic, String key, int maxNum, long begin,
    long end) throws MQClientException,
    InterruptedException {
    return this.mqClientInstance.getMQAdminImpl().queryMessage(topic, key, maxNum, begin, end);
}
```

根据调用链往下，最终调用的是`MQAdminImpl`类的`queryMessage()`方法，代码：
```java
protected QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end,
    boolean isUniqKey) throws MQClientException,
    InterruptedException {
    // 获取topic的路由信息
    TopicRouteData topicRouteData = this.mQClientFactory.getAnExistTopicRouteData(topic);
    if (null == topicRouteData) {
        this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);
        topicRouteData = this.mQClientFactory.getAnExistTopicRouteData(topic);
    }

    if (topicRouteData != null) {
        List<String> brokerAddrs = new LinkedList<String>();
        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {
            // 获取master broker地址，如果没有则从slave中随机选一个
            String addr = brokerData.selectBrokerAddr();
            if (addr != null) {
                brokerAddrs.add(addr);
            }
        }

        if (!brokerAddrs.isEmpty()) {
            final CountDownLatch countDownLatch = new CountDownLatch(brokerAddrs.size());
            final List<QueryResult> queryResultList = new LinkedList<QueryResult>();
            final ReadWriteLock lock = new ReentrantReadWriteLock(false);
                
            // 遍历topic所在的broker，查询消息
            for (String addr : brokerAddrs) {
                try {
                    QueryMessageRequestHeader requestHeader = new QueryMessageRequestHeader();
                    requestHeader.setTopic(topic);
                    requestHeader.setKey(key);
                    requestHeader.setMaxNum(maxNum);
                    requestHeader.setBeginTimestamp(begin);
                    requestHeader.setEndTimestamp(end);

                    // 发送查询请求
                    this.mQClientFactory.getMQClientAPIImpl().queryMessage(addr, requestHeader, timeoutMillis * 3,
                        new InvokeCallback() {
                            @Override
                            public void operationComplete(ResponseFuture responseFuture) {
                                try {
                                    RemotingCommand response = responseFuture.getResponseCommand();
                                    if (response != null) {
                                        switch (response.getCode()) {
                                            case ResponseCode.SUCCESS: {
                                                QueryMessageResponseHeader responseHeader = null;
                                                try {
                                                    responseHeader =
                                                        (QueryMessageResponseHeader) response
                                                            .decodeCommandCustomHeader(QueryMessageResponseHeader.class);
                                                } catch (RemotingCommandException e) {
                                                    log.error("decodeCommandCustomHeader exception", e);
                                                    return;
                                                }

                                                List<MessageExt> wrappers =
                                                    MessageDecoder.decodes(ByteBuffer.wrap(response.getBody()), true);

                                                QueryResult qr = new QueryResult(responseHeader.getIndexLastUpdateTimestamp(), wrappers);
                                                try {
                                                    lock.writeLock().lock();
                                                    queryResultList.add(qr);
                                                } finally {
                                                    lock.writeLock().unlock();
                                                }
                                                break;
                                            }
                                            default:
                                                log.warn("getResponseCommand failed, {} {}", response.getCode(), response.getRemark());
                                                break;
                                        }
                                    } else {
                                        log.warn("getResponseCommand return null");
                                    }
                                } finally {
                                    countDownLatch.countDown();
                                }
                            }
                        }, isUniqKey);
                } catch (Exception e) {
                    log.warn("queryMessage exception", e);
                }

            }

            boolean ok = countDownLatch.await(timeoutMillis * 4, TimeUnit.MILLISECONDS);
            if (!ok) {
                log.warn("queryMessage, maybe some broker failed");
            }

            long indexLastUpdateTimestamp = 0;
            List<MessageExt> messageList = new LinkedList<MessageExt>();
            for (QueryResult qr : queryResultList) {
                if (qr.getIndexLastUpdateTimestamp() > indexLastUpdateTimestamp) {
                    indexLastUpdateTimestamp = qr.getIndexLastUpdateTimestamp();
                }

                for (MessageExt msgExt : qr.getMessageList()) {
                    if (isUniqKey) {
                        if (msgExt.getMsgId().equals(key)) {

                            if (messageList.size() > 0) {

                                if (messageList.get(0).getStoreTimestamp() > msgExt.getStoreTimestamp()) {

                                    messageList.clear();
                                    messageList.add(msgExt);
                                }

                            } else {

                                messageList.add(msgExt);
                            }
                        } else {
                            log.warn("queryMessage by uniqKey, find message key not matched, maybe hash duplicate {}", msgExt.toString());
                        }
                    } else {
                        String keys = msgExt.getKeys();
                        if (keys != null) {
                            boolean matched = false;
                            String[] keyArray = keys.split(MessageConst.KEY_SEPARATOR);
                            if (keyArray != null) {
                                for (String k : keyArray) {
                                    if (key.equals(k)) {
                                        matched = true;
                                        break;
                                    }
                                }
                            }

                            if (matched) {
                                messageList.add(msgExt);
                            } else {
                                log.warn("queryMessage, find message key not matched, maybe hash duplicate {}", msgExt.toString());
                            }
                        }
                    }
                }
            }

            //If namespace not null , reset Topic without namespace.
            for (MessageExt messageExt : messageList) {
                if (null != this.mQClientFactory.getClientConfig().getNamespace()) {
                    messageExt.setTopic(NamespaceUtil.withoutNamespace(messageExt.getTopic(), this.mQClientFactory.getClientConfig().getNamespace()));
                }
            }

            if (!messageList.isEmpty()) {
                return new QueryResult(indexLastUpdateTimestamp, messageList);
            } else {
                throw new MQClientException(ResponseCode.NO_MESSAGE, "query message by key finished, but no message.");
            }
        }
    }

    throw new MQClientException(ResponseCode.TOPIC_NOT_EXIST, "The topic[" + topic + "] not matched route info");
}
```

上面的逻辑很简单，获取topic的路由信息后给broker发送查询请求，对应的发送方法为`MQClientAPIImpl`类的`queryMessage()`方法：
```java
public void queryMessage(
    final String addr,
    final QueryMessageRequestHeader requestHeader,
    final long timeoutMillis,
    final InvokeCallback invokeCallback,
    final Boolean isUnqiueKey
) throws RemotingException, MQBrokerException, InterruptedException {
    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.QUERY_MESSAGE, requestHeader);
    request.addExtField(MixAll.UNIQUE_MSG_QUERY_FLAG, isUnqiueKey.toString());
    this.remotingClient.invokeAsync(MixAll.brokerVIPChannel(this.clientConfig.isVipChannelEnabled(), addr), request, timeoutMillis,
        invokeCallback);
}
```

查询消息的请求的code为`RequestCode.QUERY_MESSAGE`，broker端对应的处理方法是`QueryMessageProcessor`类的`queryMessage()`方法：
```java
public RemotingCommand queryMessage(ChannelHandlerContext ctx, RemotingCommand request)
    throws RemotingCommandException {
    final RemotingCommand response =
        RemotingCommand.createResponseCommand(QueryMessageResponseHeader.class);
    final QueryMessageResponseHeader responseHeader =
        (QueryMessageResponseHeader) response.readCustomHeader();
    final QueryMessageRequestHeader requestHeader =
        (QueryMessageRequestHeader) request
            .decodeCommandCustomHeader(QueryMessageRequestHeader.class);

    response.setOpaque(request.getOpaque());

    String isUniqueKey = request.getExtFields().get(MixAll.UNIQUE_MSG_QUERY_FLAG);
    // 如果是根据uniqKey查询消息，则设置最大查询的消息个数，默认32个
    if (isUniqueKey != null && isUniqueKey.equals("true")) {
        requestHeader.setMaxNum(this.brokerController.getMessageStoreConfig().getDefaultQueryMaxNum());
    }

    // 从DefaultMessageStore中查询消息
    final QueryMessageResult queryMessageResult =
        this.brokerController.getMessageStore().queryMessage(requestHeader.getTopic(),
            requestHeader.getKey(), requestHeader.getMaxNum(), requestHeader.getBeginTimestamp(),
            requestHeader.getEndTimestamp());
    assert queryMessageResult != null;

    // 将index文件的endTimestamp和endPhyOffset属性保存到响应的header，这两个属性分别表示index文件保存的最新的索引对应的消息
    // 的创建时间和消息位移
    responseHeader.setIndexLastUpdatePhyoffset(queryMessageResult.getIndexLastUpdatePhyoffset());
    responseHeader.setIndexLastUpdateTimestamp(queryMessageResult.getIndexLastUpdateTimestamp());

    if (queryMessageResult.getBufferTotalSize() > 0) {
        response.setCode(ResponseCode.SUCCESS);
        response.setRemark(null);

        try {
            FileRegion fileRegion =
                new QueryMessageTransfer(response.encodeHeader(queryMessageResult
                    .getBufferTotalSize()), queryMessageResult);
            ctx.channel().writeAndFlush(fileRegion).addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    queryMessageResult.release();
                    if (!future.isSuccess()) {
                        log.error("transfer query message by page cache failed, ", future.cause());
                    }
                }
            });
        } catch (Throwable e) {
            log.error("", e);
            queryMessageResult.release();
        }

        return null;
    }

    response.setCode(ResponseCode.QUERY_NOT_FOUND);
    response.setRemark("can not find message, maybe time range not correct");
    return response;
}
```

上面的查询过程实际上实现在`DefaultMessageStore`类的`queryMessage()`方法，代码：
```java
@Override
    public QueryMessageResult queryMessage(String topic, String key, int maxNum, long begin, long end) {
        QueryMessageResult queryMessageResult = new QueryMessageResult();

        long lastQueryMsgTime = end;

        for (int i = 0; i < 3; i++) {
            // 从index文件根据消息索引查询消息
            QueryOffsetResult queryOffsetResult = this.indexService.queryOffset(topic, key, maxNum, begin, lastQueryMsgTime);
            if (queryOffsetResult.getPhyOffsets().isEmpty()) {
                break;
            }

            Collections.sort(queryOffsetResult.getPhyOffsets());

            // 保存index文件的endTimestamp和endPhyOffset属性，这两个属性分别表示index文件保存的最新的索引对应的消息的创建时间和消息位移
            queryMessageResult.setIndexLastUpdatePhyoffset(queryOffsetResult.getIndexLastUpdatePhyoffset());
            queryMessageResult.setIndexLastUpdateTimestamp(queryOffsetResult.getIndexLastUpdateTimestamp());

            // 遍历查询结果，根据结果的消息位移从commitlog文件获取消息
            for (int m = 0; m < queryOffsetResult.getPhyOffsets().size(); m++) {
                long offset = queryOffsetResult.getPhyOffsets().get(m);

                try {

                    boolean match = true;
                    MessageExt msg = this.lookMessageByOffset(offset);
                    if (0 == m) {
                        lastQueryMsgTime = msg.getStoreTimestamp();
                    }

//                    String[] keyArray = msg.getKeys().split(MessageConst.KEY_SEPARATOR);
//                    if (topic.equals(msg.getTopic())) {
//                        for (String k : keyArray) {
//                            if (k.equals(key)) {
//                                match = true;
//                                break;
//                            }
//                        }
//                    }

                    if (match) {
                        SelectMappedBufferResult result = this.commitLog.getData(offset, false);
                        if (result != null) {
                            int size = result.getByteBuffer().getInt(0);
                            result.getByteBuffer().limit(size);
                            result.setSize(size);
                            queryMessageResult.addMessage(result);
                        }
                    } else {
                        log.warn("queryMessage hash duplicate, {} {}", topic, key);
                    }
                } catch (Exception e) {
                    log.error("queryMessage exception", e);
                }
            }

            if (queryMessageResult.getBufferTotalSize() > 0) {
                break;
            }

            if (lastQueryMsgTime < begin) {
                break;
            }
        }

        return queryMessageResult;
    }
```

`DefaultMessageStore`类的`queryMessage()`方法通过`IndexService`类的`queryOffset()`方法从index文件保存的索引中查询消息，`IndexService`类的`queryOffset()`方法：
```java
public QueryOffsetResult queryOffset(String topic, String key, int maxNum, long begin, long end) {
    List<Long> phyOffsets = new ArrayList<Long>(maxNum);

    long indexLastUpdateTimestamp = 0;
    long indexLastUpdatePhyoffset = 0;
    maxNum = Math.min(maxNum, this.defaultMessageStore.getMessageStoreConfig().getMaxMsgsNumBatch());
    try {
        this.readWriteLock.readLock().lock();
        if (!this.indexFileList.isEmpty()) {
            // 遍历所有的index文件，从最新的开始遍历
            for (int i = this.indexFileList.size(); i > 0; i--) {
                IndexFile f = this.indexFileList.get(i - 1);
                boolean lastFile = i == this.indexFileList.size();
                // 保存最新的index文件的endTimestamp属性和endPhyOffset属性
                if (lastFile) {
                    indexLastUpdateTimestamp = f.getEndTimestamp();
                    indexLastUpdatePhyoffset = f.getEndPhyOffset();
                }
                    
                // 如果index文件中的索引对应的消息的创建时间在指定的时间范围内，则执行查询
                if (f.isTimeMatched(begin, end)) {

                    f.selectPhyOffset(phyOffsets, buildKey(topic, key), maxNum, begin, end, lastFile);
                }

                // 之后的index文件的消息的最小创建时间肯定小于当前index文件的消息的最小创建时间，所以满足if条件时没必要再查了
                if (f.getBeginTimestamp() < begin) {
                    break;
                }

                // 满足查询的消息数量了也没必要再查了
                if (phyOffsets.size() >= maxNum) {
                    break;
                }
            }
        }
    } catch (Exception e) {
        log.error("queryMsg exception", e);
    } finally {
        this.readWriteLock.readLock().unlock();
    }

    return new QueryOffsetResult(phyOffsets, indexLastUpdateTimestamp, indexLastUpdatePhyoffset);
}
```

`IndexService`类的`queryOffset()`方法遍历所有的`IndexFile`对象，也就是遍历所有index文件，通过`IndexFile`类的`selectPhyOffset()`方法从索引中查询消息，关于`IndexFile`类的`selectPhyOffset()`方法的实现，可以看笔记[如何实现消息存储](../broker/如何实现消息存储.md)，这里只放下`selectPhyOffset()`方法的代码：
```java
// 根据key、begin、end为查询条件在索引中查找消息
public void selectPhyOffset(final List<Long> phyOffsets, final String key, final int maxNum,
    final long begin, final long end, boolean lock) {
    if (this.mappedFile.hold()) {
        // 获取key的hashCode
        int keyHash = indexKeyHashMethod(key);
        // 找到hash槽的位置
        int slotPos = keyHash % this.hashSlotNum;
        // 计算hash槽在index文件的位移
        int absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;

        FileLock fileLock = null;
        try {
            if (lock) {
                // fileLock = this.fileChannel.lock(absSlotPos,
                // hashSlotSize, true);
            }

            // 获取当前hash槽上的int值
            int slotValue = this.mappedByteBuffer.getInt(absSlotPos);
            // if (fileLock != null) {
            // fileLock.release();
            // fileLock = null;
            // }

            // 如果满足if条件说明当前hash槽没有保存消息索引
            if (slotValue <= invalidIndex || slotValue > this.indexHeader.getIndexCount()
                || this.indexHeader.getIndexCount() <= 1) {
            } else {
                // 遍历当前hash槽对应的链表
                for (int nextIndexToRead = slotValue; ; ) {
                    // 如果找到的消息数量达到了maxNum，直接返回结果
                    if (phyOffsets.size() >= maxNum) {
                        break;
                    }

                    // 计算消息a的索引在index文件的位移
                    int absIndexPos =
                        IndexHeader.INDEX_HEADER_SIZE + this.hashSlotNum * hashSlotSize
                            + nextIndexToRead * indexSize;

                    // 读取索引信息
                    int keyHashRead = this.mappedByteBuffer.getInt(absIndexPos);
                    long phyOffsetRead = this.mappedByteBuffer.getLong(absIndexPos + 4);

                    long timeDiff = (long) this.mappedByteBuffer.getInt(absIndexPos + 4 + 8);
                    // prevIndexRead的值是链表下一个节点在索引数组中的位置
                    int prevIndexRead = this.mappedByteBuffer.getInt(absIndexPos + 4 + 8 + 4);

                    if (timeDiff < 0) {
                        break;
                    }

                    timeDiff *= 1000L;

                    // 计算消息的保存时间
                    long timeRead = this.indexHeader.getBeginTimestamp() + timeDiff;
                    boolean timeMatched = (timeRead >= begin) && (timeRead <= end);

                    // 如果正在找的key的hashCode和当前索引的hashCode相等，并且索引的消息的保存时间在指定范围内，则保存消息的
                    // 位移到结果集
                    // 需要注意的是，这里只是判断hashCode是否相等，不同的消息的key的hashCode是可能相同的，所以消费者在根据索引查询到
                    // 消息后，还得根据key的实际内容进行过滤
                    if (keyHash == keyHashRead && timeMatched) {
                        phyOffsets.add(phyOffsetRead);
                    }

                    // 满足条件说明链表到头了，或者当timeRead < begin时，表示当前索引的消息的保存时间小于正在寻找的时间范围的起始
                    // 值，此时没必要再寻找了，链表后面的索引肯定都timeRead < begin，因为index文件中链表节点越接近链表头，消息保存时间越大
                    if (prevIndexRead <= invalidIndex
                        || prevIndexRead > this.indexHeader.getIndexCount()
                        || prevIndexRead == nextIndexToRead || timeRead < begin) {
                        break;
                    }

                    // 继续寻找下一个链表节点
                    nextIndexToRead = prevIndexRead;
                }
            }
        } catch (Exception e) {
            log.error("selectPhyOffset exception ", e);
        } finally {
            if (fileLock != null) {
                try {
                    fileLock.release();
                } catch (IOException e) {
                    log.error("Failed to release the lock", e);
                }
            }

            this.mappedFile.release();
        }
    }
}
```

## queryMsgByUniqueKey
`queryMsgByUniqueKey`子命令根据消息的uniqKey查询消息，消息的uniqKey是生产者在发送消息时自动生成的，下面看看这个uniqKey是如何生成的。

前面的过程就不再啰嗦，生成消息的uniqKey的逻辑在`DefaultMQProducerImpl`类的`sendKernelImpl()`方法，所有生产者的实现最终都会调用这个方法，该方法代码：
```java
private SendResult sendKernelImpl(final Message msg,
    final MessageQueue mq,
    final CommunicationMode communicationMode,
    final SendCallback sendCallback,
    final TopicPublishInfo topicPublishInfo,
    final long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
    long beginStartTime = System.currentTimeMillis();
    // 获取brokerName对应的master broker的地址
    String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());
    if (null == brokerAddr) {
        // 如果为空则更新路由信息，再获取一次地址
        tryToFindTopicPublishInfo(mq.getTopic());
        brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());
    }

    SendMessageContext context = null;
    if (brokerAddr != null) {
        // 如果vipChannelEnabled为true，将端口改为10909而不是原先的10911，这就是vip channel，每个broker都有一个对应的
        // vip remote server，也就是fastRemotingServer
        brokerAddr = MixAll.brokerVIPChannel(this.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);

        // 获取消息体
        byte[] prevBody = msg.getBody();
        try {
            //for MessageBatch,ID has been set in the generating process
            if (!(msg instanceof MessageBatch)) {
                // 如果不是批量消息，并且当前Message对象的属性列表中的UNIQ_KEY属性为空，则添加一个该属性，属性值为根据时间戳、
                // ip、counter等信息计算的字符串
                MessageClientIDSetter.setUniqID(msg);
            }

            boolean topicWithNamespace = false;
            // 设置namespace到instanceId
            if (null != this.mQClientFactory.getClientConfig().getNamespace()) {
                msg.setInstanceId(this.mQClientFactory.getClientConfig().getNamespace());
                topicWithNamespace = true;
            }

            int sysFlag = 0;
            boolean msgBodyCompressed = false;
            if (this.tryToCompressMessage(msg)) {
                // 添加压缩表示
                sysFlag |= MessageSysFlag.COMPRESSED_FLAG;
                msgBodyCompressed = true;
            }

            // 如果是事务消息，则添加相关标识
            final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);
            if (tranMsg != null && Boolean.parseBoolean(tranMsg)) {
                sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;
            }

            // 如果存在CheckForbiddenHook，则遍历并调用checkForbidden方法
            if (hasCheckForbiddenHook()) {
                CheckForbiddenContext checkForbiddenContext = new CheckForbiddenContext();
                checkForbiddenContext.setNameSrvAddr(this.defaultMQProducer.getNamesrvAddr());
                checkForbiddenContext.setGroup(this.defaultMQProducer.getProducerGroup());
                checkForbiddenContext.setCommunicationMode(communicationMode);
                checkForbiddenContext.setBrokerAddr(brokerAddr);
                checkForbiddenContext.setMessage(msg);
                checkForbiddenContext.setMq(mq);
                checkForbiddenContext.setUnitMode(this.isUnitMode());
                this.executeCheckForbiddenHook(checkForbiddenContext);
            }

            // 如果存在SendMessageHook，则遍历并调用sendMessageBefore方法
            if (this.hasSendMessageHook()) {
                context = new SendMessageContext();
                context.setProducer(this);
                context.setProducerGroup(this.defaultMQProducer.getProducerGroup());
                context.setCommunicationMode(communicationMode);
                context.setBornHost(this.defaultMQProducer.getClientIP());
                context.setBrokerAddr(brokerAddr);
                context.setMessage(msg);
                context.setMq(mq);
                context.setNamespace(this.defaultMQProducer.getNamespace());
                String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);
                if (isTrans != null && isTrans.equals("true")) {
                    context.setMsgType(MessageType.Trans_Msg_Half);
                }

                if (msg.getProperty("__STARTDELIVERTIME") != null || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != null) {
                    context.setMsgType(MessageType.Delay_Msg);
                }
                this.executeSendMessageHookBefore(context);
            }

            SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();
            requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());
            requestHeader.setTopic(msg.getTopic());
            requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey());
            requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums());
            requestHeader.setQueueId(mq.getQueueId());
            requestHeader.setSysFlag(sysFlag);
            requestHeader.setBornTimestamp(System.currentTimeMillis());
            requestHeader.setFlag(msg.getFlag());
            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));
            requestHeader.setReconsumeTimes(0);
            requestHeader.setUnitMode(this.isUnitMode());
            requestHeader.setBatch(msg instanceof MessageBatch);
            // 如果是发向retry的topic，则记录重试次数
            if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);
                if (reconsumeTimes != null) {
                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));
                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);
                }

                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);
                if (maxReconsumeTimes != null) {
                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));
                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);
                }
            }

            SendResult sendResult = null;
            switch (communicationMode) {
                case ASYNC:
                    Message tmpMessage = msg;
                    boolean messageCloned = false;
                    if (msgBodyCompressed) {
                        //If msg body was compressed, msgbody should be reset using prevBody.
                        //Clone new message using commpressed message body and recover origin massage.
                        //Fix bug:https://github.com/apache/rocketmq-externals/issues/66
                        tmpMessage = MessageAccessor.cloneMessage(msg);
                        messageCloned = true;
                        msg.setBody(prevBody);
                    }

                    if (topicWithNamespace) {
                        if (!messageCloned) {
                            tmpMessage = MessageAccessor.cloneMessage(msg);
                            messageCloned = true;
                        }
                        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace()));
                    }

                    // 判断是否超时
                    long costTimeAsync = System.currentTimeMillis() - beginStartTime;
                    if (timeout < costTimeAsync) {
                        throw new RemotingTooMuchRequestException("sendKernelImpl call timeout");
                    }

                    // 发送消息
                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(
                        brokerAddr,
                        mq.getBrokerName(),
                        tmpMessage,
                        requestHeader,
                        timeout - costTimeAsync,
                        communicationMode,
                        sendCallback,
                        topicPublishInfo,
                        this.mQClientFactory,
                        this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),
                        context,
                        this);
                    break;
                case ONEWAY:
                case SYNC:
                    long costTimeSync = System.currentTimeMillis() - beginStartTime;
                    if (timeout < costTimeSync) {
                        throw new RemotingTooMuchRequestException("sendKernelImpl call timeout");
                    }
                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(
                        brokerAddr,
                        mq.getBrokerName(),
                        msg,
                        requestHeader,
                        timeout - costTimeSync,
                        communicationMode,
                        context,
                        this);
                    break;
                default:
                    assert false;
                    break;
            }

            // 如果存在SendMessageHook，则遍历并调用sendMessageAfter方法
            if (this.hasSendMessageHook()) {
                context.setSendResult(sendResult);
                this.executeSendMessageHookAfter(context);
            }

            return sendResult;
        } catch (RemotingException e) {
            if (this.hasSendMessageHook()) {
                context.setException(e);
                this.executeSendMessageHookAfter(context);
            }
            throw e;
        } catch (MQBrokerException e) {
            if (this.hasSendMessageHook()) {
                context.setException(e);
                this.executeSendMessageHookAfter(context);
            }
            throw e;
        } catch (InterruptedException e) {
            if (this.hasSendMessageHook()) {
                context.setException(e);
                this.executeSendMessageHookAfter(context);
            }
            throw e;
        } finally {
            msg.setBody(prevBody);
            msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace()));
        }
    }

    throw new MQClientException("The broker[" + mq.getBrokerName() + "] not exist", null);
}
```

关于uniqKey的生成逻辑是：
```java
//for MessageBatch,ID has been set in the generating process
if (!(msg instanceof MessageBatch)) {
    // 如果不是批量消息，并且当前Message对象的属性列表中的UNIQ_KEY属性为空，则添加一个该属性，属性值为根据时间戳、
    // ip、counter等信息计算的字符串
    MessageClientIDSetter.setUniqID(msg);
}
```

`MessageClientIDSetter`类的`setUniqID()`方法：
```java
public static void setUniqID(final Message msg) {
    if (msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX) == null) {
        msg.putProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, createUniqID());
    }
}

public static String createUniqID() {
    StringBuilder sb = new StringBuilder(LEN * 2);
    sb.append(FIX_STRING);
    sb.append(UtilAll.bytes2string(createUniqIDBuffer()));
    return sb.toString();
}
```

`createUniqID()`方法使用的`FIX_STRING`在`MessageClientIDSetter`类的静态代码块被初始化：
```java
static {
    byte[] ip;
    try {
        ip = UtilAll.getIP();
    } catch (Exception e) {
        // 如果获取ip失败，则使用时间戳构造一个假ip
        ip = createFakeIP();
    }
    LEN = ip.length + 2 + 4 + 4 + 2;
    // 下面的数据长度就是ip.length + 2 + 4，由于pid都不会太大，所以2个字节就够了
    ByteBuffer tempBuffer = ByteBuffer.allocate(ip.length + 2 + 4);
    tempBuffer.position(0);
    tempBuffer.put(ip); // 添加ip地址
    tempBuffer.position(ip.length);
    tempBuffer.putInt(UtilAll.getPid()); // 添加pid
    tempBuffer.position(ip.length + 2);
    tempBuffer.putInt(MessageClientIDSetter.class.getClassLoader().hashCode()); // 添加classLoader的hashCode
    FIX_STRING = UtilAll.bytes2string(tempBuffer.array());
    setStartTime(System.currentTimeMillis());
    COUNTER = new AtomicInteger(0);
}
```

从上面的代码可知，`FIX_STRING`由ip地址、pid和classLoader的hashCode组成，静态代码块初始化了一个原子类`COUNTER`，该类在构建uniqKey的过程中也会用到。

`createUniqID()`方法在append`FIX_STRING`之后，又append了`createUniqIDBuffer()`方法返回结果的字符串值，`createUniqIDBuffer()`方法代码：
```java
private static byte[] createUniqIDBuffer() {
    ByteBuffer buffer = ByteBuffer.allocate(4 + 2);
    long current = System.currentTimeMillis();
    // 默认每隔一个月重新设置启动时间
    if (current >= nextStartTime) {
        setStartTime(current);
    }
    buffer.position(0);
    buffer.putInt((int) (System.currentTimeMillis() - startTime)); // 放置当前时间和broker启动时间的差值
    buffer.putShort((short) COUNTER.getAndIncrement()); // 添加并自增COUNTER值
    return buffer.array();
}
```

以上是消息的uniqKey的构建过程，关于使用uniqKey查询的过程，实际上和上面分析的根据消息的KEYS属性查询一样，这里不再赘述。

## queryMsgById