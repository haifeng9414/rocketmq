消息消费分为并发消费和顺序消费，消费前获取消息的方式又分为push和pull，一般情况下使用的是并发push的方式消费，demo：
```java
public class Consumer {
	public static void main(String[] args) throws InterruptedException, MQClientException {

    	// 实例化消费者
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name");

    	// 设置NameServer的地址
        consumer.setNamesrvAddr("localhost:9876");

    	// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息
        consumer.subscribe("TopicTest", "*");
    	// 注册回调实现类来处理从broker拉取回来的消息
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
                System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);
                // 标记该消息已经被成功消费
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        // 启动消费者实例
        consumer.start();
        System.out.printf("Consumer Started.%n");
	}
}
```

顺序消费指的是可以按照消息的发送顺序来消费(FIFO)，RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。关于顺序消费的解析，在笔记[如何实现顺序消费](如何实现顺序消费.md)，这里不再赘述。

pull方式获取消息进行消费的demo如下：
```java
public class PullConsumer {
    private static final Map<MessageQueue, Long> OFFSE_TABLE = new HashMap<MessageQueue, Long>();

    public static void main(String[] args) throws MQClientException {
        DefaultMQPullConsumer consumer = new DefaultMQPullConsumer("please_rename_unique_group_name_5");
        consumer.setNamesrvAddr("127.0.0.1:9876");
        consumer.start();

        Set<MessageQueue> mqs = consumer.fetchSubscribeMessageQueues("broker-a");
        for (MessageQueue mq : mqs) {
            System.out.printf("Consume from the queue: %s%n", mq);
            SINGLE_MQ:
            while (true) {
                try {
                    PullResult pullResult =
                        consumer.pullBlockIfNotFound(mq, null, getMessageQueueOffset(mq), 32);
                    System.out.printf("%s%n", pullResult);
                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());
                    switch (pullResult.getPullStatus()) {
                        case FOUND:
                            break;
                        case NO_MATCHED_MSG:
                            break;
                        case NO_NEW_MSG:
                            break SINGLE_MQ;
                        case OFFSET_ILLEGAL:
                            break;
                        default:
                            break;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        consumer.shutdown();
    }

    private static long getMessageQueueOffset(MessageQueue mq) {
        Long offset = OFFSE_TABLE.get(mq);
        if (offset != null)
            return offset;

        return 0;
    }

    private static void putMessageQueueOffset(MessageQueue mq, long offset) {
        OFFSE_TABLE.put(mq, offset);
    }

}
```


下面来push和pull方式消费消息的实现，首先是push模式，对应的实现类是`DefaultMQPushConsumer`，`DefaultMQPushConsumer`类和[如何实现消息发送](如何实现消息发送.md)中分析的`DefaultMQProducer`类似，虽然实现了`MQPushConsumer`接口，但是实际上`MQPushConsumer`接口的实现是通过`DefaultMQPushConsumer`的成员变量`DefaultMQPushConsumerImpl`完成的，`DefaultMQPushConsumer`类的主要功能是定义若干个消费者相关的配置属性，并继承`ClientConfig`类从而获得管理消费者和客户端配置的能力，`DefaultMQPushConsumerImpl`类也会通过其所在的`DefaultMQPushConsumer`类获取客户端配置，从而影响其运行逻辑。这里直接看`DefaultMQPushConsumer`类的构造函数：
```java
public DefaultMQPushConsumer(final String consumerGroup) {
    this(null, consumerGroup, null, new AllocateMessageQueueAveragely());
}

public DefaultMQPushConsumer(final String namespace, final String consumerGroup, RPCHook rpcHook,
    AllocateMessageQueueStrategy allocateMessageQueueStrategy) {
    this.consumerGroup = consumerGroup;
    this.namespace = namespace;
    // 负载均衡算法，默认为取模平均
    this.allocateMessageQueueStrategy = allocateMessageQueueStrategy;
    // DefaultMQPushConsumer的大部分方法实际上就是调用DefaultMQPushConsumerImpl的相应方法实现的
    defaultMQPushConsumerImpl = new DefaultMQPushConsumerImpl(this, rpcHook);
}
```

`DefaultMQPushConsumer`类的其他代码直接看该类的源码注释，这里不再赘述，下面来看使用push模式时使用`DefaultMQPushConsumer`对象需要执行的步骤，首先是`DefaultMQPushConsumer`对象的属性设置：
```java
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name_4");

consumer.setNamesrvAddr("127.0.0.1:9876");
consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
consumer.subscribe("TopicTest", "*");

consumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                    ConsumeConcurrentlyContext context) {
        if (CollectionUtils.isNotEmpty(msgs)) {
            final List<String> msgBodies = msgs.stream().map((item) -> new String(item.getBody())).collect(Collectors.toList());

            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgBodies);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }

        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
});
```

`setNamesrvAddr()`和`setConsumeFromWhere()`方法分别定义在`ClientConfig`和`DefaultMQPushConsumer`类，用于设置namesrv的地址和消费消息时的起始位置：
```java
public void setNamesrvAddr(String namesrvAddr) {
    this.namesrvAddr = namesrvAddr;
}

public void setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) {
    this.consumeFromWhere = consumeFromWhere;
}
```

`subscribe()`方法用于设置消费者的订阅配置，实现在`DefaultMQPushConsumer`类：
```java
public void subscribe(String topic, String subExpression) throws MQClientException {
    this.defaultMQPushConsumerImpl.subscribe(withNamespace(topic), subExpression);
}

public String withNamespace(String resource) {
    return NamespaceUtil.wrapNamespace(this.getNamespace(), resource);
}

// resourceWithOutNamespace通常是某个topic，如果namespace为空或者resourceWithOutNamespace为空则直接
// 返回resourceWithOutNamespace，否则如果resourceWithOutNamespace是rocketmq内置的topic则直接返回
// 如果以上条件都不满足，则判断resourceWithOutNamespace是否是%RETRY%或%DLQ%开头的，即是否是重试队列或者
// 死信队列的topic，如果是则返回%RETRY%或%DLQ% + namespace%resourceWithoutRetryAndDLQ形式的字符串，
// 否则返回namespace%resourceWithoutRetryAndDLQ
// 即主要目的是在namespace不为空的情况下在resourceWithOutNamespace前加上namespace并返回
public static String wrapNamespace(String namespace, String resourceWithOutNamespace) {
    if (StringUtils.isEmpty(namespace) || StringUtils.isEmpty(resourceWithOutNamespace)) {
        return resourceWithOutNamespace;
    }

    if (isSystemResource(resourceWithOutNamespace) || isAlreadyWithNamespace(resourceWithOutNamespace, namespace)) {
        return resourceWithOutNamespace;
    }

    String resourceWithoutRetryAndDLQ = withOutRetryAndDLQ(resourceWithOutNamespace);
    StringBuffer strBuffer = new StringBuffer();

    if (isRetryTopic(resourceWithOutNamespace)) {
        strBuffer.append(MixAll.RETRY_GROUP_TOPIC_PREFIX);
    }

    if (isDLQTopic(resourceWithOutNamespace)) {
        strBuffer.append(MixAll.DLQ_GROUP_TOPIC_PREFIX);
    }

    return strBuffer.append(namespace).append(NAMESPACE_SEPARATOR).append(resourceWithoutRetryAndDLQ).toString();

}
```

`subscribe()`方法中用到的`withNamespace()`方法主要是用于支持按照namespace隔离客户端，通常namespace为空。`subscribe()`方法的真正实现在`DefaultMQPushConsumerImpl`类：
```java
// 订阅主题，subExpression参数为订阅的消息标签，如'*'、'tagA'等
public void subscribe(String topic, String subExpression) throws MQClientException {
    try {
        // 根据消费者的参数创建SubscriptionData对象，该对象保存了消费者订阅的topic和该topic的标签配置，即
        // 一个SubscriptionData对象表示消费者的某个topic订阅
        SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
            topic, subExpression);
        // 保存订阅配置
        this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
        if (this.mQClientFactory != null) {
            // 向broker发送心跳，心跳中会包含消费者的组名和消费配置、订阅配置
            this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}
```

可以看到，`subscribe()`方法主要用于保存消费者的订阅配置到`RebalanceImpl`对象（该对象和消费者的负载均衡有关），并向broker发送心跳，使得所有的broker能够知道消费者的配置。

`registerMessageListener()`方法则是用于注册消息处理器：
```java
@Override
public void registerMessageListener(MessageListenerConcurrently messageListener) {
    this.messageListener = messageListener;
    this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);
}

// 注册消息的处理对象
public void registerMessageListener(MessageListener messageListener) {
    this.messageListenerInner = messageListener;
}
```

最后是`start()`方法：
```java
@Override
public void start() throws MQClientException {
    // 如果namespace不为空，则以namespace%consumerGroup的格式创建新的consumerGroup
    setConsumerGroup(NamespaceUtil.wrapNamespace(this.getNamespace(), this.consumerGroup));
    this.defaultMQPushConsumerImpl.start();
    if (null != traceDispatcher) {
        try {
            traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel());
        } catch (MQClientException e) {
            log.warn("trace dispatcher start failed ", e);
        }
    }
}

// defaultMQPushConsumerImpl的start()方法
public synchronized void start() throws MQClientException {
    switch (this.serviceState) {
        case CREATE_JUST:
            log.info("the consumer [{}] start beginning. messageModel={}, isUnitMode={}", this.defaultMQPushConsumer.getConsumerGroup(),
                this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());
            // 设置状态为启动失败，如果启动过程正常执行，则会在最后更新成Running状态
            this.serviceState = ServiceState.START_FAILED;

            // 检查当前参数是否合法
            this.checkConfig();

            // defaultMQPushConsumer的subscription属性以Map的形式保存了消费者的订阅配置，copySubscription方法根据subscription
            // 属性的值创建SubscriptionData对象并保存到rebalanceImpl对象，同时添加consumeGroup的retry topic的订阅，即订阅
            // %RETRY%consumerGroupName这个topic
            this.copySubscription();

            if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {
                // 设置defaultMQPushConsumer的instanceName属性为pid
                this.defaultMQPushConsumer.changeInstanceNameToPID();
            }

            // mQClientFactory对象实现了真正需要发送网络请求的方法
            this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);

            // 配置负载均衡

            // 消费组
            this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());
            // 广播模式还是集群模式
            this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());
            // 负载均衡策略
            this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());
            this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);

            // 拉取消息的实现类
            this.pullAPIWrapper = new PullAPIWrapper(
                mQClientFactory,
                this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());
            this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);

            // offsetStore用于持久化已经消费的队列的consumeOffset
            if (this.defaultMQPushConsumer.getOffsetStore() != null) {
                this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();
            } else {
                // 没有设置offsetStore的实现则使用默认实现
                switch (this.defaultMQPushConsumer.getMessageModel()) {
                    case BROADCASTING:
                        // 广播模式offset保存在本地
                        this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
                        break;
                    case CLUSTERING:
                        // 集群模式offset保存在broker
                        this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
                        break;
                    default:
                        break;
                }
                this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);
            }
            // 获取之前持久化的offset
            this.offsetStore.load();

            // ConsumeMessageService负责持有和配置消费消息的线程池
            if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {
                this.consumeOrderly = true;
                this.consumeMessageService =
                    new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
            } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {
                this.consumeOrderly = false;
                this.consumeMessageService =
                    new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
            }

            // 启动定时任务定时调用consumeMessageService的cleanExpireMsg方法
            this.consumeMessageService.start();

            // 绑定consumerGroup和当前DefaultMQPushConsumerImpl对象的关系
            boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);
            if (!registerOK) {
                // 一个rocketmq进程内consumerGroup和DefaultMQPushConsumerImpl对象一一对应，如果存在多个DefaultMQPushConsumerImpl
                // 对象对应一个consumerGroup则报错
                this.serviceState = ServiceState.CREATE_JUST;
                this.consumeMessageService.shutdown();
                throw new MQClientException("The consumer group[" + this.defaultMQPushConsumer.getConsumerGroup()
                    + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                    null);
            }

            // 启动netty、拉取消息的线程、负载均衡线程、各种定时任务
            mQClientFactory.start();
            log.info("the consumer [{}] start OK.", this.defaultMQPushConsumer.getConsumerGroup());
            this.serviceState = ServiceState.RUNNING;
            break;
        case RUNNING:
        case START_FAILED:
        case SHUTDOWN_ALREADY:
            throw new MQClientException("The PushConsumer service state not OK, maybe started once, "
                + this.serviceState
                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),
                null);
        default:
            break;
    }

    // 从namesrv更新topic路由信息，并将路由信息保存到rebalanceImpl的topicSubscribeInfoTable属性
    this.updateTopicSubscribeInfoWhenSubscriptionChanged();
    // 遍历所有的SubscriptionData订阅配置，如果订阅时设置了tag，则根据topic获取TopicRouteData，并随机从TopicRouteData中选择一个
    // broker发送RequestCode.CHECK_CLIENT_CONFIG请求检查broker是否支持tag表达式
    this.mQClientFactory.checkClientInBroker();
    // 向所有broker发送心跳
    this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
    // 立即唤醒rebalanceService使其执行this.mqClientFactory.doRebalance()语句
    this.mQClientFactory.rebalanceImmediately();
}
```

`DefaultMQPushConsumerImpl`类的`start()`方法做了很多初始化操作，这里逐个分析，首先是`copySubscription()`方法：
```java
// defaultMQPushConsumer的subscription属性以Map的形式保存了消费者的订阅配置，copySubscription方法根据subscription
// 属性的值创建SubscriptionData对象并保存到rebalanceImpl对象，同时添加consumeGroup的retry topic的订阅，即订阅
// %RETRY%consumerGroupName这个topic
this.copySubscription();

private void copySubscription() throws MQClientException {
    try {
        // 如果defaultMQPushConsumer对象设置了subscription属性，即通过map设置了消费者的订阅配置，则
        // 将根据这些配置创建SubscriptionData对象并保存到rebalanceImpl，这一过程和DefaultMQPushConsumerImpl
        // 的subscribe方法一样
        Map<String, String> sub = this.defaultMQPushConsumer.getSubscription();
        if (sub != null) {
            for (final Map.Entry<String, String> entry : sub.entrySet()) {
                final String topic = entry.getKey();
                final String subString = entry.getValue();
                // 一个SubscriptionData对象表示消费者的一个订阅配置，即一个SubscriptionData对应一个topic和消费者设置的
                // topic的标签
                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                    topic, subString);
                this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
            }
        }

        // 设置消息处理器
        if (null == this.messageListenerInner) {
            this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();
        }

        switch (this.defaultMQPushConsumer.getMessageModel()) {
            case BROADCASTING:
                break;
            case CLUSTERING:
                // 获取retry的topic，格式为%RETRY%consumerGroup
                final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());
                // 订阅retry的消息
                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                    retryTopic, SubscriptionData.SUB_ALL);
                this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);
                break;
            default:
                break;
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}
```

`copySubscription()`方法首先解析`DefaultMQPushConsumer`类的`subscription`属性，将key和value作为topic和标签创建`SubscriptionData`对象，并将`SubscriptionData`对象保存到`RebalanceImpl`类，而`RebalanceImpl`类用于实现消费者之间的负载均衡，关于负载均衡可以看笔记[如何实现负载均衡](如何实现负载均衡.md)。

之后`copySubscription()`方法设置了`MessageListener`，并订阅了当前消费者组对应的retry topic，`MessageListener`就是demo中写的消息处理器，用于消费消息：
```java
consumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                    ConsumeConcurrentlyContext context) {
        if (CollectionUtils.isNotEmpty(msgs)) {
            final List<String> msgBodies = msgs.stream().map((item) -> new String(item.getBody())).collect(Collectors.toList());

            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgBodies);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }

        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
})
```

在`copySubscription()`方法之后，`start()`方法初始化了若干成员变量，调用了`OffsetStore`类的`load()`方法来加载消费位移，消费者开始消费消息时会从该位移开始消费。对于集群模式，`OffsetStore`类的实现是`RemoteBrokerOffsetStore`，其`load()`方法为空，因为集群模式的消费位移保存在Broker，并且只支持3种消费位移的设置方式，所以不需要加载消费位移：
- CONSUME_FROM_LAST_OFFSET 队列尾消费，即忽略历史消息
- CONSUME_FROM_FIRST_OFFSET 队列头消费，即从未过期的消息开始
- CONSUME_FROM_TIMESTAMP 按照日期选择某个位置消费，默认半个小时前的消息开始消费

在调用`load()`方法之后调用了`this.consumeMessageService.start();`语句，如果不是顺序消费消息，则`ConsumeMessageService`的实现类是`ConsumeMessageConcurrentlyService`，该类的实现在下面会分析。如果消费者顺序消费消息，则`ConsumeMessageService`的实现类是`ConsumeMessageOrderlyService`，该类的实现可以看笔记[如何实现顺序消费](如何实现顺序消费.md)。

最后是`mQClientFactory.start();`，该方法主要是启动定时任务，初始化网络连接等，也就是在该方法运行之后，消费者监听消息的过程就开始了：
```java
public void start() throws MQClientException {

    synchronized (this) {
        switch (this.serviceState) {
            case CREATE_JUST:
                // 更新状态
                this.serviceState = ServiceState.START_FAILED;
                // If not specified,looking address from name server
                // 从环境变量中获取namesrv的地址，如果获取不到则从默认url抓取namesrv地址
                if (null == this.clientConfig.getNamesrvAddr()) {
                    this.mQClientAPIImpl.fetchNameServerAddr();
                }
                // Start request-response channel
                // MQClientAPIImpl实现了真正发送各种网络请求的逻辑，必然用到了netty，这里的start方法实际上是调用
                // NettyRemotingClient的start方法创建netty的Bootstrap
                this.mQClientAPIImpl.start();
                // Start various schedule tasks
                // 开启定时任务，最主要的是更新路由信息，发送心跳等
                this.startScheduledTask();
                // Start pull service
                // pullMessageService是个无限循环的线程，负责从指定队列拉取消息
                this.pullMessageService.start();
                // Start rebalance service
                // rebalanceService是个无限循环的线程，以固定间隔调用当前类的doRebalance方法
                this.rebalanceService.start();
                // Start push service
                // 启动productGroup为MixAll.CLIENT_INNER_PRODUCER_GROUP的内置生产者，注意这里传入的startFactory参数为false，
                // 因为内置生产者不需要启动上面这几个线程和定时任务
                // defaultMQProducer主要用于在消息消费失败时发送消息给broker以实现消息重试
                this.defaultMQProducer.getDefaultMQProducerImpl().start(false);
                log.info("the client factory [{}] start OK", this.clientId);
                this.serviceState = ServiceState.RUNNING;
                break;
            case START_FAILED:
                throw new MQClientException("The Factory object[" + this.getClientId() + "] has been created before, and failed.", null);
            default:
                break;
        }
    }
}
```

`MQClientInstance`类的`start()`方法中关于初始化网络连接的过程由`this.mQClientAPIImpl.start();`实现，这个在笔记[remoting模块的作用和实现](../公共组件/remoting模块的作用和实现.md)中分析过了，对于消费者来说，比较关键的是`this.pullMessageService.start();`和`this.rebalanceService.start();`语句，分别用于实现拉取消息和实现负载均衡，下面先看`this.pullMessageService.start();`和消息拉取的实现过程。

`PullMessageService`的实现类就是`PullMessageService`，初始化在`MQClientInstance`的构造函数：
```java
public MQClientInstance(ClientConfig clientConfig, int instanceIndex, String clientId, RPCHook rpcHook) {
    // 略...

    this.pullMessageService = new PullMessageService(this);

    // 略...
}
```

`PullMessageService`类继承自`ServiceThread`类，所以其本质上是个线程类，其`run()`方法代码：
```java
@Override
public void run() {
    log.info(this.getServiceName() + " service started");

    while (!this.isStopped()) {
        try {
            PullRequest pullRequest = this.pullRequestQueue.take();
            this.pullMessage(pullRequest);
        } catch (InterruptedException ignored) {
        } catch (Exception e) {
            log.error("Pull Message Service Run Method exception", e);
        }
    }

    log.info(this.getServiceName() + " service end");
}
```

`pullRequestQueue`为阻塞队列`LinkedBlockingQueue`，上面的实现就是不断从阻塞队列获取元素并消费。初始情况下该队列为空，`PullMessageService`类中的`executePullRequestLater()`和`executePullRequestImmediately()`方法会添加`PullRequest`对象到该队列，下面来看看这两个方法是如何被调用的。

`PullRequest`对象代表的是一个拉取请求，其创建过程实际上是在消费者的负载均衡中实现的，在`MQClientInstance`类的`start()`方法中调用完`this.pullMessageService.start();`之后调用了`this.rebalanceService.start();`语句，该语句就开启了消费者的负载均衡，`RebalanceService`类也继承自`ServiceThread`，其实现非常简单：
```java
public class RebalanceService extends ServiceThread {
    private static long waitInterval =
        Long.parseLong(System.getProperty(
            "rocketmq.client.rebalance.waitInterval", "20000"));
    private final InternalLogger log = ClientLogger.getLog();
    private final MQClientInstance mqClientFactory;

    public RebalanceService(MQClientInstance mqClientFactory) {
        this.mqClientFactory = mqClientFactory;
    }

    @Override
    public void run() {
        log.info(this.getServiceName() + " service started");

        while (!this.isStopped()) {
            this.waitForRunning(waitInterval);
            this.mqClientFactory.doRebalance();
        }

        log.info(this.getServiceName() + " service end");
    }

    @Override
    public String getServiceName() {
        return RebalanceService.class.getSimpleName();
    }
}
```

可以看到，就是定时调用`MQClientInstance`的`doRebalance()`方法，下面再看看`doRebalance()`方法的实现：
```java
public void doRebalance() {
    for (Map.Entry<String, MQConsumerInner> entry : this.consumerTable.entrySet()) {
        MQConsumerInner impl = entry.getValue();
        if (impl != null) {
            try {
                impl.doRebalance();
            } catch (Throwable e) {
                log.error("doRebalance exception", e);
            }
        }
    }
}
```

`MQClientInstance`在之前的笔记说过，该实例默认情况下在一个进程内是单例的，而其`consumerTable`属性保存的是所有注册到该`MQClientInstance`实例的`DefaultMQPushConsumerImpl`对象，`DefaultMQPushConsumerImpl`对象的`start()`方法有如下代码段：
```java
public synchronized void start() throws MQClientException {
    switch (this.serviceState) {
        case CREATE_JUST:
            // 略...

            if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {
                // 设置defaultMQPushConsumer的instanceName属性为pid
                this.defaultMQPushConsumer.changeInstanceNameToPID();
            }

            // mQClientFactory对象实现了真正需要发送网络请求的方法
            this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);

            // 略...

            // 绑定consumerGroup和当前DefaultMQPushConsumerImpl对象的关系
            boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);
            if (!registerOK) {
                // 一个rocketmq进程内consumerGroup和DefaultMQPushConsumerImpl对象一一对应，如果存在多个DefaultMQPushConsumerImpl
                // 对象对应一个consumerGroup则报错
                this.serviceState = ServiceState.CREATE_JUST;
                this.consumeMessageService.shutdown();
                throw new MQClientException("The consumer group[" + this.defaultMQPushConsumer.getConsumerGroup()
                    + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                    null);
            }
            
            // 略...
            break;
        case RUNNING:
        case START_FAILED:
        case SHUTDOWN_ALREADY:
            throw new MQClientException("The PushConsumer service state not OK, maybe started once, "
                + this.serviceState
                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),
                null);
        default:
            break;
    }
    // 略...
}
```

`DefaultMQPushConsumerImpl`对象的`start()`方法在获取到`MQClientInstance`对象后，会调用`registerConsumer()`方法将自己注册到`MQClientInstance`对象，代码：
```java
public boolean registerConsumer(final String group, final MQConsumerInner consumer) {
    if (null == group || null == consumer) {
        return false;
    }

    MQConsumerInner prev = this.consumerTable.putIfAbsent(group, consumer);
    if (prev != null) {
        log.warn("the consumer group[" + group + "] exist already.");
        return false;
    }

    return true;
}
```

这就是`MQClientInstance`对象的`consumerTable`属性的由来，回到`MQClientInstance`对象的`doRebalance()`方法，该方法遍历所有注册的`DefaultMQPushConsumerImpl`对象并调用`DefaultMQPushConsumerImpl`对象的`doRebalance()`方法：
```java
// DefaultMQPushConsumerImpl类的实现
@Override
public void doRebalance() {
    if (!this.pause) {
        // isConsumeOrderly方法返回值表示当前消费者是否是顺序消费
        this.rebalanceImpl.doRebalance(this.isConsumeOrderly());
    }
}
```

在看`RebalanceImpl`类的`doRebalance()`方法的实现：
```java
// isOrder表示是否是顺序消费消息
public void doRebalance(final boolean isOrder) {
    // SubscriptionData对象保存了订阅配置、包括topic、标签等
    Map<String, SubscriptionData> subTable = this.getSubscriptionInner();
    if (subTable != null) {
        for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) {
            final String topic = entry.getKey();
            try {
                this.rebalanceByTopic(topic, isOrder);
            } catch (Throwable e) {
                if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
                    log.warn("rebalanceByTopic Exception", e);
                }
            }
        }
    }

    // 遍历processQueueTable属性中的MessageQueue对象，如果MessageQueue对象的topic不在subscriptionInner
    // 保存的订阅的topic中，则将MessageQueue对象从processQueueTable移除
    this.truncateMessageQueueNotMyTopic();
}
```

`doRebalance()`方法遍历订阅的topic，依次调用`rebalanceByTopic()`方法进行处理：
```java
private void rebalanceByTopic(final String topic, final boolean isOrder) {
    switch (messageModel) {
        case BROADCASTING: {
            Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic);
            if (mqSet != null) {
                boolean changed = this.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);
                if (changed) {
                    this.messageQueueChanged(topic, mqSet, mqSet);
                    log.info("messageQueueChanged {} {} {} {}",
                        consumerGroup,
                        topic,
                        mqSet,
                        mqSet);
                }
            } else {
                log.warn("doRebalance, {}, but the topic[{}] not exist.", consumerGroup, topic);
            }
            break;
        }
        case CLUSTERING: {
            // 获取topic的所有MessageQueue对象，每个MessageQueue对象代表一个broker中的consumeQueue，
            // 即MessageQueue对象包含了topic、brokerName和queueId
            Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic);
            // 获取consumerGroup下所有的消费者id
            List<String> cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup);
            // 通常topicSubscribeInfoTable中会包含topic的路由信息，如果mqSet为空则可能是broker中没有
            // 该topic，或者当前消费者还没获取过路由信息（这种情况其实不会发生，因为DefaultMQPushConsumerImpl
            // 的start方法最后调用了updateTopicSubscribeInfoWhenSubscriptionChanged方法更新了路由信息），
            // 这里用日志记录下这种情况
            if (null == mqSet) {
                if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
                    log.warn("doRebalance, {}, but the topic[{}] not exist.", consumerGroup, topic);
                }
            }

            // 如果当前消费组还没有消费者注册到broker，通常这也不会发生，因为只是当前消费者是会注册到broker的
            if (null == cidAll) {
                log.warn("doRebalance, {} {}, get consumer id list failed", consumerGroup, topic);
            }

            if (mqSet != null && cidAll != null) {
                List<MessageQueue> mqAll = new ArrayList<MessageQueue>();
                mqAll.addAll(mqSet);

                Collections.sort(mqAll);
                Collections.sort(cidAll);

                // allocateMessageQueueStrategy为负载均衡策略
                AllocateMessageQueueStrategy strategy = this.allocateMessageQueueStrategy;

                List<MessageQueue> allocateResult = null;
                try {
                    // 通过负载均衡策略从mqAll中选若干个队列作为当前消费者的消息来源，即当前消费者会消费这些
                    // 队列
                    allocateResult = strategy.allocate(
                        this.consumerGroup,
                        this.mQClientFactory.getClientId(),
                        mqAll,
                        cidAll);
                } catch (Throwable e) {
                    log.error("AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName={}", strategy.getName(),
                        e);
                    return;
                }

                Set<MessageQueue> allocateResultSet = new HashSet<MessageQueue>();
                if (allocateResult != null) {
                    allocateResultSet.addAll(allocateResult);
                }

                // allocateResultSet保存了所有根据负载均衡策略分配到的MessageQueue对象
                boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);
                // 如果这次的负载均衡和上次的结果有变化（新增或移除了需要消费的MessageQueue）
                if (changed) {
                    // 记录下这次负载均衡的结果
                    log.info(
                        "rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}",
                        strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),
                        allocateResultSet.size(), allocateResultSet);
                    // messageQueueChanged方法会根据这次负载均衡的结果更新流控的配置，并发送心跳给broker（也就是告诉broker这次
                    // 负载均衡的结果）
                    this.messageQueueChanged(topic, mqSet, allocateResultSet);
                }
            }
            break;
        }
        default:
            break;
    }
}
```

`rebalanceByTopic()`方法对于广播模式和集群模式分别进行了处理，而广播模式和集群模式处理过程的实现的主要区别是集群模式有一个调用负载均衡策略实现类选择`MessageQueue`的过程，所以下面主要分析集群模式，集群模式首先获取根据路由信息获得的当前topic下所有的`MessageQueue`对象（在消费者端，一个`MessageQueue`对象表示一个broker中的`ConsumeQueue`），再通过PRC从broker获取当前消费者所在的消费者组中所有消费者的id，有了这些信息后，就可以通过`AllocateMessageQueueStrategy`类完成消费者组的负载均衡，关于`AllocateMessageQueueStrategy`的实现，可以看笔记[如何实现负载均衡](如何实现负载均衡.md)，这里主要看分配到`MessageQueue`后的操作，也就是`updateProcessQueueTableInRebalance()`方法的实现：
```java
private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet,
    final boolean isOrder) {
    boolean changed = false;

    // processQueueTable保存了上一次负载均衡后分配到的MessageQueue及对应的ProcessQueue
    Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<MessageQueue, ProcessQueue> next = it.next();
        MessageQueue mq = next.getKey();
        ProcessQueue pq = next.getValue();

        if (mq.getTopic().equals(topic)) {
            // 如果这次负载均衡没有分配到该MessageQueue
            if (!mqSet.contains(mq)) {
                // 标记ProcessQueue的dropped属性为true
                pq.setDropped(true);
                // removeUnnecessaryMessageQueue方法会提交并清除消费位移，对于顺序消费，会向broker发送解锁consumeQueue的请求
                if (this.removeUnnecessaryMessageQueue(mq, pq)) {
                    // 解锁成功则从processQueueTable中移除该MessageQueue
                    it.remove();
                    changed = true;
                    log.info("doRebalance, {}, remove unnecessary mq, {}", consumerGroup, mq);
                }
                // 当前MessageQueue在上次负载均衡时也被分配到了当前消费者，并且当前MessageQueue的上次拉取消息时间到当前时间的
                // 时间差超过了阈值（默认2分钟）
            } else if (pq.isPullExpired()) {
                switch (this.consumeType()) {
                    case CONSUME_ACTIVELY: // CONSUME_ACTIVELY表示消费者的拉取策略是pull
                        break;
                    case CONSUME_PASSIVELY: // CONSUME_PASSIVELY表示消费者的拉取策略是push
                        // 拉取消息超时了就标记ProcessQueue的dropped属性为true，表示当前消费者不再消费该ProcessQueue对应的
                        // MessageQueue（也就是broker中对应的consumeQueue）
                        pq.setDropped(true);
                        // 既然放弃消费当前MessageQueue，就要提交并移除消费位移，同时对于顺序消费的情况，尝试释放锁
                        if (this.removeUnnecessaryMessageQueue(mq, pq)) {
                            it.remove();
                            changed = true;
                            log.error("[BUG]doRebalance, {}, remove unnecessary mq, {}, because pull is pause, so try to fixed it",
                                consumerGroup, mq);
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    }

    List<PullRequest> pullRequestList = new ArrayList<PullRequest>();
    // mqSet保存在这次负载均衡分配到的所有MessageQueue对象
    for (MessageQueue mq : mqSet) {
        // 如果上一次负载均衡后当前的MessageQueue对象没有分配给当前RebalanceImpl对象所在的DefaultMQPushConsumerImpl对象
        // 则在下面创建这次新分配到的MessageQueue对象对应的PullRequest
        if (!this.processQueueTable.containsKey(mq)) {
            // 顺序消息锁住当前的MessageQueue，也就是对应的Broker中的consumeQueue，从上面removeUnnecessaryMessageQueue方法
            // 的实现可以看出，锁是可能加不上的，此时记录日志，跳过这个分配到的MessageQueue
            if (isOrder && !this.lock(mq)) {
                log.warn("doRebalance, {}, add a new mq failed, {}, because lock failed", consumerGroup, mq);
                continue;
            }

            // 清除OffsetStore中保存的MessageQueue的消费位移，确保新分配的MessageQueue不会被旧数据影响
            this.removeDirtyOffset(mq);
            // ProcessQueue表示当前MessageQueue对象在当前消费者的消费情况，通过ProcessQueue对象能够判断是否需要触发消费者
            // 流控
            ProcessQueue pq = new ProcessQueue();
            // 根据DefaultMQPushConsumer对象的ConsumeFromWhere配置获取消费位移
            long nextOffset = this.computePullFromWhere(mq);
            if (nextOffset >= 0) {
                ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);
                if (pre != null) {
                    log.info("doRebalance, {}, mq already exists, {}", consumerGroup, mq);
                } else {
                    log.info("doRebalance, {}, add a new mq, {}", consumerGroup, mq);
                    // 创建当前MessageQueue对应的PullRequest
                    PullRequest pullRequest = new PullRequest();
                    pullRequest.setConsumerGroup(consumerGroup);
                    pullRequest.setNextOffset(nextOffset);
                    pullRequest.setMessageQueue(mq);
                    pullRequest.setProcessQueue(pq);
                    pullRequestList.add(pullRequest);
                    changed = true;
                }
            } else {
                log.warn("doRebalance, {}, add new mq failed, {}", consumerGroup, mq);
            }
        }
    }

    // pullRequestList保存了这次负载均衡新分配到的所有MessageQueue对应的PullRequest（不包括已经分配到的MessageQueue）
    // 这里开始针对这些PullRequest执行拉取消息操作
    this.dispatchPullRequest(pullRequestList);

    return changed;
}
```