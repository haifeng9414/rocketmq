消息消费分为并发消费和顺序消费，消费前获取消息的方式又分为push和pull，一般情况下使用的是并发push的方式消费，demo：
```java
public class Consumer {
	public static void main(String[] args) throws InterruptedException, MQClientException {

    	// 实例化消费者
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name");

    	// 设置NameServer的地址
        consumer.setNamesrvAddr("localhost:9876");

    	// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息
        consumer.subscribe("TopicTest", "*");
    	// 注册回调实现类来处理从broker拉取回来的消息
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
                System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);
                // 标记该消息已经被成功消费
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        // 启动消费者实例
        consumer.start();
        System.out.printf("Consumer Started.%n");
	}
}
```

顺序消费指的是可以按照消息的发送顺序来消费(FIFO)，RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。关于顺序消费的解析，在笔记[如何实现顺序消费](如何实现顺序消费.md)，这里不再赘述。

pull方式获取消息进行消费的demo如下：
```java
public class PullConsumer {
    private static final Map<MessageQueue, Long> OFFSE_TABLE = new HashMap<MessageQueue, Long>();

    public static void main(String[] args) throws MQClientException {
        DefaultMQPullConsumer consumer = new DefaultMQPullConsumer("please_rename_unique_group_name_5");
        consumer.setNamesrvAddr("127.0.0.1:9876");
        consumer.start();

        Set<MessageQueue> mqs = consumer.fetchSubscribeMessageQueues("broker-a");
        for (MessageQueue mq : mqs) {
            System.out.printf("Consume from the queue: %s%n", mq);
            SINGLE_MQ:
            while (true) {
                try {
                    PullResult pullResult =
                        consumer.pullBlockIfNotFound(mq, null, getMessageQueueOffset(mq), 32);
                    System.out.printf("%s%n", pullResult);
                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());
                    switch (pullResult.getPullStatus()) {
                        case FOUND:
                            break;
                        case NO_MATCHED_MSG:
                            break;
                        case NO_NEW_MSG:
                            break SINGLE_MQ;
                        case OFFSET_ILLEGAL:
                            break;
                        default:
                            break;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        consumer.shutdown();
    }

    private static long getMessageQueueOffset(MessageQueue mq) {
        Long offset = OFFSE_TABLE.get(mq);
        if (offset != null)
            return offset;

        return 0;
    }

    private static void putMessageQueueOffset(MessageQueue mq, long offset) {
        OFFSE_TABLE.put(mq, offset);
    }

}
```


下面来push和pull方式消费消息的实现，首先是push模式，对应的实现类是`DefaultMQPushConsumer`，`DefaultMQPushConsumer`类和[如何实现消息发送](如何实现消息发送.md)中分析的`DefaultMQProducer`类似，虽然实现了`MQPushConsumer`接口，但是实际上`MQPushConsumer`接口的实现是通过`DefaultMQPushConsumer`的成员变量`DefaultMQPushConsumerImpl`完成的，`DefaultMQPushConsumer`类的主要功能是定义若干个消费者相关的配置属性，并继承`ClientConfig`类从而获得管理消费者和客户端配置的能力，`DefaultMQPushConsumerImpl`类也会通过其所在的`DefaultMQPushConsumer`类获取客户端配置，从而影响其运行逻辑。这里直接看`DefaultMQPushConsumer`类的构造函数：
```java
public DefaultMQPushConsumer(final String consumerGroup) {
    this(null, consumerGroup, null, new AllocateMessageQueueAveragely());
}

public DefaultMQPushConsumer(final String namespace, final String consumerGroup, RPCHook rpcHook,
    AllocateMessageQueueStrategy allocateMessageQueueStrategy) {
    this.consumerGroup = consumerGroup;
    this.namespace = namespace;
    // 负载均衡算法，默认为取模平均
    this.allocateMessageQueueStrategy = allocateMessageQueueStrategy;
    // DefaultMQPushConsumer的大部分方法实际上就是调用DefaultMQPushConsumerImpl的相应方法实现的
    defaultMQPushConsumerImpl = new DefaultMQPushConsumerImpl(this, rpcHook);
}
```

`DefaultMQPushConsumer`类的其他代码直接看该类的源码注释，这里不再赘述，下面来看使用push模式时使用`DefaultMQPushConsumer`对象需要执行的步骤，首先是`DefaultMQPushConsumer`对象的属性设置：
```java
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name_4");

consumer.setNamesrvAddr("127.0.0.1:9876");
consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
consumer.subscribe("TopicTest", "*");

consumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                    ConsumeConcurrentlyContext context) {
        if (CollectionUtils.isNotEmpty(msgs)) {
            final List<String> msgBodies = msgs.stream().map((item) -> new String(item.getBody())).collect(Collectors.toList());

            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgBodies);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }

        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
});
```

`setNamesrvAddr()`和`setConsumeFromWhere()`方法分别定义在`ClientConfig`和`DefaultMQPushConsumer`类，用于设置namesrv的地址和消费消息时的起始位置：
```java
public void setNamesrvAddr(String namesrvAddr) {
    this.namesrvAddr = namesrvAddr;
}

public void setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) {
    this.consumeFromWhere = consumeFromWhere;
}
```

`subscribe()`方法用于设置消费者的订阅配置，实现在`DefaultMQPushConsumer`类：
```java
public void subscribe(String topic, String subExpression) throws MQClientException {
    this.defaultMQPushConsumerImpl.subscribe(withNamespace(topic), subExpression);
}

public String withNamespace(String resource) {
    return NamespaceUtil.wrapNamespace(this.getNamespace(), resource);
}

// resourceWithOutNamespace通常是某个topic，如果namespace为空或者resourceWithOutNamespace为空则直接
// 返回resourceWithOutNamespace，否则如果resourceWithOutNamespace是rocketmq内置的topic则直接返回
// 如果以上条件都不满足，则判断resourceWithOutNamespace是否是%RETRY%或%DLQ%开头的，即是否是重试队列或者
// 死信队列的topic，如果是则返回%RETRY%或%DLQ% + namespace%resourceWithoutRetryAndDLQ形式的字符串，
// 否则返回namespace%resourceWithoutRetryAndDLQ
// 即主要目的是在namespace不为空的情况下在resourceWithOutNamespace前加上namespace并返回
public static String wrapNamespace(String namespace, String resourceWithOutNamespace) {
    if (StringUtils.isEmpty(namespace) || StringUtils.isEmpty(resourceWithOutNamespace)) {
        return resourceWithOutNamespace;
    }

    if (isSystemResource(resourceWithOutNamespace) || isAlreadyWithNamespace(resourceWithOutNamespace, namespace)) {
        return resourceWithOutNamespace;
    }

    String resourceWithoutRetryAndDLQ = withOutRetryAndDLQ(resourceWithOutNamespace);
    StringBuffer strBuffer = new StringBuffer();

    if (isRetryTopic(resourceWithOutNamespace)) {
        strBuffer.append(MixAll.RETRY_GROUP_TOPIC_PREFIX);
    }

    if (isDLQTopic(resourceWithOutNamespace)) {
        strBuffer.append(MixAll.DLQ_GROUP_TOPIC_PREFIX);
    }

    return strBuffer.append(namespace).append(NAMESPACE_SEPARATOR).append(resourceWithoutRetryAndDLQ).toString();

}
```

`subscribe()`方法中用到的`withNamespace()`方法主要是用于支持按照namespace隔离客户端，通常namespace为空。`subscribe()`方法的真正实现在`DefaultMQPushConsumerImpl`类：
```java
// 订阅主题，subExpression参数为订阅的消息标签，如'*'、'tagA'等
public void subscribe(String topic, String subExpression) throws MQClientException {
    try {
        // 根据消费者的参数创建SubscriptionData对象，该对象保存了消费者订阅的topic和该topic的标签配置，即
        // 一个SubscriptionData对象表示消费者的某个topic订阅
        SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
            topic, subExpression);
        // 保存订阅配置
        this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
        if (this.mQClientFactory != null) {
            // 向broker发送心跳，心跳中会包含消费者的组名和消费配置、订阅配置
            this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}
```

可以看到，`subscribe()`方法主要用于保存消费者的订阅配置到`RebalanceImpl`对象（该对象和消费者的负载均衡有关），并向broker发送心跳（`mQClientFactory`对象是在`DefaultMQPushConsumerImpl`类的`start()`方法初始化的，所以上面的`mQClientFactory`可能为空，不一定会发送心跳，所以可以看到`DefaultMQPushConsumerImpl`类的`start()`方法最后有个发送心跳的方法调用），使得所有的broker能够知道消费者的配置。

`registerMessageListener()`方法则是用于注册消息处理器：
```java
@Override
public void registerMessageListener(MessageListenerConcurrently messageListener) {
    this.messageListener = messageListener;
    this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);
}

// 注册消息的处理对象
public void registerMessageListener(MessageListener messageListener) {
    this.messageListenerInner = messageListener;
}
```

最后是`start()`方法：
```java
@Override
public void start() throws MQClientException {
    // 如果namespace不为空，则以namespace%consumerGroup的格式创建新的consumerGroup
    setConsumerGroup(NamespaceUtil.wrapNamespace(this.getNamespace(), this.consumerGroup));
    this.defaultMQPushConsumerImpl.start();
    if (null != traceDispatcher) {
        try {
            traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel());
        } catch (MQClientException e) {
            log.warn("trace dispatcher start failed ", e);
        }
    }
}

// defaultMQPushConsumerImpl的start()方法
public synchronized void start() throws MQClientException {
    switch (this.serviceState) {
        case CREATE_JUST:
            log.info("the consumer [{}] start beginning. messageModel={}, isUnitMode={}", this.defaultMQPushConsumer.getConsumerGroup(),
                this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());
            // 设置状态为启动失败，如果启动过程正常执行，则会在最后更新成Running状态
            this.serviceState = ServiceState.START_FAILED;

            // 检查当前参数是否合法
            this.checkConfig();

            // defaultMQPushConsumer的subscription属性以Map的形式保存了消费者的订阅配置，copySubscription方法根据subscription
            // 属性的值创建SubscriptionData对象并保存到rebalanceImpl对象，同时添加consumeGroup的retry topic的订阅，即订阅
            // %RETRY%consumerGroupName这个topic
            this.copySubscription();

            if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {
                // 设置defaultMQPushConsumer的instanceName属性为pid
                this.defaultMQPushConsumer.changeInstanceNameToPID();
            }

            // mQClientFactory对象实现了真正需要发送网络请求的方法
            this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);

            // 配置负载均衡

            // 消费组
            this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());
            // 广播模式还是集群模式
            this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());
            // 负载均衡策略
            this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());
            this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);

            // 拉取消息的实现类
            this.pullAPIWrapper = new PullAPIWrapper(
                mQClientFactory,
                this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());
            this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);

            // offsetStore用于持久化已经消费的队列的consumeOffset
            if (this.defaultMQPushConsumer.getOffsetStore() != null) {
                this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();
            } else {
                // 没有设置offsetStore的实现则使用默认实现
                switch (this.defaultMQPushConsumer.getMessageModel()) {
                    case BROADCASTING:
                        // 广播模式offset保存在本地
                        this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
                        break;
                    case CLUSTERING:
                        // 集群模式offset保存在broker
                        this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
                        break;
                    default:
                        break;
                }
                this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);
            }
            // 获取之前持久化的offset
            this.offsetStore.load();

            // ConsumeMessageService负责持有和配置消费消息的线程池
            if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {
                this.consumeOrderly = true;
                this.consumeMessageService =
                    new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
            } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {
                this.consumeOrderly = false;
                this.consumeMessageService =
                    new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
            }

            // 启动定时任务定时调用consumeMessageService的cleanExpireMsg方法
            this.consumeMessageService.start();

            // 绑定consumerGroup和当前DefaultMQPushConsumerImpl对象的关系
            boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);
            if (!registerOK) {
                // 一个rocketmq进程内consumerGroup和DefaultMQPushConsumerImpl对象一一对应，如果存在多个DefaultMQPushConsumerImpl
                // 对象对应一个consumerGroup则报错
                this.serviceState = ServiceState.CREATE_JUST;
                this.consumeMessageService.shutdown();
                throw new MQClientException("The consumer group[" + this.defaultMQPushConsumer.getConsumerGroup()
                    + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                    null);
            }

            // 启动netty、拉取消息的线程、负载均衡线程、各种定时任务
            mQClientFactory.start();
            log.info("the consumer [{}] start OK.", this.defaultMQPushConsumer.getConsumerGroup());
            this.serviceState = ServiceState.RUNNING;
            break;
        case RUNNING:
        case START_FAILED:
        case SHUTDOWN_ALREADY:
            throw new MQClientException("The PushConsumer service state not OK, maybe started once, "
                + this.serviceState
                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),
                null);
        default:
            break;
    }

    // 从namesrv更新topic路由信息，并将路由信息保存到rebalanceImpl的topicSubscribeInfoTable属性
    this.updateTopicSubscribeInfoWhenSubscriptionChanged();
    // 遍历所有的SubscriptionData订阅配置，如果订阅时设置了tag，则根据topic获取TopicRouteData，并随机从TopicRouteData中选择一个
    // broker发送RequestCode.CHECK_CLIENT_CONFIG请求检查broker是否支持tag表达式
    this.mQClientFactory.checkClientInBroker();
    // 向所有broker发送心跳，心跳中包含消费者的订阅配置，这个方法使得broker能够在消费者启动时感知到消费者及其订阅配置，便于消费者的负载均衡
    this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
    // 立即唤醒rebalanceService使其执行this.mqClientFactory.doRebalance()语句
    this.mQClientFactory.rebalanceImmediately();
}
```

`DefaultMQPushConsumerImpl`类的`start()`方法做了很多初始化操作，这里逐个分析，首先是`copySubscription()`方法：
```java
// defaultMQPushConsumer的subscription属性以Map的形式保存了消费者的订阅配置，copySubscription方法根据subscription
// 属性的值创建SubscriptionData对象并保存到rebalanceImpl对象，同时添加consumeGroup的retry topic的订阅，即订阅
// %RETRY%consumerGroupName这个topic
this.copySubscription();

private void copySubscription() throws MQClientException {
    try {
        // 如果defaultMQPushConsumer对象设置了subscription属性，即通过map设置了消费者的订阅配置，则
        // 将根据这些配置创建SubscriptionData对象并保存到rebalanceImpl，这一过程和DefaultMQPushConsumerImpl
        // 的subscribe方法一样
        Map<String, String> sub = this.defaultMQPushConsumer.getSubscription();
        if (sub != null) {
            for (final Map.Entry<String, String> entry : sub.entrySet()) {
                final String topic = entry.getKey();
                final String subString = entry.getValue();
                // 一个SubscriptionData对象表示消费者的一个订阅配置，即一个SubscriptionData对应一个topic和消费者设置的
                // topic的标签
                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                    topic, subString);
                this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
            }
        }

        // 设置消息处理器
        if (null == this.messageListenerInner) {
            this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();
        }

        switch (this.defaultMQPushConsumer.getMessageModel()) {
            case BROADCASTING:
                break;
            case CLUSTERING:
                // 获取retry的topic，格式为%RETRY%consumerGroup
                final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());
                // 订阅retry的消息
                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                    retryTopic, SubscriptionData.SUB_ALL);
                this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);
                break;
            default:
                break;
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}
```

`copySubscription()`方法首先解析`DefaultMQPushConsumer`类的`subscription`属性，将key和value作为topic和标签创建`SubscriptionData`对象，并将`SubscriptionData`对象保存到`RebalanceImpl`类，而`RebalanceImpl`类用于实现消费者之间的负载均衡，关于负载均衡可以看笔记[如何实现负载均衡](如何实现负载均衡.md)。

之后`copySubscription()`方法设置了`MessageListener`，并订阅了当前消费者组对应的retry topic，`MessageListener`就是demo中写的消息处理器，用于消费消息：
```java
consumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                    ConsumeConcurrentlyContext context) {
        if (CollectionUtils.isNotEmpty(msgs)) {
            final List<String> msgBodies = msgs.stream().map((item) -> new String(item.getBody())).collect(Collectors.toList());

            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgBodies);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }

        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
})
```

在`copySubscription()`方法之后，`start()`方法初始化了若干成员变量，调用了`OffsetStore`类的`load()`方法来加载消费位移，消费者开始消费消息时会从该位移开始消费。对于集群模式，`OffsetStore`类的实现是`RemoteBrokerOffsetStore`，其`load()`方法为空，因为集群模式的消费位移保存在Broker，并且只支持3种消费位移的设置方式，所以不需要加载消费位移：
- CONSUME_FROM_LAST_OFFSET 队列尾消费，即忽略历史消息
- CONSUME_FROM_FIRST_OFFSET 队列头消费，即从未过期的消息开始
- CONSUME_FROM_TIMESTAMP 按照日期选择某个位置消费，默认半个小时前的消息开始消费

在调用`load()`方法之后调用了`this.consumeMessageService.start();`语句，如果不是顺序消费消息，则`ConsumeMessageService`的实现类是`ConsumeMessageConcurrentlyService`，该类的实现在下面会分析。如果消费者顺序消费消息，则`ConsumeMessageService`的实现类是`ConsumeMessageOrderlyService`，该类的实现可以看笔记[如何实现顺序消费](如何实现顺序消费.md)。

最后是`mQClientFactory.start();`，该方法主要是启动定时任务，初始化网络连接等，也就是在该方法运行之后，消费者监听消息的过程就开始了：
```java
public void start() throws MQClientException {

    synchronized (this) {
        switch (this.serviceState) {
            case CREATE_JUST:
                // 更新状态
                this.serviceState = ServiceState.START_FAILED;
                // If not specified,looking address from name server
                // 从环境变量中获取namesrv的地址，如果获取不到则从默认url抓取namesrv地址
                if (null == this.clientConfig.getNamesrvAddr()) {
                    this.mQClientAPIImpl.fetchNameServerAddr();
                }
                // Start request-response channel
                // MQClientAPIImpl实现了真正发送各种网络请求的逻辑，必然用到了netty，这里的start方法实际上是调用
                // NettyRemotingClient的start方法创建netty的Bootstrap
                this.mQClientAPIImpl.start();
                // Start various schedule tasks
                // 开启定时任务，最主要的是更新路由信息，发送心跳等
                this.startScheduledTask();
                // Start pull service
                // pullMessageService是个无限循环的线程，负责从指定队列拉取消息
                this.pullMessageService.start();
                // Start rebalance service
                // rebalanceService是个无限循环的线程，以固定间隔调用当前类的doRebalance方法
                this.rebalanceService.start();
                // Start push service
                // 启动productGroup为MixAll.CLIENT_INNER_PRODUCER_GROUP的内置生产者，注意这里传入的startFactory参数为false，
                // 因为内置生产者不需要启动上面这几个线程和定时任务
                // defaultMQProducer主要用于在消息消费失败时发送消息给broker以实现消息重试
                this.defaultMQProducer.getDefaultMQProducerImpl().start(false);
                log.info("the client factory [{}] start OK", this.clientId);
                this.serviceState = ServiceState.RUNNING;
                break;
            case START_FAILED:
                throw new MQClientException("The Factory object[" + this.getClientId() + "] has been created before, and failed.", null);
            default:
                break;
        }
    }
}
```

`MQClientInstance`类的`start()`方法中关于初始化网络连接的过程由`this.mQClientAPIImpl.start();`实现，这个在笔记[remoting模块的作用和实现](../公共组件/remoting模块的作用和实现.md)中分析过了，对于消费者来说，比较关键的是`this.pullMessageService.start();`和`this.rebalanceService.start();`语句，分别用于实现拉取消息和实现负载均衡，下面先看`this.pullMessageService.start();`和消息拉取的实现过程。

`PullMessageService`的实现类就是`PullMessageService`，初始化在`MQClientInstance`的构造函数：
```java
public MQClientInstance(ClientConfig clientConfig, int instanceIndex, String clientId, RPCHook rpcHook) {
    // 略...

    this.pullMessageService = new PullMessageService(this);

    // 略...
}
```

`PullMessageService`类继承自`ServiceThread`类，所以其本质上是个线程类，其`run()`方法代码：
```java
@Override
public void run() {
    log.info(this.getServiceName() + " service started");

    while (!this.isStopped()) {
        try {
            PullRequest pullRequest = this.pullRequestQueue.take();
            this.pullMessage(pullRequest);
        } catch (InterruptedException ignored) {
        } catch (Exception e) {
            log.error("Pull Message Service Run Method exception", e);
        }
    }

    log.info(this.getServiceName() + " service end");
}
```

`pullRequestQueue`为阻塞队列`LinkedBlockingQueue`，上面的实现就是不断从阻塞队列获取元素并消费。初始情况下该队列为空，`PullMessageService`类中的`executePullRequestLater()`和`executePullRequestImmediately()`方法会添加`PullRequest`对象到该队列，下面来看看这两个方法是如何被调用的。

`PullRequest`对象代表的是一个拉取请求，其创建过程实际上是在消费者的负载均衡中实现的，在`MQClientInstance`类的`start()`方法中调用完`this.pullMessageService.start();`之后调用了`this.rebalanceService.start();`语句，该语句就开启了消费者的负载均衡，`RebalanceService`类也继承自`ServiceThread`，其实现非常简单：
```java
public class RebalanceService extends ServiceThread {
    private static long waitInterval =
        Long.parseLong(System.getProperty(
            "rocketmq.client.rebalance.waitInterval", "20000"));
    private final InternalLogger log = ClientLogger.getLog();
    private final MQClientInstance mqClientFactory;

    public RebalanceService(MQClientInstance mqClientFactory) {
        this.mqClientFactory = mqClientFactory;
    }

    @Override
    public void run() {
        log.info(this.getServiceName() + " service started");

        while (!this.isStopped()) {
            this.waitForRunning(waitInterval);
            this.mqClientFactory.doRebalance();
        }

        log.info(this.getServiceName() + " service end");
    }

    @Override
    public String getServiceName() {
        return RebalanceService.class.getSimpleName();
    }
}
```

可以看到，就是定时调用`MQClientInstance`的`doRebalance()`方法，下面再看看`doRebalance()`方法的实现：
```java
public void doRebalance() {
    for (Map.Entry<String, MQConsumerInner> entry : this.consumerTable.entrySet()) {
        MQConsumerInner impl = entry.getValue();
        if (impl != null) {
            try {
                impl.doRebalance();
            } catch (Throwable e) {
                log.error("doRebalance exception", e);
            }
        }
    }
}
```

`MQClientInstance`在之前的笔记说过，该实例默认情况下在一个进程内是单例的，而其`consumerTable`属性保存的是所有注册到该`MQClientInstance`实例的`DefaultMQPushConsumerImpl`对象，`DefaultMQPushConsumerImpl`对象的`start()`方法有如下代码段：
```java
public synchronized void start() throws MQClientException {
    switch (this.serviceState) {
        case CREATE_JUST:
            // 略...

            if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {
                // 设置defaultMQPushConsumer的instanceName属性为pid
                this.defaultMQPushConsumer.changeInstanceNameToPID();
            }

            // mQClientFactory对象实现了真正需要发送网络请求的方法
            this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);

            // 略...

            // 绑定consumerGroup和当前DefaultMQPushConsumerImpl对象的关系
            boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);
            if (!registerOK) {
                // 一个rocketmq进程内consumerGroup和DefaultMQPushConsumerImpl对象一一对应，如果存在多个DefaultMQPushConsumerImpl
                // 对象对应一个consumerGroup则报错
                this.serviceState = ServiceState.CREATE_JUST;
                this.consumeMessageService.shutdown();
                throw new MQClientException("The consumer group[" + this.defaultMQPushConsumer.getConsumerGroup()
                    + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                    null);
            }
            
            // 略...
            break;
        case RUNNING:
        case START_FAILED:
        case SHUTDOWN_ALREADY:
            throw new MQClientException("The PushConsumer service state not OK, maybe started once, "
                + this.serviceState
                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),
                null);
        default:
            break;
    }
    // 略...
}
```

`DefaultMQPushConsumerImpl`对象的`start()`方法在获取到`MQClientInstance`对象后，会调用`registerConsumer()`方法将自己注册到`MQClientInstance`对象，代码：
```java
public boolean registerConsumer(final String group, final MQConsumerInner consumer) {
    if (null == group || null == consumer) {
        return false;
    }

    MQConsumerInner prev = this.consumerTable.putIfAbsent(group, consumer);
    if (prev != null) {
        log.warn("the consumer group[" + group + "] exist already.");
        return false;
    }

    return true;
}
```

这就是`MQClientInstance`对象的`consumerTable`属性的由来，回到`MQClientInstance`对象的`doRebalance()`方法，该方法遍历所有注册的`DefaultMQPushConsumerImpl`对象并调用`DefaultMQPushConsumerImpl`对象的`doRebalance()`方法：
```java
// DefaultMQPushConsumerImpl类的实现
@Override
public void doRebalance() {
    if (!this.pause) {
        // isConsumeOrderly方法返回值表示当前消费者是否是顺序消费
        this.rebalanceImpl.doRebalance(this.isConsumeOrderly());
    }
}
```

在看`RebalanceImpl`类的`doRebalance()`方法的实现：
```java
// isOrder表示是否是顺序消费消息
public void doRebalance(final boolean isOrder) {
    // SubscriptionData对象保存了订阅配置、包括topic、标签等
    Map<String, SubscriptionData> subTable = this.getSubscriptionInner();
    if (subTable != null) {
        for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) {
            final String topic = entry.getKey();
            try {
                this.rebalanceByTopic(topic, isOrder);
            } catch (Throwable e) {
                if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
                    log.warn("rebalanceByTopic Exception", e);
                }
            }
        }
    }

    // 遍历processQueueTable属性中的MessageQueue对象，如果MessageQueue对象的topic不在subscriptionInner
    // 保存的订阅的topic中，则将MessageQueue对象从processQueueTable移除
    this.truncateMessageQueueNotMyTopic();
}
```

`doRebalance()`方法遍历订阅的topic，依次调用`rebalanceByTopic()`方法进行处理：
```java
private void rebalanceByTopic(final String topic, final boolean isOrder) {
    switch (messageModel) {
        case BROADCASTING: {
            Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic);
            if (mqSet != null) {
                boolean changed = this.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);
                if (changed) {
                    this.messageQueueChanged(topic, mqSet, mqSet);
                    log.info("messageQueueChanged {} {} {} {}",
                        consumerGroup,
                        topic,
                        mqSet,
                        mqSet);
                }
            } else {
                log.warn("doRebalance, {}, but the topic[{}] not exist.", consumerGroup, topic);
            }
            break;
        }
        case CLUSTERING: {
            // 获取topic的所有MessageQueue对象，每个MessageQueue对象代表一个broker中的consumeQueue，
            // 即MessageQueue对象包含了topic、brokerName和queueId
            Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic);
            // 获取consumerGroup下所有的消费者id
            List<String> cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup);
            // 通常topicSubscribeInfoTable中会包含topic的路由信息，如果mqSet为空则可能是broker中没有
            // 该topic，或者当前消费者还没获取过路由信息（这种情况其实不会发生，因为DefaultMQPushConsumerImpl
            // 的start方法最后调用了updateTopicSubscribeInfoWhenSubscriptionChanged方法更新了路由信息），
            // 这里用日志记录下这种情况
            if (null == mqSet) {
                if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
                    log.warn("doRebalance, {}, but the topic[{}] not exist.", consumerGroup, topic);
                }
            }

            // 如果当前消费组还没有消费者注册到broker，通常这也不会发生，因为只是当前消费者是会注册到broker的
            if (null == cidAll) {
                log.warn("doRebalance, {} {}, get consumer id list failed", consumerGroup, topic);
            }

            if (mqSet != null && cidAll != null) {
                List<MessageQueue> mqAll = new ArrayList<MessageQueue>();
                mqAll.addAll(mqSet);

                Collections.sort(mqAll);
                Collections.sort(cidAll);

                // allocateMessageQueueStrategy为负载均衡策略
                AllocateMessageQueueStrategy strategy = this.allocateMessageQueueStrategy;

                List<MessageQueue> allocateResult = null;
                try {
                    // 通过负载均衡策略从mqAll中选若干个队列作为当前消费者的消息来源，即当前消费者会消费这些
                    // 队列
                    allocateResult = strategy.allocate(
                        this.consumerGroup,
                        this.mQClientFactory.getClientId(),
                        mqAll,
                        cidAll);
                } catch (Throwable e) {
                    log.error("AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName={}", strategy.getName(),
                        e);
                    return;
                }

                Set<MessageQueue> allocateResultSet = new HashSet<MessageQueue>();
                if (allocateResult != null) {
                    allocateResultSet.addAll(allocateResult);
                }

                // allocateResultSet保存了所有根据负载均衡策略分配到的MessageQueue对象
                boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);
                // 如果这次的负载均衡和上次的结果有变化（新增或移除了需要消费的MessageQueue）
                if (changed) {
                    // 记录下这次负载均衡的结果
                    log.info(
                        "rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}",
                        strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),
                        allocateResultSet.size(), allocateResultSet);
                    // messageQueueChanged方法会根据这次负载均衡的结果更新流控的配置，并发送心跳给broker
                    this.messageQueueChanged(topic, mqSet, allocateResultSet);
                }
            }
            break;
        }
        default:
            break;
    }
}
```

`rebalanceByTopic()`方法对于广播模式和集群模式分别进行了处理，而广播模式和集群模式处理过程的实现的主要区别是集群模式有一个调用负载均衡策略实现类选择`MessageQueue`的过程，所以下面主要分析集群模式，集群模式首先获取根据路由信息获得的当前topic下所有的`MessageQueue`对象（在消费者端，一个`MessageQueue`对象表示一个broker中的`ConsumeQueue`），再通过PRC从broker获取当前消费者所在的消费者组中所有消费者的id，有了这些信息后，就可以通过`AllocateMessageQueueStrategy`类完成消费者组的负载均衡，关于`AllocateMessageQueueStrategy`的实现，可以看笔记[如何实现负载均衡](如何实现负载均衡.md)，这里主要看分配到`MessageQueue`后的操作，也就是`updateProcessQueueTableInRebalance()`方法的实现：
```java
private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet,
    final boolean isOrder) {
    boolean changed = false;

    // processQueueTable保存了上一次负载均衡后分配到的MessageQueue及对应的ProcessQueue
    Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<MessageQueue, ProcessQueue> next = it.next();
        MessageQueue mq = next.getKey();
        ProcessQueue pq = next.getValue();

        if (mq.getTopic().equals(topic)) {
            // 如果这次负载均衡没有分配到该MessageQueue
            if (!mqSet.contains(mq)) {
                // 标记ProcessQueue的dropped属性为true
                pq.setDropped(true);
                // removeUnnecessaryMessageQueue方法会提交并清除消费位移，对于顺序消费，会向broker发送解锁consumeQueue的请求
                if (this.removeUnnecessaryMessageQueue(mq, pq)) {
                    // 解锁成功则从processQueueTable中移除该MessageQueue
                    it.remove();
                    changed = true;
                    log.info("doRebalance, {}, remove unnecessary mq, {}", consumerGroup, mq);
                }
                // 当前MessageQueue在上次负载均衡时也被分配到了当前消费者，并且当前MessageQueue的上次拉取消息时间到当前时间的
                // 时间差超过了阈值（默认2分钟）
            } else if (pq.isPullExpired()) {
                switch (this.consumeType()) {
                    case CONSUME_ACTIVELY: // CONSUME_ACTIVELY表示消费者的拉取策略是pull
                        break;
                    case CONSUME_PASSIVELY: // CONSUME_PASSIVELY表示消费者的拉取策略是push
                        // 拉取消息超时了就标记ProcessQueue的dropped属性为true，表示当前消费者不再消费该ProcessQueue对应的
                        // MessageQueue（也就是broker中对应的consumeQueue）
                        pq.setDropped(true);
                        // 既然放弃消费当前MessageQueue，就要提交并移除消费位移，同时对于顺序消费的情况，尝试释放锁
                        if (this.removeUnnecessaryMessageQueue(mq, pq)) {
                            it.remove();
                            changed = true;
                            log.error("[BUG]doRebalance, {}, remove unnecessary mq, {}, because pull is pause, so try to fixed it",
                                consumerGroup, mq);
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    }

    List<PullRequest> pullRequestList = new ArrayList<PullRequest>();
    // mqSet保存在这次负载均衡分配到的所有MessageQueue对象
    for (MessageQueue mq : mqSet) {
        // 如果上一次负载均衡后当前的MessageQueue对象没有分配给当前RebalanceImpl对象所在的DefaultMQPushConsumerImpl对象
        // 则在下面创建这次新分配到的MessageQueue对象对应的PullRequest
        if (!this.processQueueTable.containsKey(mq)) {
            // 顺序消息锁住当前的MessageQueue，也就是对应的Broker中的consumeQueue，从上面removeUnnecessaryMessageQueue方法
            // 的实现可以看出，锁是可能加不上的，此时记录日志，跳过这个分配到的MessageQueue
            if (isOrder && !this.lock(mq)) {
                log.warn("doRebalance, {}, add a new mq failed, {}, because lock failed", consumerGroup, mq);
                continue;
            }

            // 清除OffsetStore中保存的MessageQueue的消费位移，确保新分配的MessageQueue不会被旧数据影响
            this.removeDirtyOffset(mq);
            // ProcessQueue表示当前MessageQueue对象在当前消费者的消费情况，通过ProcessQueue对象能够判断是否需要触发消费者
            // 流控
            ProcessQueue pq = new ProcessQueue();
            // 根据DefaultMQPushConsumer对象的ConsumeFromWhere配置获取消费位移
            long nextOffset = this.computePullFromWhere(mq);
            if (nextOffset >= 0) {
                ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);
                if (pre != null) {
                    log.info("doRebalance, {}, mq already exists, {}", consumerGroup, mq);
                } else {
                    log.info("doRebalance, {}, add a new mq, {}", consumerGroup, mq);
                    // 创建当前MessageQueue对应的PullRequest
                    PullRequest pullRequest = new PullRequest();
                    pullRequest.setConsumerGroup(consumerGroup);
                    pullRequest.setNextOffset(nextOffset);
                    pullRequest.setMessageQueue(mq);
                    pullRequest.setProcessQueue(pq);
                    pullRequestList.add(pullRequest);
                    changed = true;
                }
            } else {
                log.warn("doRebalance, {}, add new mq failed, {}", consumerGroup, mq);
            }
        }
    }

    // pullRequestList保存了这次负载均衡新分配到的所有MessageQueue对应的PullRequest（不包括已经分配到的MessageQueue）
    // 这里开始针对这些PullRequest执行拉取消息操作
    this.dispatchPullRequest(pullRequestList);

    return changed;
}
```

`updateProcessQueueTableInRebalance()`方法首先遍历保存在`processQueueTable`属性中的`MessageQueue`和`ProcessQueue`对象，将不在这次负载均衡选中的`MessageQueue`集合或者拉取消息超时的`MessageQueue`对应的`ProcessQueue`对象的`dropped`属性设置为true，并分别调用`removeUnnecessaryMessageQueue()`方法提交和移除消费位移。第一次遍历之后，再次遍历负载均衡选中的`MessageQueue`集合，为不在`processQueueTable`属性中的`MessageQueue`对象，也就是不在上次负载均衡选中的`MessageQueue`集合中的`MessageQueue`对象创建`PullRequest`对象，`PullRequest`对象表示消费者对于一个broker中的队列的拉取请求。`updateProcessQueueTableInRebalance()`方法的最后调用`dispatchPullRequest()`方法针对创建的`PullRequest`对象执行拉取消息的操作，该方法代码：
```java
@Override
public void dispatchPullRequest(List<PullRequest> pullRequestList) {
    for (PullRequest pullRequest : pullRequestList) {
        // 将PullRequest交给defaultMQPushConsumerImpl，触发拉取消息的过程
        this.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);
        log.info("doRebalance, {}, add a new pull request {}", consumerGroup, pullRequest);
    }
}
```

再看`DefaultMQPushConsumerImpl`对象的`executePullRequestImmediately()`方法的实现：
```java
public void executePullRequestImmediately(final PullRequest pullRequest) {
    this.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);
}
```

`DefaultMQPushConsumerImpl`类的`executePullRequestImmediately()`方法获取`PullMessageService`对象并调用其`executePullRequestImmediately()`方法，而这个`PullMessageService`对象在上面已经分析过了，该对象实际上是个线程，其`executePullRequestImmediately()`方法和`run()`方法的实现：
```java
public void executePullRequestImmediately(final PullRequest pullRequest) {
    try {
        this.pullRequestQueue.put(pullRequest);
    } catch (InterruptedException e) {
        log.error("executePullRequestImmediately pullRequestQueue.put", e);
    }
}

@Override
public void run() {
    log.info(this.getServiceName() + " service started");

    while (!this.isStopped()) {
        try {
            PullRequest pullRequest = this.pullRequestQueue.take();
            this.pullMessage(pullRequest);
        } catch (InterruptedException ignored) {
        } catch (Exception e) {
            log.error("Pull Message Service Run Method exception", e);
        }
    }

    log.info(this.getServiceName() + " service end");
}

private void pullMessage(final PullRequest pullRequest) {
    // MQConsumerInner实际上就是DefaultMQPushConsumerImpl对象
    final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());
    if (consumer != null) {
        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;
        impl.pullMessage(pullRequest);
    } else {
        log.warn("No matched consumer for the PullRequest {}, drop it", pullRequest);
    }
}
```

`PullMessageService`对象的`executePullRequestImmediately()`方法将`PullRequest`对象添加到阻塞队列，`run()`方法从阻塞队列获取`PullRequest`对象并交由其`pullMessage()`方法处理，而`pullMessage()`方法获取`PullRequest`对象对应的消费者组，并获取`MQConsumerInner`对象，这个`MQConsumerInner`对象根据`DefaultMQPushConsumerImpl`对象的`start()`方法可知，就是`DefaultMQPushConsumerImpl`对象，所以最终处理`PullRequest`对象的过程实现在`DefaultMQPushConsumerImpl`中，下面是`DefaultMQPushConsumerImpl`类的`pullMessage()`方法的实现：
```java
public void pullMessage(final PullRequest pullRequest) {
    final ProcessQueue processQueue = pullRequest.getProcessQueue();
    // dropped属性为true表示该ProcessQueue所属的MessageQueue对象已经不由当前消费者消费了
    if (processQueue.isDropped()) {
        log.info("the pull request[{}] is dropped.", pullRequest.toString());
        return;
    }

    // 更新消息拉取时间为当前时间
    pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());

    try {
        // 确保当前DefaultMQPushConsumerImp对象的serviceState等于ServiceState.RUNNING
        this.makeSureStateOK();
    } catch (MQClientException e) {
        log.warn("pullMessage exception, consumer state not ok", e);
        // 在状态不正常的情况下，延迟一段时间再将pullRequest对象添加到pullRequestQueue，即延迟一段时间后再执行这里的pullMessage方法
        this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);
        return;
    }

    // 同上，在consumer暂停的情况下延迟一段时间再执行pullMessage方法
    if (this.isPause()) {
        log.warn("consumer was paused, execute pull request later. instanceName={}, group={}", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());
        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);
        return;
    }

    // 获取当前等待被消费的消息数量
    long cachedMessageCount = processQueue.getMsgCount().get();
    // 获取当前等待被消费的消息大小
    long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);

    // 如果当前等待消费的消息数量大于阈值，则等待50ms再执行pullMessage方法
    if (cachedMessageCount > this.defaultMQPushConsumer.getPullThresholdForQueue()) {
        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);
        // 超过阈值次数达到1000记一次日志
        if ((queueFlowControlTimes++ % 1000) == 0) {
            log.warn(
                "the cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}",
                this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);
        }
        return;
    }

    // 如果当前等待消费的消息总大小大于阈值，则等待50ms再执行pullMessage方法
    if (cachedMessageSizeInMiB > this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) {
        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);
        // 超过阈值次数达到1000记一次日志
        if ((queueFlowControlTimes++ % 1000) == 0) {
            log.warn(
                "the cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}",
                this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);
        }
        return;
    }

    // 如果不是顺序消费
    if (!this.consumeOrderly) {
        // 正在消费或者等待被消息的消息的最小位移和最大位移的差是否超过了阈值，超过了则50ms后再执行pullMessage方法
        if (processQueue.getMaxSpan() > this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {
            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);
            if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) {
                log.warn(
                    "the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}",
                    processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),
                    pullRequest, queueMaxSpanFlowControlTimes);
            }
            return;
        }
    } else {
        // 否则如果是顺序消费，检查是否持有broker中对应的队列的锁
        if (processQueue.isLocked()) {
            // lockedFirst属性可以认为表示该pullRequest对象是否执行过拉取消息
            if (!pullRequest.isLockedFirst()) {
                // 根据ConsumeFromWhere的配置获取消费位移，创建pullRequest对象时已经执行过computePullFromWhere方法并将结果
                // 设置到了pullRequest对象的nextOffset属性，这里再次获取消费位移，可能是为了尽量确保不重复消费消息吧
                final long offset = this.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());
                // 不确定啥时候会出现offset < pullRequest.getNextOffset()
                boolean brokerBusy = offset < pullRequest.getNextOffset();
                log.info("the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}",
                    pullRequest, offset, brokerBusy);
                if (brokerBusy) {
                    log.info("[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}",
                        pullRequest, offset);
                }

                // 标记pullRequest已经执行过拉取消息了
                pullRequest.setLockedFirst(true);
                pullRequest.setNextOffset(offset);
            }
        } else {
            // 未持有则不能消费，这里延迟一段时间后再次执行pullRequest，通常不会出现dropped为false，processQueue.isLocked()也
            // 为false的情况。由于消费者会定时负载均衡，所以这里一段时间后再执行pullRequest可能就会dropped为true，或者processQueue
            // 加锁成功
            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);
            log.info("pull message later because not locked in broker, {}", pullRequest);
            return;
        }
    }

    // 获取订阅配置
    final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());
    if (null == subscriptionData) {
        this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);
        log.warn("find the consumer's subscription failed, {}", pullRequest);
        return;
    }

    final long beginTimestamp = System.currentTimeMillis();

    // 拉取消息成功后的回调函数
    PullCallback pullCallback = new PullCallback() {
        @Override
        public void onSuccess(PullResult pullResult) {
            if (pullResult != null) {
                pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,
                    subscriptionData);

                switch (pullResult.getPullStatus()) {
                    case FOUND:
                        long prevRequestOffset = pullRequest.getNextOffset();
                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());
                        long pullRT = System.currentTimeMillis() - beginTimestamp;
                        DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),
                            pullRequest.getMessageQueue().getTopic(), pullRT);

                        long firstMsgOffset = Long.MAX_VALUE;
                        if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {
                            DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
                        } else {
                            firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();

                            DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),
                                pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());

                            boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());
                            DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(
                                pullResult.getMsgFoundList(),
                                processQueue,
                                pullRequest.getMessageQueue(),
                                dispatchToConsume);

                            if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) {
                                DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,
                                    DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());
                            } else {
                                DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
                            }
                        }

                        if (pullResult.getNextBeginOffset() < prevRequestOffset
                            || firstMsgOffset < prevRequestOffset) {
                            log.warn(
                                "[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}",
                                pullResult.getNextBeginOffset(),
                                firstMsgOffset,
                                prevRequestOffset);
                        }

                        break;
                    case NO_NEW_MSG:
                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());

                        DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);

                        DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
                        break;
                    case NO_MATCHED_MSG:
                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());

                        DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);

                        DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
                        break;
                    case OFFSET_ILLEGAL:
                        log.warn("the pull request offset illegal, {} {}",
                            pullRequest.toString(), pullResult.toString());
                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());

                        pullRequest.getProcessQueue().setDropped(true);
                        DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),
                                        pullRequest.getNextOffset(), false);

                                    DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());

                                    DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());

                                    log.warn("fix the pull request offset, {}", pullRequest);
                                } catch (Throwable e) {
                                    log.error("executeTaskLater Exception", e);
                                }
                            }
                        }, 10000);
                        break;
                    default:
                        break;
                }
            }
        }

        @Override
        public void onException(Throwable e) {
            if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
                log.warn("execute the pull request exception", e);
            }

            DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);
        }
    };

    boolean commitOffsetEnable = false;
    long commitOffsetValue = 0L;
    if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) {
        commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);
        if (commitOffsetValue > 0) {
            commitOffsetEnable = true;
        }
    }

    String subExpression = null;
    boolean classFilter = false;
    SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());
    if (sd != null) {
        if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() && !sd.isClassFilterMode()) {
            subExpression = sd.getSubString();
        }

        classFilter = sd.isClassFilterMode();
    }

    int sysFlag = PullSysFlag.buildSysFlag(
        commitOffsetEnable, // commitOffset
        true, // suspend
        subExpression != null, // subscription
        classFilter // class filter
    );
    try {
        this.pullAPIWrapper.pullKernelImpl(
            pullRequest.getMessageQueue(),
            subExpression,
            subscriptionData.getExpressionType(),
            subscriptionData.getSubVersion(),
            pullRequest.getNextOffset(),
            this.defaultMQPushConsumer.getPullBatchSize(),
            sysFlag,
            commitOffsetValue,
            BROKER_SUSPEND_MAX_TIME_MILLIS,
            CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,
            CommunicationMode.ASYNC, // 异步拉取消息
            pullCallback
        );
    } catch (Exception e) {
        log.error("pullKernelImpl exception", e);
        this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);
    }
}
```

`pullMessage()`方法首先判断是否需要开启消费者端的流量控制，关于这里的实现，可以看笔记[如何实现流量控制](如何实现流量控制.md)。

如果不需要开启流控，则`pullMessage()`方法创建一个`PullCallback`对象后执行`PullAPIWrapper`类的`pullKernelImpl()`方法拉取消息，`PullCallback`对象表示成功拉取消息后的回调，这里先不分析，下看看是如何拉取消息的，方法如下：
```java
public PullResult pullKernelImpl(
    final MessageQueue mq,
    final String subExpression,
    final String expressionType,
    final long subVersion,
    final long offset,
    final int maxNums,
    final int sysFlag,
    final long commitOffset,
    final long brokerSuspendMaxTimeMillis,
    final long timeoutMillis,
    final CommunicationMode communicationMode,
    final PullCallback pullCallback
) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
    // findBrokerAddressInSubscribe方法用于从name相等的broker中选择一个来拉取消息
    FindBrokerResult findBrokerResult =
        this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),
            this.recalculatePullFromWhichNode(mq), false);
    // 如果选择结果为空则更新路由并再次选择
    if (null == findBrokerResult) {
        this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());
        findBrokerResult =
            this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),
                this.recalculatePullFromWhichNode(mq), false);
    }

    if (findBrokerResult != null) {
        {
            // check version
            // 如果不是根据标签进行消息过滤，并且broker的版本小于V4_1_0_SNAPSHOT则报错
            if (!ExpressionType.isTagType(expressionType)
                && findBrokerResult.getBrokerVersion() < MQVersion.Version.V4_1_0_SNAPSHOT.ordinal()) {
                throw new MQClientException("The broker[" + mq.getBrokerName() + ", "
                    + findBrokerResult.getBrokerVersion() + "] does not upgrade to support for filter message by " + expressionType, null);
            }
        }
        int sysFlagInner = sysFlag;

        // 如果选择的broker是slave，则设置commitOffsetFlag为false
        if (findBrokerResult.isSlave()) {
            sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);
        }

        PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();
        requestHeader.setConsumerGroup(this.consumerGroup);
        requestHeader.setTopic(mq.getTopic());
        requestHeader.setQueueId(mq.getQueueId());
        requestHeader.setQueueOffset(offset);
        requestHeader.setMaxMsgNums(maxNums);
        requestHeader.setSysFlag(sysFlagInner);
        requestHeader.setCommitOffset(commitOffset);
        requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);
        requestHeader.setSubscription(subExpression);
        requestHeader.setSubVersion(subVersion);
        requestHeader.setExpressionType(expressionType);

        String brokerAddr = findBrokerResult.getBrokerAddr();
        // 如果是基于class的消息过滤，则拉取消息的地址是filterServer而不是broker，这里从路由信息中获取broker对应的
        // filterServer的地址
        if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) {
            brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);
        }

        // 向broker发送拉取消息的请求
        PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage(
            brokerAddr,
            requestHeader,
            timeoutMillis,
            communicationMode,
            pullCallback);

        return pullResult;
    }

    throw new MQClientException("The broker[" + mq.getBrokerName() + "] not exist", null);
}
```

`pullKernelImpl()`方法实现了选择broker的过程，真正拉取消息的逻辑实现在`MQClientAPIImpl`类的`pullMessage()`方法：
```java
public PullResult pullMessage(
    final String addr,
    final PullMessageRequestHeader requestHeader,
    final long timeoutMillis,
    final CommunicationMode communicationMode,
    final PullCallback pullCallback
) throws RemotingException, MQBrokerException, InterruptedException {
    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, requestHeader);

    switch (communicationMode) {
        case ONEWAY:
            assert false;
            return null;
        case ASYNC:
            this.pullMessageAsync(addr, request, timeoutMillis, pullCallback);
            return null;
        case SYNC:
            return this.pullMessageSync(addr, request, timeoutMillis);
        default:
            assert false;
            break;
    }

    return null;
}
```

默认`communicationMode`属性为ASYNC，即异步拉取消息，`pullMessage()`方法调用`pullMessageAsync()`方法向broker发送一个`RequestCode.PULL_MESSAGE`请求，`pullMessageAsync()`方法代码：
```java
private void pullMessageAsync(
    final String addr,
    final RemotingCommand request,
    final long timeoutMillis,
    final PullCallback pullCallback
) throws RemotingException, InterruptedException {
    this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() {
        @Override
        public void operationComplete(ResponseFuture responseFuture) {
            RemotingCommand response = responseFuture.getResponseCommand();
            if (response != null) {
                try {
                    PullResult pullResult = MQClientAPIImpl.this.processPullResponse(response);
                    assert pullResult != null;
                    pullCallback.onSuccess(pullResult);
                } catch (Exception e) {
                    pullCallback.onException(e);
                }
            } else {
                if (!responseFuture.isSendRequestOK()) {
                    pullCallback.onException(new MQClientException("send request failed to " + addr + ". Request: " + request, responseFuture.getCause()));
                } else if (responseFuture.isTimeout()) {
                    pullCallback.onException(new MQClientException("wait response from " + addr + " timeout :" + responseFuture.getTimeoutMillis() + "ms" + ". Request: " + request,
                        responseFuture.getCause()));
                } else {
                    pullCallback.onException(new MQClientException("unknown reason. addr: " + addr + ", timeoutMillis: " + timeoutMillis + ". Request: " + request, responseFuture.getCause()));
                }
            }
        }
    });
}
```

`pullMessageAsync()`方法主要是添加了一个异步请求的回调函数，实现在`MQClientAPIImpl`类的`processPullResponse()`方法：
```java
private PullResult processPullResponse(
    final RemotingCommand response) throws MQBrokerException, RemotingCommandException {
    PullStatus pullStatus = PullStatus.NO_NEW_MSG;
    switch (response.getCode()) {
        case ResponseCode.SUCCESS:
            pullStatus = PullStatus.FOUND;
            break;
        case ResponseCode.PULL_NOT_FOUND:
            pullStatus = PullStatus.NO_NEW_MSG;
            break;
        case ResponseCode.PULL_RETRY_IMMEDIATELY:
            pullStatus = PullStatus.NO_MATCHED_MSG;
            break;
        case ResponseCode.PULL_OFFSET_MOVED:
            pullStatus = PullStatus.OFFSET_ILLEGAL;
            break;

        default:
            throw new MQBrokerException(response.getCode(), response.getRemark());
    }

    PullMessageResponseHeader responseHeader =
        (PullMessageResponseHeader) response.decodeCommandCustomHeader(PullMessageResponseHeader.class);

    return new PullResultExt(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),
        responseHeader.getMaxOffset(), null, responseHeader.getSuggestWhichBrokerId(), response.getBody());
}
```

可以看到`processPullResponse()`方法主要是负责状态转换，并创建`PullResultExt`对象，下面再看看broker端收到`RequestCode.PULL_MESSAGE`请求后是如何处理的，对于`RequestCode.PULL_MESSAGE`请求，broker对应的处理函数是`PullMessageProcessor`类的`processRequest()`方法：
```java
private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend)
    throws RemotingCommandException {
    RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);
    final PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();
    final PullMessageRequestHeader requestHeader =
        (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);

    response.setOpaque(request.getOpaque());

    log.debug("receive PullMessage request command, {}", request);

    // 检查当前broker是否可读
    if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {
        response.setCode(ResponseCode.NO_PERMISSION);
        response.setRemark(String.format("the broker[%s] pulling message is forbidden", this.brokerController.getBrokerConfig().getBrokerIP1()));
        return response;
    }

    // findSubscriptionGroupConfig方法获取或者创建请求中的消费者组对应的SubscriptionGroupConfig对象，该对象用于配置broker
    // 对于某个消费者组的行为，如是否可以被该消费者组消费等
    SubscriptionGroupConfig subscriptionGroupConfig =
        this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());
    if (null == subscriptionGroupConfig) {
        response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);
        response.setRemark(String.format("subscription group [%s] does not exist, %s", requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));
        return response;
    }

    // 如果配置为不可被该消费者组消费则返回error
    if (!subscriptionGroupConfig.isConsumeEnable()) {
        response.setCode(ResponseCode.NO_PERMISSION);
        response.setRemark("subscription group no permission, " + requestHeader.getConsumerGroup());
        return response;
    }

    // 对于push模式的消费者，hasSuspendFlag为true
    final boolean hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag());
    final boolean hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag());
    // 这次发送拉取消息请求的消费者是否设置了消息标签，即是否需要根据标签进行过滤
    final boolean hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag());

    // 请求挂起等待的时间
    final long suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : 0;

    // TopicConfig对象主要保存了某个topic的配置，包括读队列和写队列的数量、权限等
    TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());
    if (null == topicConfig) {
        log.error("the topic {} not exist, consumer: {}", requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel));
        response.setCode(ResponseCode.TOPIC_NOT_EXIST);
        response.setRemark(String.format("topic[%s] not exist, apply first please! %s", requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));
        return response;
    }

    if (!PermName.isReadable(topicConfig.getPerm())) {
        response.setCode(ResponseCode.NO_PERMISSION);
        response.setRemark("the topic[" + requestHeader.getTopic() + "] pulling message is forbidden");
        return response;
    }

    // 如果请求的队列ID不合法则返回error
    if (requestHeader.getQueueId() < 0 || requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {
        String errorInfo = String.format("queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]",
            requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress());
        log.warn(errorInfo);
        response.setCode(ResponseCode.SYSTEM_ERROR);
        response.setRemark(errorInfo);
        return response;
    }

    SubscriptionData subscriptionData = null;
    ConsumerFilterData consumerFilterData = null;
    if (hasSubscriptionFlag) {
        try {
            subscriptionData = FilterAPI.build(
                requestHeader.getTopic(), requestHeader.getSubscription(), requestHeader.getExpressionType()
            );
            if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {
                consumerFilterData = ConsumerFilterManager.build(
                    requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getSubscription(),
                    requestHeader.getExpressionType(), requestHeader.getSubVersion()
                );
                assert consumerFilterData != null;
            }
        } catch (Exception e) {
            log.warn("Parse the consumer's subscription[{}] failed, group: {}", requestHeader.getSubscription(),
                requestHeader.getConsumerGroup());
            response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);
            response.setRemark("parse the consumer's subscription failed");
            return response;
        }
    } else {
        // ConsumerGroupInfo保存了某个消费者组的配置及能够于该消费者组中已经注册到当前broker的消费者联系的channel
        ConsumerGroupInfo consumerGroupInfo =
            this.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup());
        if (null == consumerGroupInfo) {
            log.warn("the consumer's group info not exist, group: {}", requestHeader.getConsumerGroup());
            response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);
            response.setRemark("the consumer's group info not exist" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));
            return response;
        }

        // 未开启广播模式的情况下拉取请求如果是广播模式则报错
        if (!subscriptionGroupConfig.isConsumeBroadcastEnable()
            && consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) {
            response.setCode(ResponseCode.NO_PERMISSION);
            response.setRemark("the consumer group[" + requestHeader.getConsumerGroup() + "] can not consume by broadcast way");
            return response;
        }

        // 获取当前topic的订阅配置
        subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic());
        if (null == subscriptionData) {
            log.warn("the consumer's subscription not exist, group: {}, topic:{}", requestHeader.getConsumerGroup(), requestHeader.getTopic());
            response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);
            response.setRemark("the consumer's subscription not exist" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));
            return response;
        }

        // 检查配置的版本是否是最新的
        if (subscriptionData.getSubVersion() < requestHeader.getSubVersion()) {
            log.warn("The broker's subscription is not latest, group: {} {}", requestHeader.getConsumerGroup(),
                subscriptionData.getSubString());
            response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST);
            response.setRemark("the consumer's subscription not latest");
            return response;
        }
        // 如果不是按照标签进行过滤，则判断过滤的配置是否是最新的
        if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {
            consumerFilterData = this.brokerController.getConsumerFilterManager().get(requestHeader.getTopic(),
                requestHeader.getConsumerGroup());
            if (consumerFilterData == null) {
                response.setCode(ResponseCode.FILTER_DATA_NOT_EXIST);
                response.setRemark("The broker's consumer filter data is not exist!Your expression may be wrong!");
                return response;
            }
            if (consumerFilterData.getClientVersion() < requestHeader.getSubVersion()) {
                log.warn("The broker's consumer filter data is not latest, group: {}, topic: {}, serverV: {}, clientV: {}",
                    requestHeader.getConsumerGroup(), requestHeader.getTopic(), consumerFilterData.getClientVersion(), requestHeader.getSubVersion());
                response.setCode(ResponseCode.FILTER_DATA_NOT_LATEST);
                response.setRemark("the consumer's consumer filter data not latest");
                return response;
            }
        }
    }

    if (!ExpressionType.isTagType(subscriptionData.getExpressionType())
        && !this.brokerController.getBrokerConfig().isEnablePropertyFilter()) {
        response.setCode(ResponseCode.SYSTEM_ERROR);
        response.setRemark("The broker does not support consumer to filter message by " + subscriptionData.getExpressionType());
        return response;
    }

    // MessageFilter对象负责实现消息过滤
    MessageFilter messageFilter;
    if (this.brokerController.getBrokerConfig().isFilterSupportRetry()) {
        messageFilter = new ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,
            this.brokerController.getConsumerFilterManager());
    } else {
        messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,
            this.brokerController.getConsumerFilterManager());
    }

    // 根据位移获取消息，返回的消息最多requestHeader.getMaxMsgNums()条或者800条
    final GetMessageResult getMessageResult =
        this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),
            requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter);
    if (getMessageResult != null) {
        response.setRemark(getMessageResult.getStatus().name());
        responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());
        responseHeader.setMinOffset(getMessageResult.getMinOffset());
        responseHeader.setMaxOffset(getMessageResult.getMaxOffset());

        // getMessageResult的suggestPullingFromSlave的值会在上面的getMessage方法中被更新，当拉取的消息不在内存中而在磁盘中时，
        // suggestPullingFromSlave为true，此时建议消费者从slave读取消息
        if (getMessageResult.isSuggestPullingFromSlave()) {
            // getWhichBrokerWhenConsumeSlowly方法默认返回1，也就是默认只建议slave中brokerId等于1的那个
            responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());
        } else {
            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);
        }

        switch (this.brokerController.getMessageStoreConfig().getBrokerRole()) {
            case ASYNC_MASTER:
            case SYNC_MASTER:
                break;
            case SLAVE:
                // 如果当前broker是slave并且被设置为不可读，则建议消费者从master读取消息
                if (!this.brokerController.getBrokerConfig().isSlaveReadEnable()) {
                    // ResponseCode.PULL_RETRY_IMMEDIATELY表示消费者应该立即重新发送拉取消息请求
                    response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);
                    responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);
                }
                break;
        }

        if (this.brokerController.getBrokerConfig().isSlaveReadEnable()) {
            // consume too slow ,redirect to another machine
            // 这个在上面分析过了，消费者拉取的消息在磁盘中，这里建议消费者从slave拉取消息
            if (getMessageResult.isSuggestPullingFromSlave()) {
                responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());
            }
            // consume ok
            else {
                // 如果拉取的消息在内存，则建议消费者从master broker拉取消息，subscriptionGroupConfig.getBrokerId()默认返回
                // master id
                responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());
            }
        } else {
            // 如果slave设置为不可读，则从master broker拉取消息
            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);
        }

        // 根据拉取消息的结果设置response的code
        switch (getMessageResult.getStatus()) {
            case FOUND: // 拉取到消息了
                response.setCode(ResponseCode.SUCCESS);
                break;
            case MESSAGE_WAS_REMOVING: // 位移对应的CommitLog文件被删除了
                // getMessageResult会包含下一次应该拉取的消息位移的起始值，当CommitLog文件被删除的情况下，让消费者立即重新发送
                // 拉取消息请求即可
                response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);
                break;
            case NO_MATCHED_LOGIC_QUEUE:
            case NO_MESSAGE_IN_QUEUE: // 当前队列没有保存消息
                // 没有保存消息的队列对其拉取消息时queueOffset正常应该为0，不为空可能是当前broker为slave，但是还没来得及同步
                // master的消息，这种情况拉取消息请求的消息位移应该修正
                if (0 != requestHeader.getQueueOffset()) {
                    response.setCode(ResponseCode.PULL_OFFSET_MOVED);

                    // XXX: warn and notify me
                    log.info("the broker store no queue data, fix the request offset {} to {}, Topic: {} QueueId: {} Consumer Group: {}",
                        requestHeader.getQueueOffset(),
                        getMessageResult.getNextBeginOffset(),
                        requestHeader.getTopic(),
                        requestHeader.getQueueId(),
                        requestHeader.getConsumerGroup()
                    );
                } else {
                    // PULL_NOT_FOUND就是正常的表示没有消息能够被拉取
                    response.setCode(ResponseCode.PULL_NOT_FOUND);
                }
                break;
            case NO_MATCHED_MESSAGE: // 消息被过滤了，这个时候消费者应该立即从getMessageResult保存的nextBeginOffset开始再次拉取消息
                response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);
                break;
            case OFFSET_FOUND_NULL: // 没有找到consumeQueue文件
                response.setCode(ResponseCode.PULL_NOT_FOUND);
                break;
            case OFFSET_OVERFLOW_BADLY: // 请求的消息位移超出broker的队列保存的最大位移了
                // 这个时候和NO_MESSAGE_IN_QUEUE一样需要修正消息位移
                response.setCode(ResponseCode.PULL_OFFSET_MOVED);
                // XXX: warn and notify me
                log.info("the request offset: {} over flow badly, broker max offset: {}, consumer: {}",
                    requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());
                break;
            case OFFSET_OVERFLOW_ONE:
                // 请求的消息位移刚好等于broker的队列保存的消息的最大位移，说明从上次拉取消息后到这次拉取消息这两个请求之间，生产者
                // 没有产生消息
                response.setCode(ResponseCode.PULL_NOT_FOUND);
                break;
            case OFFSET_TOO_SMALL: // 消息位移小于broker的队列保存的最小位移，需要修正
                response.setCode(ResponseCode.PULL_OFFSET_MOVED);
                log.info("the request offset too small. group={}, topic={}, requestOffset={}, brokerMinOffset={}, clientIp={}",
                    requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),
                    getMessageResult.getMinOffset(), channel.remoteAddress());
                break;
            default:
                assert false;
                break;
        }

        // 如果存在hook
        if (this.hasConsumeMessageHook()) {
            ConsumeMessageContext context = new ConsumeMessageContext();
            context.setConsumerGroup(requestHeader.getConsumerGroup());
            context.setTopic(requestHeader.getTopic());
            context.setQueueId(requestHeader.getQueueId());

            String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);

            switch (response.getCode()) {
                case ResponseCode.SUCCESS:
                    int commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();
                    int incValue = getMessageResult.getMsgCount4Commercial() * commercialBaseCount;

                    context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_SUCCESS);
                    context.setCommercialRcvTimes(incValue);
                    context.setCommercialRcvSize(getMessageResult.getBufferTotalSize());
                    context.setCommercialOwner(owner);

                    break;
                case ResponseCode.PULL_NOT_FOUND:
                    if (!brokerAllowSuspend) {

                        context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);
                        context.setCommercialRcvTimes(1);
                        context.setCommercialOwner(owner);

                    }
                    break;
                case ResponseCode.PULL_RETRY_IMMEDIATELY:
                case ResponseCode.PULL_OFFSET_MOVED:
                    context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);
                    context.setCommercialRcvTimes(1);
                    context.setCommercialOwner(owner);
                    break;
                default:
                    assert false;
                    break;
            }

            this.executeConsumeMessageHookBefore(context);
        }

        // 更新统计数据，设置response的消息数据
        switch (response.getCode()) {
            case ResponseCode.SUCCESS: // 如果拉取消息成功，下面将消息写入响应
                // 增加消费者组拉取的消息数量
                this.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),
                    getMessageResult.getMessageCount());

                // 增加消费者组拉取的消息大小
                this.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),
                    getMessageResult.getBufferTotalSize());

                // 增加当前broker被拉取消息的数量
                this.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());
                // 如果设置使用Java堆进行消息传输，即通过ByteBuffer.allocate创建ByteBuffer保存消息实体对应的字节，默认为true
                if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {
                    final long beginTimeMills = this.brokerController.getMessageStore().now();
                    // readGetMessageResult方法返回这里拉取到的消息的所有字节
                    final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());
                    // 增加readGetMessageResult方法执行的延迟
                    this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),
                        requestHeader.getTopic(), requestHeader.getQueueId(),
                        (int) (this.brokerController.getMessageStore().now() - beginTimeMills));
                    response.setBody(r);
                } else {
                    try {
                        // 否则通过netty的FileRegion完成消息实体向字节的转换并写到channel
                        FileRegion fileRegion =
                            new ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);
                        channel.writeAndFlush(fileRegion).addListener(new ChannelFutureListener() {
                            @Override
                            public void operationComplete(ChannelFuture future) throws Exception {
                                getMessageResult.release();
                                if (!future.isSuccess()) {
                                    log.error("transfer many message by pagecache failed, {}", channel.remoteAddress(), future.cause());
                                }
                            }
                        });
                    } catch (Throwable e) {
                        log.error("transfer many message by pagecache exception", e);
                        getMessageResult.release();
                    }

                    response = null;
                }
                break;
            case ResponseCode.PULL_NOT_FOUND: // 如果没有能够返回的消息

                // 如果当前broker支持挂起，并且这次拉取请求的挂起设置为true，对于push模式的消费者，hasSuspendFlag为true
                if (brokerAllowSuspend && hasSuspendFlag) {
                    // suspendTimeoutMillisLong表示挂起操作的超时时间
                    long pollingTimeMills = suspendTimeoutMillisLong;
                    // 如果没有开启长轮训，则设置挂起操作的超时时间为shortPollingTimeMills，默认1秒
                    if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) {
                        pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();
                    }

                    String topic = requestHeader.getTopic();
                    long offset = requestHeader.getQueueOffset();
                    int queueId = requestHeader.getQueueId();
                    // 这个PullRequest对象和消费者端的PullRequest对象不是同一个，这里的PullRequest对象可以认为是被挂起的拉取
                    // 消息请求的上下文
                    PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,
                        this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);
                    // 将挂起请求保存到PullRequestHoldService
                    this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);
                    // 设置response为空，即没有需要返回给消费者的数据，这样消费者的拉取请求会一直等待broker的响应，而broker会通
                    // 过PullRequestHoldService对象挂起当前拉取请求，在消费者指定的时间内定时尝试拉取消息，拉取到消息后或者超时
                    // 后返回
                    response = null;
                    break;
                }

            case ResponseCode.PULL_RETRY_IMMEDIATELY:
                break;
            case ResponseCode.PULL_OFFSET_MOVED: // 表示请求的消息位移需要修正
                // 如果当前broker是master或者offsetCheckInSlave为true，发送一个broker自己创建的消息到OFFSET_MOVED_EVENT
                // 这个topic
                if (this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE
                    || this.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) {
                    MessageQueue mq = new MessageQueue();
                    mq.setTopic(requestHeader.getTopic());
                    mq.setQueueId(requestHeader.getQueueId());
                    mq.setBrokerName(this.brokerController.getBrokerConfig().getBrokerName());

                    OffsetMovedEvent event = new OffsetMovedEvent();
                    event.setConsumerGroup(requestHeader.getConsumerGroup());
                    event.setMessageQueue(mq);
                    event.setOffsetRequest(requestHeader.getQueueOffset());
                    event.setOffsetNew(getMessageResult.getNextBeginOffset());
                    this.generateOffsetMovedEvent(event);
                    log.warn(
                        "PULL_OFFSET_MOVED:correction offset. topic={}, groupId={}, requestOffset={}, newOffset={}, suggestBrokerId={}",
                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),
                        responseHeader.getSuggestWhichBrokerId());
                } else {
                    // 建议从master broker拉取消息
                    responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());
                    response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);
                    log.warn("PULL_OFFSET_MOVED:none correction. topic={}, groupId={}, requestOffset={}, suggestBrokerId={}",
                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),
                        responseHeader.getSuggestWhichBrokerId());
                }

                break;
            default:
                assert false;
        }
    } else {
        response.setCode(ResponseCode.SYSTEM_ERROR);
        response.setRemark("store getMessage return null");
    }

    // 消费者会在其offsetStore存在未提交的消息位移时将消息位移设置为requestHeader.getCommitOffset()，并设置hasCommitOffsetFlag为
    // true，表示这次拉取请求需要顺便提交消息位移，下面就是处理这种情况的
    boolean storeOffsetEnable = brokerAllowSuspend;
    storeOffsetEnable = storeOffsetEnable && hasCommitOffsetFlag;
    storeOffsetEnable = storeOffsetEnable
        && this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;
    if (storeOffsetEnable) {
        // ConsumerOffsetManager负责管理和持久化消费者提交的消费位移
        this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),
            requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());
    }
    return response;
}
```

`processRequest()`方法很长，不过有很大篇幅是用于判断当前请求是否合法的，这部分就不分析了，直接看源码和源码注释，这里挑出真正处理拉取消息请求的逻辑，最重要的语句是：
```java
final GetMessageResult getMessageResult =
this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),
    requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter);
```

`MessageStore`对象的`getMessage()`方法返回`GetMessageResult`对象，表示拉取结果，代码如下：
```java
public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset,
    final int maxMsgNums,
    final MessageFilter messageFilter) {
    if (this.shutdown) {
        log.warn("message store has shutdown, so getMessage is forbidden");
        return null;
    }

    if (!this.runningFlags.isReadable()) {
        log.warn("message store is not readable, so getMessage is forbidden " + this.runningFlags.getFlagBits());
        return null;
    }

    long beginTime = this.getSystemClock().now();

    GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;
    long nextBeginOffset = offset;
    long minOffset = 0;
    long maxOffset = 0;

    GetMessageResult getResult = new GetMessageResult();

    // 获取当前broker中所有消息的最大位移
    final long maxOffsetPy = this.commitLog.getMaxOffset();

    // 根据topic和队列id找到对应的consumeQueue
    ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);
    if (consumeQueue != null) {
        // 当前队列中消息的最小位移
        minOffset = consumeQueue.getMinOffsetInQueue();
        // 当前队列中消息的最大位移
        maxOffset = consumeQueue.getMaxOffsetInQueue();

        // 验证拉取请求的消息位移是否合法，即是否在minOffset和maxOffset之间
        if (maxOffset == 0) {
            status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;
            nextBeginOffset = nextOffsetCorrection(offset, 0);
        } else if (offset < minOffset) {
            status = GetMessageStatus.OFFSET_TOO_SMALL;
            nextBeginOffset = nextOffsetCorrection(offset, minOffset);
        } else if (offset == maxOffset) {
            status = GetMessageStatus.OFFSET_OVERFLOW_ONE;
            nextBeginOffset = nextOffsetCorrection(offset, offset);
        } else if (offset > maxOffset) {
            status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;
            if (0 == minOffset) {
                nextBeginOffset = nextOffsetCorrection(offset, minOffset);
            } else {
                nextBeginOffset = nextOffsetCorrection(offset, maxOffset);
            }
        } else {
            // 根据消息位移获取具体的ConsumeQueue文件的字节数据
            SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);
            if (bufferConsumeQueue != null) {
                try {
                    status = GetMessageStatus.NO_MATCHED_MESSAGE;

                    // 表示可以拉取的消息的最小值，初始为Long.MIN_VALUE即还没有限制
                    long nextPhyFileStartOffset = Long.MIN_VALUE;
                    // 当前ConsumeQueue文件中遍历到的消息位移的最大值
                    long maxPhyOffsetPulling = 0;

                    int i = 0;
                    // 最大可以拉取的消息个数（其实是消息大小，可以看下面for循环的条件，i的值是每次递增ConsumeQueue.CQ_STORE_UNIT_SIZE，
                    // 即20个字节，所以一次拉取请求最多能够拉取16000/20=800条消息）
                    final int maxFilterMessageCount = Math.max(16000, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);
                    // 是否统计这次拉取的消息的最大值和broker保存的消息的最大值之间的差到brokerStatsManager，默认为true
                    final boolean diskFallRecorded = this.messageStoreConfig.isDiskFallRecorded();
                    ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit();
                    // 遍历consumeQueue的记录
                    for (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {
                        // 消息在commitLog文件中的位移
                        long offsetPy = bufferConsumeQueue.getByteBuffer().getLong();
                        // 消息的大小
                        int sizePy = bufferConsumeQueue.getByteBuffer().getInt();
                        // 消息标签的hashCode
                        long tagsCode = bufferConsumeQueue.getByteBuffer().getLong();

                        // 更新遍历到的消息的最大位移值
                        maxPhyOffsetPulling = offsetPy;

                        // nextPhyFileStartOffset会在下面被更新，主要用于判断当前遍历的位移所在的CommitLog文件是否存在
                        if (nextPhyFileStartOffset != Long.MIN_VALUE) {
                            // 如果nextPhyFileStartOffset的值被设置了并且offsetPy < nextPhyFileStartOffset，说明offsetPy
                            // 这个位移所在的CommitLog文件已经被删除了，没必要执行下面的逻辑了
                            if (offsetPy < nextPhyFileStartOffset)
                                continue;
                        }

                        // 判断当前消息位移值对应的消息是否在磁盘中（如果isInDisk为false表示消息在内存中）
                        boolean isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);

                        // 判断是否应该停止拉取消息了，判断依据是已经保存在getResult中的消息数量或者消息大小加上这次遍历到的消息
                        // 大小是否超过了指定的值，传入isInDisk是因为指定的值在消息存在于磁盘和存在于内存时是不一样的
                        if (this.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),
                            isInDisk)) {
                            break;
                        }

                        boolean extRet = false, isTagsCodeLegal = true;
                        if (consumeQueue.isExtAddr(tagsCode)) {
                            extRet = consumeQueue.getExt(tagsCode, cqExtUnit);
                            if (extRet) {
                                tagsCode = cqExtUnit.getTagsCode();
                            } else {
                                // can't find ext content.Client will filter messages by tag also.
                                log.error("[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}, topic={}, group={}",
                                    tagsCode, offsetPy, sizePy, topic, group);
                                isTagsCodeLegal = false;
                            }
                        }

                        // 根据tagHashCode执行消息过滤
                        if (messageFilter != null
                            && !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) {
                            if (getResult.getBufferTotalSize() == 0) {
                                // 如果消息不匹配并且还没有成功拉取到消息，设置状态为NO_MATCHED_MESSAGE
                                status = GetMessageStatus.NO_MATCHED_MESSAGE;
                            }

                            continue;
                        }

                        // 从commitLog读取指定位移的消息，只要offsetPy的位移所在的CommitLog文件还存在（即还没有从磁盘中被删除）
                        // 则selectResult就不会为空
                        SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);
                        if (null == selectResult) {
                            // 如果结果为空并且这次拉取操作还没有读到过消息，说明当前遍历到的位移所在的CommitLog文件已经被删除了，
                            // rocketmq是有定期删除CommitLog文件的逻辑的
                            if (getResult.getBufferTotalSize() == 0) {
                                status = GetMessageStatus.MESSAGE_WAS_REMOVING;
                            }

                            // 此时将nextPhyFileStartOffset设置为下一个CommitLog文件的起始位移，循环开始会跳过小于
                            // nextPhyFileStartOffset的位移，这样就使得后续不存在对应CommitLog文件的位移会被跳过
                            nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy);
                            continue;
                        }

                        // 按照消息内容进行过滤
                        if (messageFilter != null
                            && !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), null)) {
                            if (getResult.getBufferTotalSize() == 0) {
                                status = GetMessageStatus.NO_MATCHED_MESSAGE;
                            }
                            // release...
                            selectResult.release();
                            continue;
                        }

                        this.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();
                        // 保存消息到结果集
                        getResult.addMessage(selectResult);
                        status = GetMessageStatus.FOUND;
                        nextPhyFileStartOffset = Long.MIN_VALUE;
                    }

                    if (diskFallRecorded) {
                        long fallBehind = maxOffsetPy - maxPhyOffsetPulling;
                        brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);
                    }

                    // 更新下一次应该拉取的消息位移
                    nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);

                    // 计算当前broker的消息的最大位移和这次拉取到的消息的位移的差值
                    long diff = maxOffsetPy - maxPhyOffsetPulling;
                    // 计算允许保存在内存中的消息的大小，默认为物理内存的40%
                    long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE
                        * (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0));
                    // 如果diff > memory说明消费者消费消息的速度慢于生产者生产消息的速度，导致拉取消息会从磁盘读取，此时设置
                    // suggestPullingFromSlave为true表示建议之后的拉取请求从slave拉取
                    getResult.setSuggestPullingFromSlave(diff > memory);
                } finally {
                    bufferConsumeQueue.release();
                }
            } else {
                status = GetMessageStatus.OFFSET_FOUND_NULL;
                nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));
                log.warn("consumer request topic: " + topic + "offset: " + offset + " minOffset: " + minOffset + " maxOffset: "
                    + maxOffset + ", but access logic queue failed.");
            }
        }
    } else {
        // 看findConsumeQueue方法的实现，好像不会存在consumeQueue对象为空的情况
        status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;
        nextBeginOffset = nextOffsetCorrection(offset, 0);
    }

    // 记录统计数据
    if (GetMessageStatus.FOUND == status) {
        this.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();
    } else {
        this.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();
    }
    long elapsedTime = this.getSystemClock().now() - beginTime;
    this.storeStatsService.setGetMessageEntireTimeMax(elapsedTime);

    getResult.setStatus(status);
    // nextBeginOffset为下一次拉取消息时应该拉取的起始位移
    getResult.setNextBeginOffset(nextBeginOffset);
    // maxOffset为当前consumeQueue的消息位移的最大值
    getResult.setMaxOffset(maxOffset);
    // maxOffset为当前consumeQueue的消息位移的最小值
    getResult.setMinOffset(minOffset);
    return getResult;
}
```

`getMessage()`方法主要是根据拉取请求的消息位移获取`ConsumeQueue`对象，并遍历`ConsumeQueue`对象中保存的消息位移记录并通过这个消息位移记录在`CommitLog`对象中找到对应的消息数据，将数据保存在结果集中。`getMessage()`方法在遍历之前校验了拉取请求的位移值的合法性，同时在遍历`ConsumeQueue`对象的消息位移记录时对消息进行了过滤（如果消费者配置了过滤条件），关于消息过滤可以看笔记[如何实现消息过滤](如何实现消息过滤.md)，`getMessage()`方法做的其他工作可以看源码中的注释，这里不再赘述。

回到`PullMessageProcessor`类的`processRequest()`方法，`getMessage()`方法返回后，`processRequest()`方法根据拉取结果执行不同的处理逻辑，首先是根据拉取的结果设置消费者下一次应该向哪个broker发送拉取消息的请求，然后设置响应的状态：
```java
response.setRemark(getMessageResult.getStatus().name());
// nextBeginOffset为下一次拉取消息时应该拉取的起始位移
responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());
// maxOffset为当前consumeQueue的消息位移的最小值
responseHeader.setMinOffset(getMessageResult.getMinOffset());
// maxOffset为当前consumeQueue的消息位移的最大值
responseHeader.setMaxOffset(getMessageResult.getMaxOffset());

// getMessageResult的suggestPullingFromSlave的值会在上面的getMessage方法中被更新，当拉取的消息不在内存中而在磁盘中时，
// suggestPullingFromSlave为true，此时建议消费者从slave读取消息
if (getMessageResult.isSuggestPullingFromSlave()) {
    // getWhichBrokerWhenConsumeSlowly方法默认返回1，也就是默认只建议slave中brokerId等于1的那个
    responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());
} else {
    responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);
}

switch (this.brokerController.getMessageStoreConfig().getBrokerRole()) {
    case ASYNC_MASTER:
    case SYNC_MASTER:
        break;
    case SLAVE:
        // 如果当前broker是slave并且被设置为不可读，则建议消费者从master读取消息
        if (!this.brokerController.getBrokerConfig().isSlaveReadEnable()) {
            // ResponseCode.PULL_RETRY_IMMEDIATELY表示消费者应该立即重新发送拉取消息请求
            response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);
            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);
        }
        break;
}

if (this.brokerController.getBrokerConfig().isSlaveReadEnable()) {
    // consume too slow ,redirect to another machine
    // 这个在上面分析过了，消费者拉取的消息在磁盘中，这里建议消费者从slave拉取消息
    if (getMessageResult.isSuggestPullingFromSlave()) {
        responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());
    }
    // consume ok
    else {
        // 如果拉取的消息在内存，则建议消费者从master broker拉取消息，subscriptionGroupConfig.getBrokerId()默认返回
        // master id
        responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());
    }
} else {
    // 如果slave设置为不可读，则从master broker拉取消息
    responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);
}

// 根据拉取消息的结果设置response的code
switch (getMessageResult.getStatus()) {
    case FOUND: // 拉取到消息了
        response.setCode(ResponseCode.SUCCESS);
        break;
    case MESSAGE_WAS_REMOVING: // 位移对应的CommitLog文件被删除了
        // getMessageResult会包含下一次应该拉取的消息位移的起始值，当CommitLog文件被删除的情况下，让消费者立即重新发送
        // 拉取消息请求即可
        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);
        break;
    case NO_MATCHED_LOGIC_QUEUE:
    case NO_MESSAGE_IN_QUEUE: // 当前队列没有保存消息
        // 没有保存消息的队列对其拉取消息时queueOffset正常应该为0，不为空可能是当前broker为slave，但是还没来得及同步
        // master的消息，这种情况拉取消息请求的消息位移应该修正
        if (0 != requestHeader.getQueueOffset()) {
            response.setCode(ResponseCode.PULL_OFFSET_MOVED);

            // XXX: warn and notify me
            log.info("the broker store no queue data, fix the request offset {} to {}, Topic: {} QueueId: {} Consumer Group: {}",
                requestHeader.getQueueOffset(),
                getMessageResult.getNextBeginOffset(),
                requestHeader.getTopic(),
                requestHeader.getQueueId(),
                requestHeader.getConsumerGroup()
            );
        } else {
            // PULL_NOT_FOUND就是正常的表示没有消息能够被拉取
            response.setCode(ResponseCode.PULL_NOT_FOUND);
        }
        break;
    case NO_MATCHED_MESSAGE: // 消息被过滤了，这个时候消费者应该立即从getMessageResult保存的nextBeginOffset开始再次拉取消息
        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);
        break;
    case OFFSET_FOUND_NULL: // 没有找到consumeQueue文件
        response.setCode(ResponseCode.PULL_NOT_FOUND);
        break;
    case OFFSET_OVERFLOW_BADLY: // 请求的消息位移超出broker的队列保存的最大位移了
        // 这个时候和NO_MESSAGE_IN_QUEUE一样需要修正消息位移
        response.setCode(ResponseCode.PULL_OFFSET_MOVED);
        // XXX: warn and notify me
        log.info("the request offset: {} over flow badly, broker max offset: {}, consumer: {}",
            requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());
        break;
    case OFFSET_OVERFLOW_ONE:
        // 请求的消息位移刚好等于broker的队列保存的消息的最大位移，说明从上次拉取消息后到这次拉取消息这两个请求之间，生产者
        // 没有产生消息
        response.setCode(ResponseCode.PULL_NOT_FOUND);
        break;
    case OFFSET_TOO_SMALL: // 消息位移小于broker的队列保存的最小位移，需要修正
        response.setCode(ResponseCode.PULL_OFFSET_MOVED);
        log.info("the request offset too small. group={}, topic={}, requestOffset={}, brokerMinOffset={}, clientIp={}",
            requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),
            getMessageResult.getMinOffset(), channel.remoteAddress());
        break;
    default:
        assert false;
        break;
}
```

在设置好状态后，再进一步对响应进行处理：
```java
// 更新统计数据，设置response的消息数据
switch (response.getCode()) {
    case ResponseCode.SUCCESS: // 如果拉取消息成功，下面将消息写入响应
        // 增加消费者组拉取的消息数量
        this.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),
            getMessageResult.getMessageCount());

        // 增加消费者组拉取的消息大小
        this.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),
            getMessageResult.getBufferTotalSize());

        // 增加当前broker被拉取消息的数量
        this.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());
        // 如果设置使用Java堆进行消息传输，即通过ByteBuffer.allocate创建ByteBuffer保存消息实体对应的字节，默认为true
        if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {
            final long beginTimeMills = this.brokerController.getMessageStore().now();
            // readGetMessageResult方法返回这里拉取到的消息的所有字节
            final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());
            // 增加readGetMessageResult方法执行的延迟
            this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),
                requestHeader.getTopic(), requestHeader.getQueueId(),
                (int) (this.brokerController.getMessageStore().now() - beginTimeMills));
            response.setBody(r);
        } else {
            try {
                // 否则通过netty的FileRegion完成消息实体向字节的转换并写到channel
                FileRegion fileRegion =
                    new ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);
                channel.writeAndFlush(fileRegion).addListener(new ChannelFutureListener() {
                    @Override
                    public void operationComplete(ChannelFuture future) throws Exception {
                        getMessageResult.release();
                        if (!future.isSuccess()) {
                            log.error("transfer many message by pagecache failed, {}", channel.remoteAddress(), future.cause());
                        }
                    }
                });
            } catch (Throwable e) {
                log.error("transfer many message by pagecache exception", e);
                getMessageResult.release();
            }

            response = null;
        }
        break;
    case ResponseCode.PULL_NOT_FOUND: // 如果没有能够返回的消息

        // 如果当前broker支持挂起，并且这次拉取请求的挂起设置为true，对于push模式的消费者，hasSuspendFlag为true
        if (brokerAllowSuspend && hasSuspendFlag) {
            // suspendTimeoutMillisLong表示挂起操作的超时时间
            long pollingTimeMills = suspendTimeoutMillisLong;
            // 如果没有开启长轮训，则设置挂起操作的超时时间为shortPollingTimeMills，默认1秒
            if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) {
                pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();
            }

            String topic = requestHeader.getTopic();
            long offset = requestHeader.getQueueOffset();
            int queueId = requestHeader.getQueueId();
            // 这个PullRequest对象和消费者端的PullRequest对象不是同一个，这里的PullRequest对象可以认为是被挂起的拉取
            // 消息请求的上下文
            PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,
                this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);
            // 将挂起请求保存到PullRequestHoldService
            this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);
            // 设置response为空，即没有需要返回给消费者的数据，这样消费者的拉取请求会一直等待broker的响应，而broker会通
            // 过PullRequestHoldService对象挂起当前拉取请求，在消费者指定的时间内定时尝试拉取消息，拉取到消息后或者超时
            // 后返回
            response = null;
            break;
        }

    case ResponseCode.PULL_RETRY_IMMEDIATELY:
        break;
    case ResponseCode.PULL_OFFSET_MOVED: // 表示请求的消息位移需要修正
        // 如果当前broker是master或者offsetCheckInSlave为true，发送一个broker自己创建的消息到OFFSET_MOVED_EVENT
        // 这个topic
        if (this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE
            || this.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) {
            MessageQueue mq = new MessageQueue();
            mq.setTopic(requestHeader.getTopic());
            mq.setQueueId(requestHeader.getQueueId());
            mq.setBrokerName(this.brokerController.getBrokerConfig().getBrokerName());

            OffsetMovedEvent event = new OffsetMovedEvent();
            event.setConsumerGroup(requestHeader.getConsumerGroup());
            event.setMessageQueue(mq);
            event.setOffsetRequest(requestHeader.getQueueOffset());
            event.setOffsetNew(getMessageResult.getNextBeginOffset());
            this.generateOffsetMovedEvent(event);
            log.warn(
                "PULL_OFFSET_MOVED:correction offset. topic={}, groupId={}, requestOffset={}, newOffset={}, suggestBrokerId={}",
                requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),
                responseHeader.getSuggestWhichBrokerId());
        } else {
            // 建议从master broker拉取消息
            responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());
            response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);
            log.warn("PULL_OFFSET_MOVED:none correction. topic={}, groupId={}, requestOffset={}, suggestBrokerId={}",
                requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),
                responseHeader.getSuggestWhichBrokerId());
        }

        break;
    default:
        assert false;
}
```

最重要的是对`ResponseCode.SUCCESS`和`ResponseCode.PULL_NOT_FOUND`状态的处理，当状态为`ResponseCode.SUCCESS`时，broker将消息写入响应并返回，如果是`ResponseCode.PULL_NOT_FOUND`的状态，表示还没有能够被消费者消费的消息，此时对于push模式的消费者，就需要挂起请求，在一段时间后再次拉取消息返回，对应的逻辑：
```java
// suspendTimeoutMillisLong表示挂起操作的超时时间
long pollingTimeMills = suspendTimeoutMillisLong;
// 如果没有开启长轮训，则设置挂起操作的超时时间为shortPollingTimeMills，默认1秒
if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) {
    pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();
}

String topic = requestHeader.getTopic();
long offset = requestHeader.getQueueOffset();
int queueId = requestHeader.getQueueId();
// 这个PullRequest对象和消费者端的PullRequest对象不是同一个，这里的PullRequest对象可以认为是被挂起的拉取
// 消息请求的上下文
PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,
    this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);
// 将挂起请求保存到PullRequestHoldService
this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);
// 设置response为空，即没有需要返回给消费者的数据，这样消费者的拉取请求会一直等待broker的响应，而broker会通
// 过PullRequestHoldService对象挂起当前拉取请求，在消费者指定的时间内定时尝试拉取消息，拉取到消息后或者超时
// 后返回
response = null;
break;
```

上面的主要逻辑是设置挂起操作的参数，创建一个`PullRequest`对象用于保存即将被挂起的拉取消息请求的上下文，之后通过`PullRequestHoldService`对象的`suspendPullRequest()`方法实现请求挂起，`PullRequestHoldService`对象的`suspendPullRequest()`方法实现：
```java
public void suspendPullRequest(final String topic, final int queueId, final PullRequest pullRequest) {
    // 创建PullRequest的key，格式为topic@queueId
    String key = this.buildKey(topic, queueId);
    ManyPullRequest mpr = this.pullRequestTable.get(key);
    if (null == mpr) {
        mpr = new ManyPullRequest();
        ManyPullRequest prev = this.pullRequestTable.putIfAbsent(key, mpr);
        if (prev != null) {
            mpr = prev;
        }
    }

    // key相同的PullRequest被放到一个ManyPullRequest对象中
    mpr.addPullRequest(pullRequest);
}
```

上面的实现只是简单的将`PullRequest`对象保存到`pullRequestTable`，`PullRequestHoldService`类继承自`ServiceThread`类，所以其也是个线程，`PullRequestHoldService`类的`run()`方法实现：
```java
@Override
public void run() {
    log.info("{} service started", this.getServiceName());
    while (!this.isStopped()) {
        try {
            // 定时调用checkHoldRequest方法
            if (this.brokerController.getBrokerConfig().isLongPollingEnable()) {
                this.waitForRunning(5 * 1000);
            } else {
                // 没有开启长轮询则使用短轮询，默认1s
                this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills());
            }

            long beginLockTimestamp = this.systemClock.now();
            this.checkHoldRequest();
            long costTime = this.systemClock.now() - beginLockTimestamp;
            if (costTime > 5 * 1000) {
                log.info("[NOTIFYME] check hold request cost {} ms.", costTime);
            }
        } catch (Throwable e) {
            log.warn(this.getServiceName() + " service has exception. ", e);
        }
    }

    log.info("{} service end", this.getServiceName());
}
```

`run()`方法定时调用`checkHoldRequest()`方法：
```java
private void checkHoldRequest() {
    // 遍历所有的key，相当于遍历所有的topic和queueId的组合
    for (String key : this.pullRequestTable.keySet()) {
        String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);
        if (2 == kArray.length) {
            String topic = kArray[0];
            int queueId = Integer.parseInt(kArray[1]);
            // 获取当前broker的指定topic下指定queue的最大消息位移
            final long offset = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);
            try {
                // 通知消息位移的值
                this.notifyMessageArriving(topic, queueId, offset);
            } catch (Throwable e) {
                log.error("check hold request failed. topic={}, queueId={}", topic, queueId, e);
            }
        }
    }
}
```

`checkHoldRequest()`方法获取broker中指定topic的指定队列保存的消息的最大位移值，再调用`notifyMessageArriving()`方法处理这个值，`notifyMessageArriving()`方法代码：
```java
public void notifyMessageArriving(final String topic, final int queueId, final long maxOffset) {
    notifyMessageArriving(topic, queueId, maxOffset, null, 0, null, null);
}

public void notifyMessageArriving(final String topic, final int queueId, final long maxOffset, final Long tagsCode,
    long msgStoreTime, byte[] filterBitMap, Map<String, String> properties) {
    String key = this.buildKey(topic, queueId);
    ManyPullRequest mpr = this.pullRequestTable.get(key);
    if (mpr != null) {
        // 获取当前topic下的queue的所有PullRequest
        List<PullRequest> requestList = mpr.cloneListAndClear();
        if (requestList != null) {
            List<PullRequest> replayList = new ArrayList<PullRequest>();

            for (PullRequest request : requestList) {
                // maxOffset为当前broker保存的当前topic下的queue的最大消息位移
                long newestOffset = maxOffset;
                if (newestOffset <= request.getPullFromThisOffset()) {
                    newestOffset = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);
                }

                if (newestOffset > request.getPullFromThisOffset()) {
                    // 判断消息是否匹配
                    boolean match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,
                        new ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));
                    // match by bit map, need eval again when properties is not null.
                    if (match && properties != null) {
                        match = request.getMessageFilter().isMatchedByCommitLog(null, properties);
                    }

                    if (match) {
                        try {
                            // executeRequestWhenWakeup方法实际上是调用PullMessageProcessor的processRequest方法再次
                            // 执行一次拉取请求的处理，因为此时broker的消息位移已经满足返回给消费者的条件了，注意executeRequestWhenWakeup
                            // 方法执行processRequest方法时设置了brokerAllowSuspend为false，即关闭这次处理拉取请求过程的挂起
                            // 使得请求能够立即返回，无论是否能够获取到消息
                            this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),
                                request.getRequestCommand());
                        } catch (Throwable e) {
                            log.error("execute request when wakeup failed.", e);
                        }
                        continue;
                    }
                }

                // 如果到了挂起的时间限制，则直接再次处理拉取请求
                if (System.currentTimeMillis() >= (request.getSuspendTimestamp() + request.getTimeoutMillis())) {
                    try {
                        this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),
                            request.getRequestCommand());
                    } catch (Throwable e) {
                        log.error("execute request when wakeup failed.", e);
                    }
                    continue;
                }

                // 保存没有满足返回条件的拉取请求
                replayList.add(request);
            }

            if (!replayList.isEmpty()) {
                // 等下次再判断是否能够返回这些请求
                mpr.addPullRequest(replayList);
            }
        }
    }
}
```

`notifyMessageArriving()`方法遍历`PullRequest`对象，如果当前队列的消息的最大位移值满足被`PullRequest`对象拉取的条件，则调用`PullMessageProcessor`对象的`executeRequestWhenWakeup()`方法，该方法代码：
```java
public void executeRequestWhenWakeup(final Channel channel,
    final RemotingCommand request) throws RemotingCommandException {
    Runnable run = new Runnable() {
        @Override
        public void run() {
            try {
                // 这里设置brokerAllowSuspend为false使得这次拉取请求即使没有能够被消费者消费的消息，也会返回而不会被挂起
                final RemotingCommand response = PullMessageProcessor.this.processRequest(channel, request, false);

                if (response != null) {
                    response.setOpaque(request.getOpaque());
                    response.markResponseType();
                    try {
                        channel.writeAndFlush(response).addListener(new ChannelFutureListener() {
                            @Override
                            public void operationComplete(ChannelFuture future) throws Exception {
                                if (!future.isSuccess()) {
                                    log.error("processRequestWrapper response to {} failed",
                                        future.channel().remoteAddress(), future.cause());
                                    log.error(request.toString());
                                    log.error(response.toString());
                                }
                            }
                        });
                    } catch (Throwable e) {
                        log.error("processRequestWrapper process request over, but response failed", e);
                        log.error(request.toString());
                        log.error(response.toString());
                    }
                }
            } catch (RemotingCommandException e1) {
                log.error("excuteRequestWhenWakeup run", e1);
            }
        }
    };
    this.brokerController.getPullMessageExecutor().submit(new RequestTask(run, channel, request));
}
```

`executeRequestWhenWakeup()`方法异步调用`PullMessageProcessor`对象的`processRequest()`方法，相当于再次执行拉取消息请求.`processRequest()`方法的参数是根据`PullRequest`对象得到的，同时需要注意的是参数`brokerAllowSuspend`被设置为false，这将使得这个再次发起的请求不会被挂起。另外一个关键点在于`PullRequest`对象持有最初的拉取消息请求的`Channel`，使得broker能够在一段时间后通过这个`Channel`返回响应给消费者。

以上是broker对消费者拉取消息的请求的处理，下面回到消费者端，看看消费者是如何处理响应的，对应的方法在`MQClientAPIImpl`类的`pullMessageAsync()`方法：
```java
private void pullMessageAsync(
    final String addr,
    final RemotingCommand request,
    final long timeoutMillis,
    final PullCallback pullCallback
) throws RemotingException, InterruptedException {
    this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() {
        @Override
        public void operationComplete(ResponseFuture responseFuture) {
            RemotingCommand response = responseFuture.getResponseCommand();
            if (response != null) {
                try {
                    // 处理broker发回来的响应
                    PullResult pullResult = MQClientAPIImpl.this.processPullResponse(response);
                    assert pullResult != null;
                    pullCallback.onSuccess(pullResult);
                } catch (Exception e) {
                    pullCallback.onException(e);
                }
            } else {
                if (!responseFuture.isSendRequestOK()) {
                    pullCallback.onException(new MQClientException("send request failed to " + addr + ". Request: " + request, responseFuture.getCause()));
                } else if (responseFuture.isTimeout()) {
                    pullCallback.onException(new MQClientException("wait response from " + addr + " timeout :" + responseFuture.getTimeoutMillis() + "ms" + ". Request: " + request,
                        responseFuture.getCause()));
                } else {
                    pullCallback.onException(new MQClientException("unknown reason. addr: " + addr + ", timeoutMillis: " + timeoutMillis + ". Request: " + request, responseFuture.getCause()));
                }
            }
        }
    });
}
```

如果请求没有发生异常，则由`MQClientAPIImpl`类的`processPullResponse()`方法处理响应，并通过传入的`PullCallback`对象的`onSuccess()`方法处理结果，这里先看`processPullResponse()`方法代码：
```java
private PullResult processPullResponse(
    final RemotingCommand response) throws MQBrokerException, RemotingCommandException {
    PullStatus pullStatus = PullStatus.NO_NEW_MSG;
    switch (response.getCode()) {
        case ResponseCode.SUCCESS: // 成功拉取到消息
            pullStatus = PullStatus.FOUND;
            break;
        case ResponseCode.PULL_NOT_FOUND: // 没有需要消费的消息
            pullStatus = PullStatus.NO_NEW_MSG;
            break;
        case ResponseCode.PULL_RETRY_IMMEDIATELY: // 应该立即重新发起拉取消息请求
            pullStatus = PullStatus.NO_MATCHED_MSG;
            break;
        case ResponseCode.PULL_OFFSET_MOVED: // 消息位移需要修正
            pullStatus = PullStatus.OFFSET_ILLEGAL;
            break;

        default:
            throw new MQBrokerException(response.getCode(), response.getRemark());
    }

    PullMessageResponseHeader responseHeader =
        (PullMessageResponseHeader) response.decodeCommandCustomHeader(PullMessageResponseHeader.class);

    return new PullResultExt(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),
        responseHeader.getMaxOffset(), null, responseHeader.getSuggestWhichBrokerId(), response.getBody());
}
```

`processPullResponse()`方法根据响应的code设置`pullStatus`，并创建`PullResultExt`对象返回，`PullResultExt`对象的处理在`PullCallback`类的`onSuccess()`方法，`PullCallback`对象是`DefaultMQPushConsumerImpl`类的`pullMessage()`方法创建的匿名内部类的实例，代码：
```java
public void pullMessage(final PullRequest pullRequest) {
    // 略...

    // 拉取消息成功后的回调函数
    PullCallback pullCallback = new PullCallback() {
        @Override
        public void onSuccess(PullResult pullResult) {
            if (pullResult != null) {
                // processPullResult方法再次根据标签对消息进行过滤，如果存在FilterMessageHook，则也会通过FilterMessageHook
                // 对象对消息进行过滤。processPullResult方法在过滤完成后为所有拉取到的消息设置了一些属性
                pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,
                    subscriptionData);

                switch (pullResult.getPullStatus()) {
                    case FOUND: // 成功拉取到消息
                        // 这次拉取消息请求的起始消息位移
                        long prevRequestOffset = pullRequest.getNextOffset();
                        // pullResult.getNextBeginOffset()的值为broker返回的下一次拉取请求应该拉取的消息位移
                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());
                        long pullRT = System.currentTimeMillis() - beginTimestamp;
                        // 统计拉取时间
                        DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),
                            pullRequest.getMessageQueue().getTopic(), pullRT);

                        long firstMsgOffset = Long.MAX_VALUE;
                        if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {
                            // 拉取到的消息为空则再次尝试拉取
                            DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
                        } else {
                            // 获取位移最小的消息的位移
                            firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();

                            // 统计拉取的消息数量
                            DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),
                                pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());

                            // putMessage方法将消息保存到processQueue对象的msgTreeMap属性，并根据拉取结果计算统计数据，如
                            // 拉取到的消息总数量、总大小、还有多少消息没有被消费等
                            boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());
                            // consumeMessageService就是ConsumeMessageConcurrentlyService或者ConsumeMessageOrderlyService
                            // 并发或者按顺序消费消息，这里的submitConsumeRequest方法会通过线程池异步消费消息，所以不用等待消息消费
                            // 完成就能够在下面决定是否立即再次拉取消息
                            DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(
                                pullResult.getMsgFoundList(),
                                processQueue,
                                pullRequest.getMessageQueue(),
                                dispatchToConsume);

                            // 根据配置决定什么时候再次拉取消息
                            if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) {
                                DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,
                                    DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());
                            } else {
                                DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
                            }
                        }

                        // 理论上不会发生这个情况
                        if (pullResult.getNextBeginOffset() < prevRequestOffset
                            || firstMsgOffset < prevRequestOffset) {
                            log.warn(
                                "[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}",
                                pullResult.getNextBeginOffset(),
                                firstMsgOffset,
                                prevRequestOffset);
                        }

                        break;
                    case NO_NEW_MSG: // 没有需要消费的消息
                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());

                        // 更新offsetStore的消费位移
                        DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);

                        // 再次尝试拉取消息
                        DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
                        break;
                    case NO_MATCHED_MSG: // broker返回的响应的code为PULL_RETRY_IMMEDIATELY
                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());

                        // 更新offsetStore的消费位移
                        DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);

                        // 再次尝试拉取消息
                        DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
                        break;
                    case OFFSET_ILLEGAL: // 拉取请求的消息位移不合法
                        log.warn("the pull request offset illegal, {} {}",
                            pullRequest.toString(), pullResult.toString());
                        // pullResult.getNextBeginOffset()的值是broker返回的正确的消息位移的值
                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());

                        // 先取消消费当前队列
                        pullRequest.getProcessQueue().setDropped(true);
                        // 1秒后执行
                        DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    // 将broker返回的正确的消息位移的值保存到offsetStore
                                    DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),
                                        pullRequest.getNextOffset(), false);

                                    // 持久化消息位移，对于集群模式，实际上就是提交offsetStore中保存的当前队列的消费位移
                                    DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());

                                    // 当前消费者不在消费这个不合法的消息位移对应的队列
                                    DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());

                                    log.warn("fix the pull request offset, {}", pullRequest);
                                } catch (Throwable e) {
                                    log.error("executeTaskLater Exception", e);
                                }
                            }
                        }, 10000);
                        break;
                    default:
                        break;
                }
            }
        }

        @Override
        public void onException(Throwable e) {
            if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
                log.warn("execute the pull request exception", e);
            }

            // 发生异常时过一段时间再尝试拉取消息
            DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);
        }
    };


    // 略...
}
```

`PullCallback`对象的`onSuccess()`方法负责成功拉取消息后的处理，该方法首先调用`PullAPIWrapper`对象的`processPullResult()`方法对拉取到的消息进行过滤，并为消息设置一些属性，代码：
```java
public PullResult processPullResult(final MessageQueue mq, final PullResult pullResult,
    final SubscriptionData subscriptionData) {
    PullResultExt pullResultExt = (PullResultExt) pullResult;

    // 设置下一次从哪个broker拉取消息
    this.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId());
    // 如果成功拉取到消息
    if (PullStatus.FOUND == pullResult.getPullStatus()) {
        // messageBinary就是响应的body
        ByteBuffer byteBuffer = ByteBuffer.wrap(pullResultExt.getMessageBinary());
        // 获取拉取到的所有消息
        List<MessageExt> msgList = MessageDecoder.decodes(byteBuffer);

        List<MessageExt> msgListFilterAgain = msgList;
        // 因为broker是基于tag的hashCode过滤的，所以这里需要对标签进行精确过滤
        if (!subscriptionData.getTagsSet().isEmpty() && !subscriptionData.isClassFilterMode()) {
            msgListFilterAgain = new ArrayList<MessageExt>(msgList.size());
            for (MessageExt msg : msgList) {
                if (msg.getTags() != null) {
                    if (subscriptionData.getTagsSet().contains(msg.getTags())) {
                        msgListFilterAgain.add(msg);
                    }
                }
            }
        }

        // 如果存在hook则调用
        if (this.hasHook()) {
            FilterMessageContext filterMessageContext = new FilterMessageContext();
            filterMessageContext.setUnitMode(unitMode);
            // msgListFilterAgain包含了在上面根据标签精确过滤后拉取到的消息
            filterMessageContext.setMsgList(msgListFilterAgain);
            this.executeHook(filterMessageContext);
        }

        // 遍历经过过滤后最终的消息
        for (MessageExt msg : msgListFilterAgain) {
            // 如果是事物消息的话
            String traFlag = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);
            if (Boolean.parseBoolean(traFlag)) {
                msg.setTransactionId(msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));
            }
            // 将broker中保存在这次拉取消息请求对应的队列的消息的最小位移和最大位移保存到消息的属性中
            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MIN_OFFSET,
                Long.toString(pullResult.getMinOffset()));
            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MAX_OFFSET,
                Long.toString(pullResult.getMaxOffset()));
        }

        // 更新拉取消息结果中消息的结果集
        pullResultExt.setMsgFoundList(msgListFilterAgain);
    }

    // 清除响应的body
    pullResultExt.setMessageBinary(null);

    return pullResult;
}
```

`processPullResult()`方法为过滤后的消息添加了`MessageConst.PROPERTY_MAX_OFFSET`属性，这个属性的值等于`pullResult.getMaxOffset()`，而`pullResult.getMaxOffset()`的值是在`DefaultMessageStore`类的`getMessage()`方法中设置的，等于拉取消息请求对应的`consumeQueue`所保存的消息中位移的最大值，通过这个值就能`consumeQueue`所对应的队列里最新的消息位移是多少。

`processPullResult()`方法之后比较重要的逻辑是`case FOUND`中下面的语句：
```java
// putMessage方法将消息保存到processQueue对象的msgTreeMap属性，并根据拉取结果计算统计数据，如
// 拉取到的消息总数量、总大小、还有多少消息没有被消费等
boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());
// consumeMessageService就是ConsumeMessageConcurrentlyService或者ConsumeMessageOrderlyService
// 并发或者按顺序消费消息，这里的submitConsumeRequest方法会通过线程池异步消费消息，所以不用等待消息消费
// 完成就能够在下面决定是否立即再次拉取消息
DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(
    pullResult.getMsgFoundList(),
    processQueue,
    pullRequest.getMessageQueue(),
    dispatchToConsume);
```

`ProcessQueue`类的`putMessage()`方法主要是根据拉取结果统计一些指标，同时会过滤掉已经拉取过的消息，尽量防止重复消费：
```java
public boolean putMessage(final List<MessageExt> msgs) {
    boolean dispatchToConsume = false;
    try {
        this.lockTreeMap.writeLock().lockInterruptibly();
        try {
            int validMsgCnt = 0;
            for (MessageExt msg : msgs) {
                // 以消息位移为key，消息为value
                MessageExt old = msgTreeMap.put(msg.getQueueOffset(), msg);
                // old为空说明消息还没有被拉取过，否则说明消息被当前消费者重复拉取了
                if (null == old) {
                    // 记录非重复的消息数量
                    validMsgCnt++;
                    // 更新拉取到的消息的位移的最大值
                    this.queueOffsetMax = msg.getQueueOffset();
                    // 更新拉取到的消息总大小
                    msgSize.addAndGet(msg.getBody().length);
                }
            }
            // 更新拉取到的消息的总数
            msgCount.addAndGet(validMsgCnt);

            if (!msgTreeMap.isEmpty() && !this.consuming) {
                dispatchToConsume = true;
                this.consuming = true;
            }

            if (!msgs.isEmpty()) {
                MessageExt messageExt = msgs.get(msgs.size() - 1);
                // 获取broker中这次拉取消息请求对应的队列保存的消息的最大位移
                String property = messageExt.getProperty(MessageConst.PROPERTY_MAX_OFFSET);
                if (property != null) {
                    // 计算上面获取到的broker中的位移值和这次拉取到的消息的最大位移值的差，相当于计算还有多少消息位移没有被消费
                    long accTotal = Long.parseLong(property) - messageExt.getQueueOffset();
                    if (accTotal > 0) {
                        this.msgAccCnt = accTotal;
                    }
                }
            }
        } finally {
            this.lockTreeMap.writeLock().unlock();
        }
    } catch (InterruptedException e) {
        log.error("putMessage exception", e);
    }

    return dispatchToConsume;
}
```

`ConsumeMessageService`类的`submitConsumeRequest()`方法就是真正执行消息消费的地方，`ConsumeMessageService`类有两个实现类：`ConsumeMessageConcurrentlyService`和`ConsumeMessageOrderlyService`，分别用于正常消费消息和顺序消费消息，关于`ConsumeMessageOrderlyService`类的实现，可以看笔记[如何实现顺序消费](如何实现顺序消费.md)，这里主要分析`ConsumeMessageConcurrentlyService`类的实现。首先是`ConsumeMessageService`类实例的初始化，实现在`DefaultMQPushConsumerImpl`类的`start()`方法：
```java
public synchronized void start() throws MQClientException {
    switch (this.serviceState) {
        case CREATE_JUST:
            // 略...

            // ConsumeMessageService负责持有和配置消费消息的线程池
            if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {
                this.consumeOrderly = true;
                this.consumeMessageService =
                    new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
            } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {
                this.consumeOrderly = false;
                this.consumeMessageService =
                    new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
            }

            // 略...
    }

    // 略...
}
```

上面的逻辑是，根据用于创建的`MessageListener`对象的类型来决定`ConsumeMessageService`的类型，如最开始的demo所示，对于没有顺序消费要求的消费者，`MessageListener`为`MessageListenerConcurrently`类型的：
```java
consumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                    ConsumeConcurrentlyContext context) {
        if (CollectionUtils.isNotEmpty(msgs)) {
            final List<String> msgBodies = msgs.stream().map((item) -> new String(item.getBody())).collect(Collectors.toList());

            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgBodies);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }

        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
})
```

下面再看看`ConsumeMessageConcurrentlyService`类的实现，下面是`ConsumeMessageConcurrentlyService`类的源码：
```java
public class ConsumeMessageConcurrentlyService implements ConsumeMessageService {
    private static final InternalLogger log = ClientLogger.getLog();
    private final DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;
    private final DefaultMQPushConsumer defaultMQPushConsumer;
    private final MessageListenerConcurrently messageListener;
    private final BlockingQueue<Runnable> consumeRequestQueue;
    private final ThreadPoolExecutor consumeExecutor;
    private final String consumerGroup;

    private final ScheduledExecutorService scheduledExecutorService;
    private final ScheduledExecutorService cleanExpireMsgExecutors;

    public ConsumeMessageConcurrentlyService(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,
        MessageListenerConcurrently messageListener) {
        this.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;
        // messageListener就是用户编写的消息消费逻辑
        this.messageListener = messageListener;

        // 通过defaultMQPushConsumer能够获取到配置
        this.defaultMQPushConsumer = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();
        // 当前消费者的消费者组
        this.consumerGroup = this.defaultMQPushConsumer.getConsumerGroup();
        this.consumeRequestQueue = new LinkedBlockingQueue<Runnable>();

        // 初始化线程池
        this.consumeExecutor = new ThreadPoolExecutor(
            this.defaultMQPushConsumer.getConsumeThreadMin(), // 默认20
            this.defaultMQPushConsumer.getConsumeThreadMax(), // 默认20
            1000 * 60,
            TimeUnit.MILLISECONDS,
            this.consumeRequestQueue, // 使用无界同步队列
            new ThreadFactoryImpl("ConsumeMessageThread_"));

        // 初始化一个单线程的线程池，专门用于提交消费请求
        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl("ConsumeMessageScheduledThread_"));
        // 初始化一个单线程的线程池，专门用于检查消息消费时候超时，超时则发送给broker，broker会将消息保存到retry topic
        this.cleanExpireMsgExecutors = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl("CleanExpireMsgScheduledThread_"));
    }

    public void start() {
        // 定时执行cleanExpireMsg方法，cleanExpireMsg方法会检查消息是否消费超时，如果超时则会发送CONSUMER_SEND_MSG_BACK请求给broker，
        // 请求中带有消费超时的消息，broker会将消息保存到重试队列
        this.cleanExpireMsgExecutors.scheduleAtFixedRate(new Runnable() {

            @Override
            public void run() {
                cleanExpireMsg();
            }

        }, this.defaultMQPushConsumer.getConsumeTimeout(), this.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);
    }

    public void shutdown() {
        this.scheduledExecutorService.shutdown();
        this.consumeExecutor.shutdown();
        this.cleanExpireMsgExecutors.shutdown();
    }

    @Override
    public void updateCorePoolSize(int corePoolSize) {
        if (corePoolSize > 0
            && corePoolSize <= Short.MAX_VALUE
            && corePoolSize < this.defaultMQPushConsumer.getConsumeThreadMax()) {
            this.consumeExecutor.setCorePoolSize(corePoolSize);
        }
    }

    @Override
    public void incCorePoolSize() {
        // long corePoolSize = this.consumeExecutor.getCorePoolSize();
        // if (corePoolSize < this.defaultMQPushConsumer.getConsumeThreadMax())
        // {
        // this.consumeExecutor.setCorePoolSize(this.consumeExecutor.getCorePoolSize()
        // + 1);
        // }
        // log.info("incCorePoolSize Concurrently from {} to {}, ConsumerGroup:
        // {}",
        // corePoolSize,
        // this.consumeExecutor.getCorePoolSize(),
        // this.consumerGroup);
    }

    @Override
    public void decCorePoolSize() {
        // long corePoolSize = this.consumeExecutor.getCorePoolSize();
        // if (corePoolSize > this.defaultMQPushConsumer.getConsumeThreadMin())
        // {
        // this.consumeExecutor.setCorePoolSize(this.consumeExecutor.getCorePoolSize()
        // - 1);
        // }
        // log.info("decCorePoolSize Concurrently from {} to {}, ConsumerGroup:
        // {}",
        // corePoolSize,
        // this.consumeExecutor.getCorePoolSize(),
        // this.consumerGroup);
    }

    @Override
    public int getCorePoolSize() {
        return this.consumeExecutor.getCorePoolSize();
    }

    @Override
    // 直接消费指定消息，该方法不会影响消费者的消息位移，通常也不会被使用，下面的实现在ConsumeRequest类的run方法中也都分析过了
    public ConsumeMessageDirectlyResult consumeMessageDirectly(MessageExt msg, String brokerName) {
        ConsumeMessageDirectlyResult result = new ConsumeMessageDirectlyResult();
        result.setOrder(false);
        result.setAutoCommit(true);

        List<MessageExt> msgs = new ArrayList<MessageExt>();
        msgs.add(msg);
        MessageQueue mq = new MessageQueue();
        mq.setBrokerName(brokerName);
        mq.setTopic(msg.getTopic());
        mq.setQueueId(msg.getQueueId());

        ConsumeConcurrentlyContext context = new ConsumeConcurrentlyContext(mq);

        this.defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, this.consumerGroup);

        final long beginTime = System.currentTimeMillis();

        log.info("consumeMessageDirectly receive new message: {}", msg);

        try {
            ConsumeConcurrentlyStatus status = this.messageListener.consumeMessage(msgs, context);
            if (status != null) {
                switch (status) {
                    case CONSUME_SUCCESS:
                        result.setConsumeResult(CMResult.CR_SUCCESS);
                        break;
                    case RECONSUME_LATER:
                        result.setConsumeResult(CMResult.CR_LATER);
                        break;
                    default:
                        break;
                }
            } else {
                result.setConsumeResult(CMResult.CR_RETURN_NULL);
            }
        } catch (Throwable e) {
            result.setConsumeResult(CMResult.CR_THROW_EXCEPTION);
            result.setRemark(RemotingHelper.exceptionSimpleDesc(e));

            log.warn(String.format("consumeMessageDirectly exception: %s Group: %s Msgs: %s MQ: %s",
                RemotingHelper.exceptionSimpleDesc(e),
                ConsumeMessageConcurrentlyService.this.consumerGroup,
                msgs,
                mq), e);
        }

        result.setSpentTimeMills(System.currentTimeMillis() - beginTime);

        log.info("consumeMessageDirectly Result: {}", result);

        return result;
    }

    @Override
    public void submitConsumeRequest(
        final List<MessageExt> msgs,
        final ProcessQueue processQueue,
        final MessageQueue messageQueue,
        final boolean dispatchToConsume) {
        // 获取一次能够批量消费消息的数量，默认为1
        final int consumeBatchSize = this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();
        if (msgs.size() <= consumeBatchSize) {
            // 消息数量在限定值以下直接创建ConsumeRequest对象并提交给consumeExecutor线程池进行消费
            ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue);
            try {
                // ConsumeRequest类实现了Runnable接口，这里执行submit相当于执行ConsumeRequest类的run方法
                this.consumeExecutor.submit(consumeRequest);
            } catch (RejectedExecutionException e) {
                // 线程池慢了导致拒绝执行时过一段时间再执行
                this.submitConsumeRequestLater(consumeRequest);
            }
        } else {
            // 如果消息数量超过了一次能够批量消费的值，则分批消费
            for (int total = 0; total < msgs.size(); ) {
                List<MessageExt> msgThis = new ArrayList<MessageExt>(consumeBatchSize);
                // 组成批量消息
                for (int i = 0; i < consumeBatchSize; i++, total++) {
                    if (total < msgs.size()) {
                        msgThis.add(msgs.get(total));
                    } else {
                        break;
                    }
                }

                ConsumeRequest consumeRequest = new ConsumeRequest(msgThis, processQueue, messageQueue);
                try {
                    this.consumeExecutor.submit(consumeRequest);
                } catch (RejectedExecutionException e) {
                    for (; total < msgs.size(); total++) {
                        msgThis.add(msgs.get(total));
                    }

                    // 线程池慢了导致拒绝执行时过一段时间再执行
                    this.submitConsumeRequestLater(consumeRequest);
                }
            }
        }
    }


    private void cleanExpireMsg() {
        // 遍历当前消费者负责消费的队列
        Iterator<Map.Entry<MessageQueue, ProcessQueue>> it =
            this.defaultMQPushConsumerImpl.getRebalanceImpl().getProcessQueueTable().entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<MessageQueue, ProcessQueue> next = it.next();
            ProcessQueue pq = next.getValue();
            // cleanExpiredMsg方法会将消费时间超时的消息发送回broker，broker会将消息保存到retry topic
            pq.cleanExpiredMsg(this.defaultMQPushConsumer);
        }
    }

    public void processConsumeResult(
        final ConsumeConcurrentlyStatus status,
        final ConsumeConcurrentlyContext context,
        final ConsumeRequest consumeRequest
    ) {
        // 获取批量消息消费成功的位置，注意通常用户编写的消费逻辑不会修改这个值，而这个值的默认值为Integer.MAX_VALUE，即不发生异常的情
        // 况下默认认为所有消息消费成功，消费逻辑可以修改这个值以实现只确认消费批量消息的指定位置及该位置之前的消息
        int ackIndex = context.getAckIndex();

        if (consumeRequest.getMsgs().isEmpty())
            return;

        switch (status) {
            case CONSUME_SUCCESS: // 消费成功
                // ackIndex默认等于Integer.MAX_VALUE，所以这里需要修正该值
                if (ackIndex >= consumeRequest.getMsgs().size()) {
                    ackIndex = consumeRequest.getMsgs().size() - 1;
                }
                // 消费成功的消息个数
                int ok = ackIndex + 1;
                // 成功的数量不等于批量消息的数量则认为消费失败
                int failed = consumeRequest.getMsgs().size() - ok;
                // 统计消费结果
                this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);
                this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);
                break;
            case RECONSUME_LATER:
                ackIndex = -1;
                this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),
                    consumeRequest.getMsgs().size());
                break;
            default:
                break;
        }

        switch (this.defaultMQPushConsumer.getMessageModel()) {
            case BROADCASTING:
                // 广播模式消费失败的消息只是记录日志，不做补偿操作
                for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) {
                    MessageExt msg = consumeRequest.getMsgs().get(i);
                    log.warn("BROADCASTING, the message consume failed, drop it, {}", msg.toString());
                }
                break;
            case CLUSTERING:
                // 集群模式需要完成消息重试逻辑
                List<MessageExt> msgBackFailed = new ArrayList<MessageExt>(consumeRequest.getMsgs().size());
                // 遍历ackIndex + 1及之后的消息，即消费失败的消息
                for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) {
                    MessageExt msg = consumeRequest.getMsgs().get(i);
                    // 发送消息给broker，broker会将消息保存到retry topic
                    boolean result = this.sendMessageBack(msg, context);
                    if (!result) {
                        // 发送失败增加重试次数，即保存到msgBackFailed记录下来
                        msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
                        msgBackFailed.add(msg);
                    }
                }

                if (!msgBackFailed.isEmpty()) {
                    // 从批量消息集合中移除发送失败的消息，剩下的消息是消费成功和发送给broker成功的消息
                    consumeRequest.getMsgs().removeAll(msgBackFailed);

                    // 发送给broker失败的消息一段时间后直接在消费者端重新尝试消费
                    this.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());
                }
                break;
            default:
                break;
        }

        // 从ProcessQueue中移除消费成功和消费失败后发送回broker成功的消息，如果移除消息完成后，ProcessQueue中还保留着消息，则
        // removeMessage方法的返回值为移除之后ProcessQueue保存的消息中位移的最小值，如果移除之前ProcessQueue保存的消息为空，则返回
        // 值为-1（通常不会出现这种情况，因为ProcessQueue中只是会包含下面传入的这些消息），如果移除之后ProcessQueue保存的消息为空，
        // 则返回ProcessQueue保存过的消息中位移的最大值，通过removeMessage的这种实现机制，再加上下面的updateOffset方法，就实现了消息
        // 消费后的自动提交
        long offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());
        if (offset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
            // 更新offsetStore中指定队列的消息位移，这里updateOffset方法的increaseOnly为true，表示offsetStore中指定队列的消息位移
            // 如果小于传入的offset的话才更新，否则不更新，这种机制就是消息位移自动提交的关键
            this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true);
        }
    }

    public ConsumerStatsManager getConsumerStatsManager() {
        return this.defaultMQPushConsumerImpl.getConsumerStatsManager();
    }

    public boolean sendMessageBack(final MessageExt msg, final ConsumeConcurrentlyContext context) {
        int delayLevel = context.getDelayLevelWhenNextConsume();

        // Wrap topic with namespace before sending back message.
        msg.setTopic(this.defaultMQPushConsumer.withNamespace(msg.getTopic()));
        try {
            this.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName());
            return true;
        } catch (Exception e) {
            log.error("sendMessageBack exception, group: " + this.consumerGroup + " msg: " + msg.toString(), e);
        }

        return false;
    }

    private void submitConsumeRequestLater(
        final List<MessageExt> msgs,
        final ProcessQueue processQueue,
        final MessageQueue messageQueue
    ) {

        this.scheduledExecutorService.schedule(new Runnable() {

            @Override
            public void run() {
                ConsumeMessageConcurrentlyService.this.submitConsumeRequest(msgs, processQueue, messageQueue, true);
            }
        }, 5000, TimeUnit.MILLISECONDS);
    }

    private void submitConsumeRequestLater(final ConsumeRequest consumeRequest
    ) {
        // ConsumeRequest提交给线程池执行时如果被拒绝了，则5秒后再次提交
        this.scheduledExecutorService.schedule(new Runnable() {

            @Override
            public void run() {
                ConsumeMessageConcurrentlyService.this.consumeExecutor.submit(consumeRequest);
            }
        }, 5000, TimeUnit.MILLISECONDS);
    }

    class ConsumeRequest implements Runnable {
        private final List<MessageExt> msgs;
        private final ProcessQueue processQueue;
        private final MessageQueue messageQueue;

        public ConsumeRequest(List<MessageExt> msgs, ProcessQueue processQueue, MessageQueue messageQueue) {
            this.msgs = msgs;
            this.processQueue = processQueue;
            this.messageQueue = messageQueue;
        }

        public List<MessageExt> getMsgs() {
            return msgs;
        }

        public ProcessQueue getProcessQueue() {
            return processQueue;
        }

        @Override
        public void run() {
            // 如果processQueue已经不由当前消费者消费，直接返回
            if (this.processQueue.isDropped()) {
                log.info("the message queue not be able to consume, because it's dropped. group={} {}", ConsumeMessageConcurrentlyService.this.consumerGroup, this.messageQueue);
                return;
            }

            // MessageListenerConcurrently就是用户实现的消息消费逻辑
            MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.this.messageListener;
            // 消费逻辑通过ConsumeConcurrentlyContext对象能够改变确认消费成功的消息位置，实现方式在processConsumeResult方法能看到
            ConsumeConcurrentlyContext context = new ConsumeConcurrentlyContext(messageQueue);
            // ConsumeConcurrentlyStatus为消费结果，有CONSUME_SUCCESS和RECONSUME_LATER
            ConsumeConcurrentlyStatus status = null;
            // 如果消息的topic为retry topic，则恢复消息的topic为原始的topic，如果topic存在namespace，则移除namespace
            defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup());

            ConsumeMessageContext consumeMessageContext = null;
            // 存在hook则调用hook的before方法
            if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
                consumeMessageContext = new ConsumeMessageContext();
                consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());
                consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());
                consumeMessageContext.setProps(new HashMap<String, String>());
                consumeMessageContext.setMq(messageQueue);
                consumeMessageContext.setMsgList(msgs);
                consumeMessageContext.setSuccess(false);
                ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);
            }

            long beginTimestamp = System.currentTimeMillis();
            boolean hasException = false;
            ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;
            try {
                if (msgs != null && !msgs.isEmpty()) {
                    for (MessageExt msg : msgs) {
                        // 设置消息被消费的时间为当前时间
                        MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));
                    }
                }
                // 同步调用消费逻辑
                status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);
            } catch (Throwable e) {
                log.warn("consumeMessage exception: {} Group: {} Msgs: {} MQ: {}",
                    RemotingHelper.exceptionSimpleDesc(e),
                    ConsumeMessageConcurrentlyService.this.consumerGroup,
                    msgs,
                    messageQueue);
                hasException = true;
            }
            long consumeRT = System.currentTimeMillis() - beginTimestamp;
            if (null == status) {
                if (hasException) {
                    returnType = ConsumeReturnType.EXCEPTION;
                } else {
                    returnType = ConsumeReturnType.RETURNNULL;
                }
            } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {
                returnType = ConsumeReturnType.TIME_OUT; // 消费超时
            } else if (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) {
                returnType = ConsumeReturnType.FAILED; // 消费失败
            } else if (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) {
                returnType = ConsumeReturnType.SUCCESS; // 消费成功
            }

            // 将消费结果保存到consumeMessageContext，之后回调用hook的after方法
            if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
                consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());
            }

            if (null == status) {
                log.warn("consumeMessage return null, Group: {} Msgs: {} MQ: {}",
                    ConsumeMessageConcurrentlyService.this.consumerGroup,
                    msgs,
                    messageQueue);
                // 消费结果为null只能当作RECONSUME_LATER处理，即过一段时间再尝试消费
                status = ConsumeConcurrentlyStatus.RECONSUME_LATER;
            }

            // 消费完成后调用hook的after
            if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
                consumeMessageContext.setStatus(status.toString());
                consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);
                ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);
            }

            // 统计消费时间
            ConsumeMessageConcurrentlyService.this.getConsumerStatsManager()
                .incConsumeRT(ConsumeMessageConcurrentlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);

            if (!processQueue.isDropped()) {
                // 处理消费结果
                ConsumeMessageConcurrentlyService.this.processConsumeResult(status, context, this);
            } else {
                log.warn("processQueue is dropped without process consume result. messageQueue={}, msgs={}", messageQueue, msgs);
            }
        }

        public MessageQueue getMessageQueue() {
            return messageQueue;
        }

    }
}
```

对于`PullCallback`类的`onSuccess()`方法中调用的`submitConsumeRequest()`方法，代码如下：
```java
@Override
public void submitConsumeRequest(
    final List<MessageExt> msgs,
    final ProcessQueue processQueue,
    final MessageQueue messageQueue,
    final boolean dispatchToConsume) {
    // 获取一次能够批量消费消息的数量，默认为1
    final int consumeBatchSize = this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();
    if (msgs.size() <= consumeBatchSize) {
        // 消息数量在限定值以下直接创建ConsumeRequest对象并提交给consumeExecutor线程池进行消费
        ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue);
        try {
            // ConsumeRequest类实现了Runnable接口，这里执行submit相当于执行ConsumeRequest类的run方法
            this.consumeExecutor.submit(consumeRequest);
        } catch (RejectedExecutionException e) {
            // 线程池慢了导致拒绝执行时过一段时间再执行
            this.submitConsumeRequestLater(consumeRequest);
        }
    } else {
        // 如果消息数量超过了一次能够批量消费的值，则分批消费
        for (int total = 0; total < msgs.size(); ) {
            List<MessageExt> msgThis = new ArrayList<MessageExt>(consumeBatchSize);
            // 组成批量消息
            for (int i = 0; i < consumeBatchSize; i++, total++) {
                if (total < msgs.size()) {
                    msgThis.add(msgs.get(total));
                } else {
                    break;
                }
            }

            ConsumeRequest consumeRequest = new ConsumeRequest(msgThis, processQueue, messageQueue);
            try {
                this.consumeExecutor.submit(consumeRequest);
            } catch (RejectedExecutionException e) {
                for (; total < msgs.size(); total++) {
                    msgThis.add(msgs.get(total));
                }

                // 线程池慢了导致拒绝执行时过一段时间再执行
                this.submitConsumeRequestLater(consumeRequest);
            }
        }
    }
}
```

`submitConsumeRequest()`方法将传入的消息按照配置组成一批或多批消息封装成`ConsumeRequest`对象，之后将`consumeExecutor`对象提交到`consumeExecutor`这个线程池，`consumeExecutor`这个线程池的初始化在`ConsumeMessageConcurrentlyService`类的构造函数：
```java
// 初始化线程池
this.consumeExecutor = new ThreadPoolExecutor(
    this.defaultMQPushConsumer.getConsumeThreadMin(), // 默认20
    this.defaultMQPushConsumer.getConsumeThreadMax(), // 默认20
    1000 * 60,
    TimeUnit.MILLISECONDS,
    this.consumeRequestQueue, // 使用无界同步队列
    new ThreadFactoryImpl("ConsumeMessageThread_"));
```

这里再看看`ConsumeRequest`类的`run()`方法：
```java
@Override
public void run() {
    // 如果processQueue已经不由当前消费者消费，直接返回
    if (this.processQueue.isDropped()) {
        log.info("the message queue not be able to consume, because it's dropped. group={} {}", ConsumeMessageConcurrentlyService.this.consumerGroup, this.messageQueue);
        return;
    }

    // MessageListenerConcurrently就是用户实现的消息消费逻辑
    MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.this.messageListener;
    // 消费逻辑通过ConsumeConcurrentlyContext对象能够改变确认消费成功的消息位置，实现方式在processConsumeResult方法能看到
    ConsumeConcurrentlyContext context = new ConsumeConcurrentlyContext(messageQueue);
    // ConsumeConcurrentlyStatus为消费结果，有CONSUME_SUCCESS和RECONSUME_LATER
    ConsumeConcurrentlyStatus status = null;
    // 如果消息的topic为retry topic，则恢复消息的topic为原始的topic，如果topic存在namespace，则移除namespace
    defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup());

    ConsumeMessageContext consumeMessageContext = null;
    // 存在hook则调用hook的before方法
    if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
        consumeMessageContext = new ConsumeMessageContext();
        consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());
        consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());
        consumeMessageContext.setProps(new HashMap<String, String>());
        consumeMessageContext.setMq(messageQueue);
        consumeMessageContext.setMsgList(msgs);
        consumeMessageContext.setSuccess(false);
        ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);
    }

    long beginTimestamp = System.currentTimeMillis();
    boolean hasException = false;
    ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;
    try {
        if (msgs != null && !msgs.isEmpty()) {
            for (MessageExt msg : msgs) {
                // 设置消息被消费的时间为当前时间
                MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));
            }
        }
        // 同步调用消费逻辑
        status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);
    } catch (Throwable e) {
        log.warn("consumeMessage exception: {} Group: {} Msgs: {} MQ: {}",
            RemotingHelper.exceptionSimpleDesc(e),
            ConsumeMessageConcurrentlyService.this.consumerGroup,
            msgs,
            messageQueue);
        hasException = true;
    }
    long consumeRT = System.currentTimeMillis() - beginTimestamp;
    if (null == status) {
        if (hasException) {
            returnType = ConsumeReturnType.EXCEPTION;
        } else {
            returnType = ConsumeReturnType.RETURNNULL;
        }
    } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {
        returnType = ConsumeReturnType.TIME_OUT; // 消费超时
    } else if (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) {
        returnType = ConsumeReturnType.FAILED; // 消费失败
    } else if (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) {
        returnType = ConsumeReturnType.SUCCESS; // 消费成功
    }

    // 将消费结果保存到consumeMessageContext，之后回调用hook的after方法
    if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
        consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());
    }

    if (null == status) {
        log.warn("consumeMessage return null, Group: {} Msgs: {} MQ: {}",
            ConsumeMessageConcurrentlyService.this.consumerGroup,
            msgs,
            messageQueue);
        // 消费结果为null只能当作RECONSUME_LATER处理，即过一段时间再尝试消费
        status = ConsumeConcurrentlyStatus.RECONSUME_LATER;
    }

    // 消费完成后调用hook的after
    if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
        consumeMessageContext.setStatus(status.toString());
        consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);
        ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);
    }

    // 统计消费时间
    ConsumeMessageConcurrentlyService.this.getConsumerStatsManager()
        .incConsumeRT(ConsumeMessageConcurrentlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);

    if (!processQueue.isDropped()) {
        // 处理消费结果
        ConsumeMessageConcurrentlyService.this.processConsumeResult(status, context, this);
    } else {
        log.warn("processQueue is dropped without process consume result. messageQueue={}, msgs={}", messageQueue, msgs);
    }
}
```

上面`run()`方法的核心逻辑是为即将被消费的消息设置`PROPERTY_CONSUME_START_TIMESTAMP`属性，表示消息被消费的时间，时候调用用户编写的`MessageListenerConcurrently`类完成消费逻辑并获取消费结果，最后调用`ConsumeMessageConcurrentlyService`类的`processConsumeResult()`方法处理消费结果，该方法代码：
```java
public void processConsumeResult(
    final ConsumeConcurrentlyStatus status,
    final ConsumeConcurrentlyContext context,
    final ConsumeRequest consumeRequest
) {
    // 获取批量消息消费成功的位置，注意通常用户编写的消费逻辑不会修改这个值，而这个值的默认值为Integer.MAX_VALUE，即不发生异常的情
    // 况下默认认为所有消息消费成功，消费逻辑可以修改这个值以实现只确认消费批量消息的指定位置及该位置之前的消息
    int ackIndex = context.getAckIndex();

    if (consumeRequest.getMsgs().isEmpty())
        return;

    switch (status) {
        case CONSUME_SUCCESS: // 消费成功
            // ackIndex默认等于Integer.MAX_VALUE，所以这里需要修正该值
            if (ackIndex >= consumeRequest.getMsgs().size()) {
                ackIndex = consumeRequest.getMsgs().size() - 1;
            }
            // 消费成功的消息个数
            int ok = ackIndex + 1;
            // 成功的数量不等于批量消息的数量则认为消费失败
            int failed = consumeRequest.getMsgs().size() - ok;
            // 统计消费结果
            this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);
            this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);
            break;
        case RECONSUME_LATER:
            ackIndex = -1;
            this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),
                consumeRequest.getMsgs().size());
            break;
        default:
            break;
    }

    switch (this.defaultMQPushConsumer.getMessageModel()) {
        case BROADCASTING:
            // 广播模式消费失败的消息只是记录日志，不做补偿操作
            for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) {
                MessageExt msg = consumeRequest.getMsgs().get(i);
                log.warn("BROADCASTING, the message consume failed, drop it, {}", msg.toString());
            }
            break;
        case CLUSTERING:
            // 集群模式需要完成消息重试逻辑
            List<MessageExt> msgBackFailed = new ArrayList<MessageExt>(consumeRequest.getMsgs().size());
            // 遍历ackIndex + 1及之后的消息，即消费失败的消息
            for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) {
                MessageExt msg = consumeRequest.getMsgs().get(i);
                // 发送消息给broker，broker会将消息保存到retry topic
                boolean result = this.sendMessageBack(msg, context);
                if (!result) {
                    // 发送失败增加重试次数，即保存到msgBackFailed记录下来
                    msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
                    msgBackFailed.add(msg);
                }
            }

            if (!msgBackFailed.isEmpty()) {
                // 从批量消息集合中移除发送失败的消息，剩下的消息是消费成功和发送给broker成功的消息
                consumeRequest.getMsgs().removeAll(msgBackFailed);

                // 发送给broker失败的消息一段时间后直接在消费者端重新尝试消费
                this.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());
            }
            break;
        default:
            break;
    }

    // 从ProcessQueue中移除消费成功和消费失败后发送回broker成功的消息，如果移除消息完成后，ProcessQueue中还保留着消息，则
    // removeMessage方法的返回值为移除之后ProcessQueue保存的消息中位移的最小值，如果移除之前ProcessQueue保存的消息为空，则返回
    // 值为-1（通常不会出现这种情况，因为ProcessQueue中只是会包含下面传入的这些消息），如果移除之后ProcessQueue保存的消息为空，
    // 则返回ProcessQueue保存过的消息中位移的最大值，通过removeMessage的这种实现机制，再加上下面的updateOffset方法，就实现了消息
    // 消费后的自动提交
    long offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());
    if (offset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
        // 更新offsetStore中指定队列的消息位移，这里updateOffset方法的increaseOnly为true，表示offsetStore中指定队列的消息位移
        // 如果小于传入的offset的话才更新，否则不更新，这种机制就是消息位移自动提交的关键
        this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true);
    }
}
```

`processConsumeResult()`方法根据消费结果决定哪些消息需要重新消费，最后`processConsumeResult()`方法调用`ProcessQueue`对象的`removeMessage()`方法将被成功消费的消息从`ProcessQueue`对象移除，`removeMessage()`方法代码：
```java
public long removeMessage(final List<MessageExt> msgs) {
    long result = -1;
    final long now = System.currentTimeMillis();
    try {
        this.lockTreeMap.writeLock().lockInterruptibly();
        this.lastConsumeTimestamp = now;
        try {
            if (!msgTreeMap.isEmpty()) {
                // queueOffsetMax是ProcessQueue保存的消息中位移的最大值
                result = this.queueOffsetMax + 1;
                int removedCnt = 0;
                // 遍历消息，从msgTreeMap中移除消息
                for (MessageExt msg : msgs) {
                    MessageExt prev = msgTreeMap.remove(msg.getQueueOffset());
                    if (prev != null) {
                        removedCnt--;
                        // 减少ProcessQueue保存的消息总大小的值
                        msgSize.addAndGet(0 - msg.getBody().length);
                    }
                }
                // 减少ProcessQueue保存的消息总数量的值
                msgCount.addAndGet(removedCnt);

                // 如果msgTreeMap不为空，说明还有消息正在等待消费或正在被消费，此时返回这些消息的最小位移
                // 通过这种逻辑，使得removeMessage方法要么返回-1，要么返回正在等待消费或正在被消费的消息
                // 的最小位移，要么在msgTreeMap为空，即消息都被消费完成后，返回从ProcessQueue对应的队列
                // 拉取到的消息的最大位移值
                if (!msgTreeMap.isEmpty()) {
                    result = msgTreeMap.firstKey();
                }
            }
        } finally {
            this.lockTreeMap.writeLock().unlock();
        }
    } catch (Throwable t) {
        log.error("removeMessage exception", t);
    }

    return result;
}
```

`removeMessage()`方法的返回值为可以被认为消费完成的消息的最大位移，这个值在`processConsumeResult()`方法中会被交给`OffsetStore`的`updateOffset()`方法，该方法会将需要被提交的消息位移保存到内存中，对于集群模式下`OffsetStore`的实现类`RemoteBrokerOffsetStore`的`updateOffset()`方法代码如下：
```java
@Override
public void updateOffset(MessageQueue mq, long offset, boolean increaseOnly) {
    if (mq != null) {
        AtomicLong offsetOld = this.offsetTable.get(mq);
        if (null == offsetOld) {
            offsetOld = this.offsetTable.putIfAbsent(mq, new AtomicLong(offset));
        }

        if (null != offsetOld) {
            if (increaseOnly) {
                MixAll.compareAndIncreaseOnly(offsetOld, offset);
            } else {
                offsetOld.set(offset);
            }
        }
    }
}
```

`RemoteBrokerOffsetStore`类实现了`persistAll()`方法，该方法会将其内存中的位移值发送给broker，而`MQClientInstance`类的`startScheduledTask()`方法有如下定时任务：
```java
// 定时持久化消费进度
this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {

    @Override
    public void run() {
        try {
            MQClientInstance.this.persistAllConsumerOffset();
        } catch (Exception e) {
            log.error("ScheduledTask persistAllConsumerOffset exception", e);
        }
    }
}, 1000 * 10, this.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);

// 上面调用的persistAllConsumerOffset方法
private void persistAllConsumerOffset() {
    Iterator<Entry<String, MQConsumerInner>> it = this.consumerTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<String, MQConsumerInner> entry = it.next();
        MQConsumerInner impl = entry.getValue();
        impl.persistConsumerOffset();
    }
}
```

定时任务会定时调用`DefaultMQPushConsumerImpl`对象的`persistConsumerOffset()`方法，而`DefaultMQPushConsumerImpl`对象的`persistConsumerOffset()`方法又会调用`OffsetStore`的`persistAll()`方法，从而实现消息位移的自动提交：
```java
@Override
public void persistConsumerOffset() {
    try {
        this.makeSureStateOK();
        Set<MessageQueue> mqs = new HashSet<MessageQueue>();
        Set<MessageQueue> allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();
        mqs.addAll(allocateMq);

        this.offsetStore.persistAll(mqs);
    } catch (Exception e) {
        log.error("group: " + this.defaultMQPushConsumer.getConsumerGroup() + " persistConsumerOffset exception", e);
    }
}
```

`RemoteBrokerOffsetStore`类的`persistAll()`方法将消息位移发送给broker后，broker端的处理函数是`ConsumerManageProcessor`类的`updateConsumerOffset()`方法：
```java
private RemotingCommand updateConsumerOffset(ChannelHandlerContext ctx, RemotingCommand request)
    throws RemotingCommandException {
    final RemotingCommand response =
        RemotingCommand.createResponseCommand(UpdateConsumerOffsetResponseHeader.class);
    final UpdateConsumerOffsetRequestHeader requestHeader =
        (UpdateConsumerOffsetRequestHeader) request
            .decodeCommandCustomHeader(UpdateConsumerOffsetRequestHeader.class);
    this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(ctx.channel()), requestHeader.getConsumerGroup(),
        requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());
    response.setCode(ResponseCode.SUCCESS);
    response.setRemark(null);
    return response;
}
```

`updateConsumerOffset()`方法调用`ConsumerOffsetManager`类的`commitOffset()`方法完成位移提交：
```java
public void commitOffset(final String clientHost, final String group, final String topic, final int queueId,
    final long offset) {
    // topic@group
    String key = topic + TOPIC_GROUP_SEPARATOR + group;
    this.commitOffset(clientHost, key, queueId, offset);
}

private void commitOffset(final String clientHost, final String key, final int queueId, final long offset) {
    ConcurrentMap<Integer, Long> map = this.offsetTable.get(key);
    if (null == map) {
        map = new ConcurrentHashMap<Integer, Long>(32);
        map.put(queueId, offset);
        this.offsetTable.put(key, map);
    } else {
        // 只需要保存消费者提交的消费位移到内存即可，当前ConsumerOffsetManager类继承自ConfigManager类，而ConfigManager类实现了
        // persist方法，broker在启动时，BrokerController类的initialize方法会开启定时任务，定时执行ConsumerOffsetManager的
        // persist方法实现消费位移的持久化
        Long storeOffset = map.put(queueId, offset);
        if (storeOffset != null && offset < storeOffset) {
            log.warn("[NOTIFYME]update consumer offset less than store. clientHost={}, key={}, queueId={}, requestOffset={}, storeOffset={}", clientHost, key, queueId, offset, storeOffset);
        }
    }
}
```

可以发现`ConsumerOffsetManager`类的`commitOffset()`方法也只是将提交上来的位移保存到内存，`ConsumerOffsetManager`类继承自`ConfigManager`类，所以也继承了被持久化的能力，broker在启动时会执行`BrokerController`类的`initialize()`方法，该方法有如下定时任务：
```java
public boolean initialize() throws CloneNotSupportedException {
    // 尝试加载topics.json文件的内容作为配置，如果加载失败则尝试加载topics.json.bak文件
    boolean result = this.topicConfigManager.load();

    // 如果加载成功，则以同样的方式处理consumerOffset.json文件
    result = result && this.consumerOffsetManager.load();

    // 略...

    if (result) {
        // 略...

        // 每隔一段时间持久化一次consumerOffset
        this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                try {
                    BrokerController.this.consumerOffsetManager.persist();
                } catch (Throwable e) {
                    log.error("schedule persist consumerOffset error.", e);
                }
            }
        }, 1000 * 10, this.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);

        // 略...
    }
    // 略...
}
```

启动时调用`consumerOffsetManager.load()`加载已经持久化的被提交的消息位移，同时会开启定时任务定时调用`consumerOffsetManager.persist()`完成被提交的位移的持久化。

以上是消息消费过程。