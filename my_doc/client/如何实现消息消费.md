消息消费分为并发消费和顺序消费，消费前获取消息的方式又分为push和pull，一般情况下使用的是并发push的方式消费，demo：
```java
public class Consumer {
	public static void main(String[] args) throws InterruptedException, MQClientException {

    	// 实例化消费者
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name");

    	// 设置NameServer的地址
        consumer.setNamesrvAddr("localhost:9876");

    	// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息
        consumer.subscribe("TopicTest", "*");
    	// 注册回调实现类来处理从broker拉取回来的消息
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
                System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);
                // 标记该消息已经被成功消费
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        // 启动消费者实例
        consumer.start();
        System.out.printf("Consumer Started.%n");
	}
}
```

顺序消费指的是可以按照消息的发送顺序来消费(FIFO)，RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。关于顺序消费的解析，在笔记[如何实现顺序消费](如何实现顺序消费.md)，这里不再赘述。

pull方式获取消息进行消费的demo如下：
```java
public class PullConsumer {
    private static final Map<MessageQueue, Long> OFFSE_TABLE = new HashMap<MessageQueue, Long>();

    public static void main(String[] args) throws MQClientException {
        DefaultMQPullConsumer consumer = new DefaultMQPullConsumer("please_rename_unique_group_name_5");
        consumer.setNamesrvAddr("127.0.0.1:9876");
        consumer.start();

        Set<MessageQueue> mqs = consumer.fetchSubscribeMessageQueues("broker-a");
        for (MessageQueue mq : mqs) {
            System.out.printf("Consume from the queue: %s%n", mq);
            SINGLE_MQ:
            while (true) {
                try {
                    PullResult pullResult =
                        consumer.pullBlockIfNotFound(mq, null, getMessageQueueOffset(mq), 32);
                    System.out.printf("%s%n", pullResult);
                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());
                    switch (pullResult.getPullStatus()) {
                        case FOUND:
                            break;
                        case NO_MATCHED_MSG:
                            break;
                        case NO_NEW_MSG:
                            break SINGLE_MQ;
                        case OFFSET_ILLEGAL:
                            break;
                        default:
                            break;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        consumer.shutdown();
    }

    private static long getMessageQueueOffset(MessageQueue mq) {
        Long offset = OFFSE_TABLE.get(mq);
        if (offset != null)
            return offset;

        return 0;
    }

    private static void putMessageQueueOffset(MessageQueue mq, long offset) {
        OFFSE_TABLE.put(mq, offset);
    }

}
```


下面来push和pull方式消费消息的实现，首先是push模式，对应的实现类是`DefaultMQPushConsumer`，`DefaultMQPushConsumer`类和[如何实现消息发送](如何实现消息发送.md)中分析的`DefaultMQProducer`类似，虽然实现了`MQPushConsumer`接口，但是实际上`MQPushConsumer`接口的实现是通过`DefaultMQPushConsumer`的成员变量`DefaultMQPushConsumerImpl`完成的，`DefaultMQPushConsumer`类的主要功能是定义若干个消费者相关的配置属性，并继承`ClientConfig`类从而获得管理消费者和客户端配置的能力，`DefaultMQPushConsumerImpl`类也会通过其所在的`DefaultMQPushConsumer`类获取客户端配置，从而影响其运行逻辑。这里直接看`DefaultMQPushConsumer`类的构造函数：
```java
public DefaultMQPushConsumer(final String consumerGroup) {
    this(null, consumerGroup, null, new AllocateMessageQueueAveragely());
}

public DefaultMQPushConsumer(final String namespace, final String consumerGroup, RPCHook rpcHook,
    AllocateMessageQueueStrategy allocateMessageQueueStrategy) {
    this.consumerGroup = consumerGroup;
    this.namespace = namespace;
    // 负载均衡算法，默认为取模平均
    this.allocateMessageQueueStrategy = allocateMessageQueueStrategy;
    // DefaultMQPushConsumer的大部分方法实际上就是调用DefaultMQPushConsumerImpl的相应方法实现的
    defaultMQPushConsumerImpl = new DefaultMQPushConsumerImpl(this, rpcHook);
}
```

`DefaultMQPushConsumer`类的其他代码直接看该类的源码注释，这里不再赘述，下面来看使用push模式时使用`DefaultMQPushConsumer`对象需要执行的步骤，首先是`DefaultMQPushConsumer`对象的属性设置：
```java
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name_4");

consumer.setNamesrvAddr("127.0.0.1:9876");
consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
consumer.subscribe("TopicTest", "*");

consumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                    ConsumeConcurrentlyContext context) {
        if (CollectionUtils.isNotEmpty(msgs)) {
            final List<String> msgBodies = msgs.stream().map((item) -> new String(item.getBody())).collect(Collectors.toList());

            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgBodies);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }

        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
});
```

`setNamesrvAddr()`和`setConsumeFromWhere()`方法分别定义在`ClientConfig`和`DefaultMQPushConsumer`类，用于设置namesrv的地址和消费消息时的起始位置：
```java
public void setNamesrvAddr(String namesrvAddr) {
    this.namesrvAddr = namesrvAddr;
}

public void setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) {
    this.consumeFromWhere = consumeFromWhere;
}
```

`subscribe()`方法用于设置消费者的订阅配置，实现在`DefaultMQPushConsumer`类：
```java
public void subscribe(String topic, String subExpression) throws MQClientException {
    this.defaultMQPushConsumerImpl.subscribe(withNamespace(topic), subExpression);
}

public String withNamespace(String resource) {
    return NamespaceUtil.wrapNamespace(this.getNamespace(), resource);
}

// resourceWithOutNamespace通常是某个topic，如果namespace为空或者resourceWithOutNamespace为空则直接
// 返回resourceWithOutNamespace，否则如果resourceWithOutNamespace是rocketmq内置的topic则直接返回
// 如果以上条件都不满足，则判断resourceWithOutNamespace是否是%RETRY%或%DLQ%开头的，即是否是重试队列或者
// 死信队列的topic，如果是则返回%RETRY%或%DLQ% + namespace%resourceWithoutRetryAndDLQ形式的字符串，
// 否则返回namespace%resourceWithoutRetryAndDLQ
// 即主要目的是在namespace不为空的情况下在resourceWithOutNamespace前加上namespace并返回
public static String wrapNamespace(String namespace, String resourceWithOutNamespace) {
    if (StringUtils.isEmpty(namespace) || StringUtils.isEmpty(resourceWithOutNamespace)) {
        return resourceWithOutNamespace;
    }

    if (isSystemResource(resourceWithOutNamespace) || isAlreadyWithNamespace(resourceWithOutNamespace, namespace)) {
        return resourceWithOutNamespace;
    }

    String resourceWithoutRetryAndDLQ = withOutRetryAndDLQ(resourceWithOutNamespace);
    StringBuffer strBuffer = new StringBuffer();

    if (isRetryTopic(resourceWithOutNamespace)) {
        strBuffer.append(MixAll.RETRY_GROUP_TOPIC_PREFIX);
    }

    if (isDLQTopic(resourceWithOutNamespace)) {
        strBuffer.append(MixAll.DLQ_GROUP_TOPIC_PREFIX);
    }

    return strBuffer.append(namespace).append(NAMESPACE_SEPARATOR).append(resourceWithoutRetryAndDLQ).toString();

}
```

`subscribe()`方法中用到的`withNamespace()`方法主要是用于支持按照namespace隔离客户端，通常namespace为空。`subscribe()`方法的真正实现在`DefaultMQPushConsumerImpl`类：
```java
// 订阅主题，subExpression参数为订阅的消息标签，如'*'、'tagA'等
public void subscribe(String topic, String subExpression) throws MQClientException {
    try {
        // 根据消费者的参数创建SubscriptionData对象，该对象保存了消费者订阅的topic和该topic的标签配置，即
        // 一个SubscriptionData对象表示消费者的某个topic订阅
        SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
            topic, subExpression);
        // 保存订阅配置
        this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
        if (this.mQClientFactory != null) {
            // 向broker发送心跳，心跳中会包含消费者的组名和消费配置、订阅配置
            this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}
```

可以看到，`subscribe()`方法主要用于保存消费者的订阅配置到`RebalanceImpl`对象（该对象和消费者的负载均衡有关），并向broker发送心跳，使得所有的broker能够知道消费者的配置。

`registerMessageListener()`方法则是用于注册消息处理器：
```java
@Override
public void registerMessageListener(MessageListenerConcurrently messageListener) {
    this.messageListener = messageListener;
    this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);
}

// 注册消息的处理对象
public void registerMessageListener(MessageListener messageListener) {
    this.messageListenerInner = messageListener;
}
```

最后是`start()`方法：
```java
@Override
public void start() throws MQClientException {
    // 如果namespace不为空，则以namespace%consumerGroup的格式创建新的consumerGroup
    setConsumerGroup(NamespaceUtil.wrapNamespace(this.getNamespace(), this.consumerGroup));
    this.defaultMQPushConsumerImpl.start();
    if (null != traceDispatcher) {
        try {
            traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel());
        } catch (MQClientException e) {
            log.warn("trace dispatcher start failed ", e);
        }
    }
}
```