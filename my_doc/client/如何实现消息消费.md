消息消费分为并发消费和顺序消费，消费前获取消息的方式又分为push和pull，一般情况下使用的是并发push的方式消费，demo：
```java
public class Consumer {
	public static void main(String[] args) throws InterruptedException, MQClientException {

    	// 实例化消费者
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name");

    	// 设置NameServer的地址
        consumer.setNamesrvAddr("localhost:9876");

    	// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息
        consumer.subscribe("TopicTest", "*");
    	// 注册回调实现类来处理从broker拉取回来的消息
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
                System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);
                // 标记该消息已经被成功消费
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        // 启动消费者实例
        consumer.start();
        System.out.printf("Consumer Started.%n");
	}
}
```

顺序消费指的是可以按照消息的发送顺序来消费(FIFO)，RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。关于顺序消费的解析，在笔记[如何实现顺序消费](如何实现顺序消费.md)，这里不再赘述。

pull方式获取消息进行消费的demo如下：
```java
public class PullConsumer {
    private static final Map<MessageQueue, Long> OFFSE_TABLE = new HashMap<MessageQueue, Long>();

    public static void main(String[] args) throws MQClientException {
        DefaultMQPullConsumer consumer = new DefaultMQPullConsumer("please_rename_unique_group_name_5");
        consumer.setNamesrvAddr("127.0.0.1:9876");
        consumer.start();

        Set<MessageQueue> mqs = consumer.fetchSubscribeMessageQueues("broker-a");
        for (MessageQueue mq : mqs) {
            System.out.printf("Consume from the queue: %s%n", mq);
            SINGLE_MQ:
            while (true) {
                try {
                    PullResult pullResult =
                        consumer.pullBlockIfNotFound(mq, null, getMessageQueueOffset(mq), 32);
                    System.out.printf("%s%n", pullResult);
                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());
                    switch (pullResult.getPullStatus()) {
                        case FOUND:
                            break;
                        case NO_MATCHED_MSG:
                            break;
                        case NO_NEW_MSG:
                            break SINGLE_MQ;
                        case OFFSET_ILLEGAL:
                            break;
                        default:
                            break;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        consumer.shutdown();
    }

    private static long getMessageQueueOffset(MessageQueue mq) {
        Long offset = OFFSE_TABLE.get(mq);
        if (offset != null)
            return offset;

        return 0;
    }

    private static void putMessageQueueOffset(MessageQueue mq, long offset) {
        OFFSE_TABLE.put(mq, offset);
    }

}
```


下面来push和pull方式消费消息的实现，首先是push模式，对应的实现类是`DefaultMQPushConsumer`，`DefaultMQPushConsumer`类和[如何实现消息发送](如何实现消息发送.md)中分析的`DefaultMQProducer`类似，虽然实现了`MQPushConsumer`接口，但是实际上`MQPushConsumer`接口的实现是通过`DefaultMQPushConsumer`的成员变量`DefaultMQPushConsumerImpl`完成的，`DefaultMQPushConsumer`类的主要功能是定义若干个消费者相关的配置属性，并继承`ClientConfig`类从而获得管理消费者和客户端配置的能力，`DefaultMQPushConsumerImpl`类也会通过其所在的`DefaultMQPushConsumer`类获取客户端配置，从而影响其运行逻辑。这里直接看`DefaultMQPushConsumer`类的构造函数：
```java
public DefaultMQPushConsumer(final String consumerGroup) {
    this(null, consumerGroup, null, new AllocateMessageQueueAveragely());
}

public DefaultMQPushConsumer(final String namespace, final String consumerGroup, RPCHook rpcHook,
    AllocateMessageQueueStrategy allocateMessageQueueStrategy) {
    this.consumerGroup = consumerGroup;
    this.namespace = namespace;
    // 负载均衡算法，默认为取模平均
    this.allocateMessageQueueStrategy = allocateMessageQueueStrategy;
    // DefaultMQPushConsumer的大部分方法实际上就是调用DefaultMQPushConsumerImpl的相应方法实现的
    defaultMQPushConsumerImpl = new DefaultMQPushConsumerImpl(this, rpcHook);
}
```

`DefaultMQPushConsumer`类的其他代码直接看该类的源码注释，这里不再赘述，下面来看使用push模式时使用`DefaultMQPushConsumer`对象需要执行的步骤，首先是`DefaultMQPushConsumer`对象的属性设置：
```java
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name_4");

consumer.setNamesrvAddr("127.0.0.1:9876");
consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
consumer.subscribe("TopicTest", "*");

consumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                    ConsumeConcurrentlyContext context) {
        if (CollectionUtils.isNotEmpty(msgs)) {
            final List<String> msgBodies = msgs.stream().map((item) -> new String(item.getBody())).collect(Collectors.toList());

            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgBodies);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }

        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
});
```

`setNamesrvAddr()`和`setConsumeFromWhere()`方法分别定义在`ClientConfig`和`DefaultMQPushConsumer`类，用于设置namesrv的地址和消费消息时的起始位置：
```java
public void setNamesrvAddr(String namesrvAddr) {
    this.namesrvAddr = namesrvAddr;
}

public void setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) {
    this.consumeFromWhere = consumeFromWhere;
}
```

`subscribe()`方法用于设置消费者的订阅配置，实现在`DefaultMQPushConsumer`类：
```java
public void subscribe(String topic, String subExpression) throws MQClientException {
    this.defaultMQPushConsumerImpl.subscribe(withNamespace(topic), subExpression);
}

public String withNamespace(String resource) {
    return NamespaceUtil.wrapNamespace(this.getNamespace(), resource);
}

// resourceWithOutNamespace通常是某个topic，如果namespace为空或者resourceWithOutNamespace为空则直接
// 返回resourceWithOutNamespace，否则如果resourceWithOutNamespace是rocketmq内置的topic则直接返回
// 如果以上条件都不满足，则判断resourceWithOutNamespace是否是%RETRY%或%DLQ%开头的，即是否是重试队列或者
// 死信队列的topic，如果是则返回%RETRY%或%DLQ% + namespace%resourceWithoutRetryAndDLQ形式的字符串，
// 否则返回namespace%resourceWithoutRetryAndDLQ
// 即主要目的是在namespace不为空的情况下在resourceWithOutNamespace前加上namespace并返回
public static String wrapNamespace(String namespace, String resourceWithOutNamespace) {
    if (StringUtils.isEmpty(namespace) || StringUtils.isEmpty(resourceWithOutNamespace)) {
        return resourceWithOutNamespace;
    }

    if (isSystemResource(resourceWithOutNamespace) || isAlreadyWithNamespace(resourceWithOutNamespace, namespace)) {
        return resourceWithOutNamespace;
    }

    String resourceWithoutRetryAndDLQ = withOutRetryAndDLQ(resourceWithOutNamespace);
    StringBuffer strBuffer = new StringBuffer();

    if (isRetryTopic(resourceWithOutNamespace)) {
        strBuffer.append(MixAll.RETRY_GROUP_TOPIC_PREFIX);
    }

    if (isDLQTopic(resourceWithOutNamespace)) {
        strBuffer.append(MixAll.DLQ_GROUP_TOPIC_PREFIX);
    }

    return strBuffer.append(namespace).append(NAMESPACE_SEPARATOR).append(resourceWithoutRetryAndDLQ).toString();

}
```

`subscribe()`方法中用到的`withNamespace()`方法主要是用于支持按照namespace隔离客户端，通常namespace为空。`subscribe()`方法的真正实现在`DefaultMQPushConsumerImpl`类：
```java
// 订阅主题，subExpression参数为订阅的消息标签，如'*'、'tagA'等
public void subscribe(String topic, String subExpression) throws MQClientException {
    try {
        // 根据消费者的参数创建SubscriptionData对象，该对象保存了消费者订阅的topic和该topic的标签配置，即
        // 一个SubscriptionData对象表示消费者的某个topic订阅
        SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
            topic, subExpression);
        // 保存订阅配置
        this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
        if (this.mQClientFactory != null) {
            // 向broker发送心跳，心跳中会包含消费者的组名和消费配置、订阅配置
            this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}
```

可以看到，`subscribe()`方法主要用于保存消费者的订阅配置到`RebalanceImpl`对象（该对象和消费者的负载均衡有关），并向broker发送心跳，使得所有的broker能够知道消费者的配置。

`registerMessageListener()`方法则是用于注册消息处理器：
```java
@Override
public void registerMessageListener(MessageListenerConcurrently messageListener) {
    this.messageListener = messageListener;
    this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);
}

// 注册消息的处理对象
public void registerMessageListener(MessageListener messageListener) {
    this.messageListenerInner = messageListener;
}
```

最后是`start()`方法：
```java
@Override
public void start() throws MQClientException {
    // 如果namespace不为空，则以namespace%consumerGroup的格式创建新的consumerGroup
    setConsumerGroup(NamespaceUtil.wrapNamespace(this.getNamespace(), this.consumerGroup));
    this.defaultMQPushConsumerImpl.start();
    if (null != traceDispatcher) {
        try {
            traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel());
        } catch (MQClientException e) {
            log.warn("trace dispatcher start failed ", e);
        }
    }
}

// defaultMQPushConsumerImpl的start()方法
public synchronized void start() throws MQClientException {
    switch (this.serviceState) {
        case CREATE_JUST:
            log.info("the consumer [{}] start beginning. messageModel={}, isUnitMode={}", this.defaultMQPushConsumer.getConsumerGroup(),
                this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());
            // 设置状态为启动失败，如果启动过程正常执行，则会在最后更新成Running状态
            this.serviceState = ServiceState.START_FAILED;

            // 检查当前参数是否合法
            this.checkConfig();

            // defaultMQPushConsumer的subscription属性以Map的形式保存了消费者的订阅配置，copySubscription方法根据subscription
            // 属性的值创建SubscriptionData对象并保存到rebalanceImpl对象，同时添加consumeGroup的retry topic的订阅，即订阅
            // %RETRY%consumerGroupName这个topic
            this.copySubscription();

            if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {
                // 设置defaultMQPushConsumer的instanceName属性为pid
                this.defaultMQPushConsumer.changeInstanceNameToPID();
            }

            // mQClientFactory对象实现了真正需要发送网络请求的方法
            this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);

            // 配置负载均衡

            // 消费组
            this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());
            // 广播模式还是集群模式
            this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());
            // 负载均衡策略
            this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());
            this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);

            // 拉取消息的实现类
            this.pullAPIWrapper = new PullAPIWrapper(
                mQClientFactory,
                this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());
            this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);

            // offsetStore用于持久化已经消费的队列的consumeOffset
            if (this.defaultMQPushConsumer.getOffsetStore() != null) {
                this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();
            } else {
                // 没有设置offsetStore的实现则使用默认实现
                switch (this.defaultMQPushConsumer.getMessageModel()) {
                    case BROADCASTING:
                        // 广播模式offset保存在本地
                        this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
                        break;
                    case CLUSTERING:
                        // 集群模式offset保存在broker
                        this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
                        break;
                    default:
                        break;
                }
                this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);
            }
            // 获取之前持久化的offset
            this.offsetStore.load();

            // ConsumeMessageService负责持有和配置消费消息的线程池
            if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {
                this.consumeOrderly = true;
                this.consumeMessageService =
                    new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
            } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {
                this.consumeOrderly = false;
                this.consumeMessageService =
                    new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
            }

            // 启动定时任务定时调用consumeMessageService的cleanExpireMsg方法
            this.consumeMessageService.start();

            // 绑定consumerGroup和当前DefaultMQPushConsumerImpl对象的关系
            boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);
            if (!registerOK) {
                // 一个rocketmq进程内consumerGroup和DefaultMQPushConsumerImpl对象一一对应，如果存在多个DefaultMQPushConsumerImpl
                // 对象对应一个consumerGroup则报错
                this.serviceState = ServiceState.CREATE_JUST;
                this.consumeMessageService.shutdown();
                throw new MQClientException("The consumer group[" + this.defaultMQPushConsumer.getConsumerGroup()
                    + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                    null);
            }

            // 启动netty、拉取消息的线程、负载均衡线程、各种定时任务
            mQClientFactory.start();
            log.info("the consumer [{}] start OK.", this.defaultMQPushConsumer.getConsumerGroup());
            this.serviceState = ServiceState.RUNNING;
            break;
        case RUNNING:
        case START_FAILED:
        case SHUTDOWN_ALREADY:
            throw new MQClientException("The PushConsumer service state not OK, maybe started once, "
                + this.serviceState
                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),
                null);
        default:
            break;
    }

    // 从namesrv更新topic路由信息，并将路由信息保存到rebalanceImpl的topicSubscribeInfoTable属性
    this.updateTopicSubscribeInfoWhenSubscriptionChanged();
    // 遍历所有的SubscriptionData订阅配置，如果订阅时设置了tag，则根据topic获取TopicRouteData，并随机从TopicRouteData中选择一个
    // broker发送RequestCode.CHECK_CLIENT_CONFIG请求检查broker是否支持tag表达式
    this.mQClientFactory.checkClientInBroker();
    // 向所有broker发送心跳
    this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
    // 立即唤醒rebalanceService使其执行this.mqClientFactory.doRebalance()语句
    this.mQClientFactory.rebalanceImmediately();
}
```

`DefaultMQPushConsumerImpl`类的`start()`方法做了很多初始化操作，这里逐个分析，首先是`copySubscription()`方法：
```java
// defaultMQPushConsumer的subscription属性以Map的形式保存了消费者的订阅配置，copySubscription方法根据subscription
// 属性的值创建SubscriptionData对象并保存到rebalanceImpl对象，同时添加consumeGroup的retry topic的订阅，即订阅
// %RETRY%consumerGroupName这个topic
this.copySubscription();

private void copySubscription() throws MQClientException {
    try {
        // 如果defaultMQPushConsumer对象设置了subscription属性，即通过map设置了消费者的订阅配置，则
        // 将根据这些配置创建SubscriptionData对象并保存到rebalanceImpl，这一过程和DefaultMQPushConsumerImpl
        // 的subscribe方法一样
        Map<String, String> sub = this.defaultMQPushConsumer.getSubscription();
        if (sub != null) {
            for (final Map.Entry<String, String> entry : sub.entrySet()) {
                final String topic = entry.getKey();
                final String subString = entry.getValue();
                // 一个SubscriptionData对象表示消费者的一个订阅配置，即一个SubscriptionData对应一个topic和消费者设置的
                // topic的标签
                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                    topic, subString);
                this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
            }
        }

        // 设置消息处理器
        if (null == this.messageListenerInner) {
            this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();
        }

        switch (this.defaultMQPushConsumer.getMessageModel()) {
            case BROADCASTING:
                break;
            case CLUSTERING:
                // 获取retry的topic，格式为%RETRY%consumerGroup
                final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());
                // 订阅retry的消息
                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                    retryTopic, SubscriptionData.SUB_ALL);
                this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);
                break;
            default:
                break;
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}
```

`copySubscription()`方法首先解析`DefaultMQPushConsumer`类的`subscription`属性，将key和value作为topic和标签创建`SubscriptionData`对象，并将`SubscriptionData`对象保存到`RebalanceImpl`类，而`RebalanceImpl`类用于实现消费者之间的负载均衡，关于负载均衡可以看笔记[如何实现负载均衡](如何实现负载均衡.md)。

之后`copySubscription()`方法设置了`MessageListener`，并订阅了当前消费者组对应的retry topic，`MessageListener`就是demo中写的消息处理器，用于消费消息：
```java
consumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                    ConsumeConcurrentlyContext context) {
        if (CollectionUtils.isNotEmpty(msgs)) {
            final List<String> msgBodies = msgs.stream().map((item) -> new String(item.getBody())).collect(Collectors.toList());

            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgBodies);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }

        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
})
```

在`copySubscription()`方法之后，`start()`方法初始化了若干成员变量，调用了`OffsetStore`类的`load()`方法来加载消费位移，消费者开始消费消息时会从该位移开始消费。对于集群模式，`OffsetStore`类的实现是`RemoteBrokerOffsetStore`，其`load()`方法为空，因为集群模式的消费位移保存在Broker，并且只支持3种消费位移的设置方式，所以不需要加载消费位移：
- CONSUME_FROM_LAST_OFFSET 队列尾消费，即忽略历史消息
- CONSUME_FROM_FIRST_OFFSET 队列头消费，即从未过期的消息开始
- CONSUME_FROM_TIMESTAMP 按照日期选择某个位置消费，默认半个小时前的消息开始消费

在调用`load()`方法之后调用了`this.consumeMessageService.start();`语句，如果不是顺序消费消息，则`ConsumeMessageService`的实现类是`ConsumeMessageConcurrentlyService`，该类的实现在下面会分析。如果消费者顺序消费消息，则`ConsumeMessageService`的实现类是`ConsumeMessageOrderlyService`，该类的实现可以看笔记[如何实现顺序消费](如何实现顺序消费.md)。

最后是`mQClientFactory.start();`，该方法主要是启动定时任务，初始化网络连接等，也就是在该方法运行之后，消费者监听消息的过程就开始了：
```java
public void start() throws MQClientException {

    synchronized (this) {
        switch (this.serviceState) {
            case CREATE_JUST:
                // 更新状态
                this.serviceState = ServiceState.START_FAILED;
                // If not specified,looking address from name server
                // 从环境变量中获取namesrv的地址，如果获取不到则从默认url抓取namesrv地址
                if (null == this.clientConfig.getNamesrvAddr()) {
                    this.mQClientAPIImpl.fetchNameServerAddr();
                }
                // Start request-response channel
                // MQClientAPIImpl实现了真正发送各种网络请求的逻辑，必然用到了netty，这里的start方法实际上是调用
                // NettyRemotingClient的start方法创建netty的Bootstrap
                this.mQClientAPIImpl.start();
                // Start various schedule tasks
                // 开启定时任务，最主要的是更新路由信息，发送心跳等
                this.startScheduledTask();
                // Start pull service
                // pullMessageService是个无限循环的线程，负责从指定队列拉取消息
                this.pullMessageService.start();
                // Start rebalance service
                // rebalanceService是个无限循环的线程，以固定间隔调用当前类的doRebalance方法
                this.rebalanceService.start();
                // Start push service
                // 启动productGroup为MixAll.CLIENT_INNER_PRODUCER_GROUP的内置生产者，注意这里传入的startFactory参数为false，
                // 因为内置生产者不需要启动上面这几个线程和定时任务
                // defaultMQProducer主要用于在消息消费失败时发送消息给broker以实现消息重试
                this.defaultMQProducer.getDefaultMQProducerImpl().start(false);
                log.info("the client factory [{}] start OK", this.clientId);
                this.serviceState = ServiceState.RUNNING;
                break;
            case START_FAILED:
                throw new MQClientException("The Factory object[" + this.getClientId() + "] has been created before, and failed.", null);
            default:
                break;
        }
    }
}
```

`MQClientInstance`类的`start()`方法中关于初始化网络连接的过程由`this.mQClientAPIImpl.start();`实现，这个在笔记[remoting模块的作用和实现](../公共组件/remoting模块的作用和实现.md)中分析过了，对于消费者来说，比较关键的是`this.pullMessageService.start();`和`this.rebalanceService.start();`语句，分别用于实现拉取消息和实现负载均衡，下面先看`this.pullMessageService.start();`和消息拉取的实现过程。