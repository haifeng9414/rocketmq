rocketmq的消息过滤有以下几种方法：
- tag过滤：Consumer端在订阅消息时除了指定topic还可以指定tag，如果一个消息有多个tag，可以用||分隔。其中，Consumer端会将这个订阅请求构建成一个`SubscriptionData`对象，发送一个Pull消息的请求给Broker端。Broker端从rocketmq的文件存储层Store读取数据之前，会用这些数据先构建一个`MessageFilter`对象，然后传给Store。Store从`ConsumeQueue`读取到一条记录后，会用它记录的消息tag hash值去做过滤，由于在服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤，故在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。
- SQL92过滤：这种方式的大致做法和上面的Tag过滤方式一样，只是在Store层的具体过滤过程不太一样，真正的SQL expression的构建和执行由rocketmq-filter模块负责的。每次过滤都去执行SQL表达式会影响效率，所以rocketmq使用了BloomFilter避免了每次都去执行。SQL92的表达式上下文为消息的属性。
- FilterServer过滤：rocketmq允许消费者上传一个Java类给FilterServer进行过滤。
  - FilterServer只能运行在Broker所在的机器
  - 可以有若干个FilterServer进程
  - 拉取消息的时候，消息先经过FilterServer，FilterServer靠上传的Java类过滤消息后才推给Consumer消费
  - 客户端完全可以消费消息的时候做过滤，不需要FilterServer
  - FilterServer存在的目的是用Broker的CPU资源换取网卡资源，因为Broker的瓶颈往往在网卡，而且CPU资源很闲。在客户端过滤会导致无用的消息在占用网卡资源
  - 使用Java类作为过滤表达式是一个双刃剑，一方面方便了应用的过滤操作且节省网卡资源，另一方面也带来了服务器端的安全风险。这就需要应用来保证过滤代码安全，例如在过滤程序里尽可能不做申请大内存，创建线程等操作。避免Broker服务器资源泄漏
  
下面介绍以上几种消息过滤的实现。

## tag过滤
tag过滤发生在broker处理消费者的拉取消息请求的过程中，处理拉取消息请求时，broker从consumequeue文件读取到消息索引，之后根据消息索引中的tag hash判断是否返回消息，所以tag过滤实际上发生在broker端的消息查询过程，消息查询在笔记[如何实现消息查询](如何实现消息查询.md)中已经分析过了，这里只对tag过滤的相关实现做分析。

消费者在启动之前需要设置其订阅的topic和tag，代码如下：
```java
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name_4");
/*
* Subscribe one more more topics to consume.
*/
consumer.subscribe("TopicTest", "*");
```

`DefaultMQPushConsumer`类的`subscribe()`方法最终会将订阅信息保存到`SubscriptionData`对象，代码在`DefaultMQPushConsumerImpl`类的`subscribe()`方法：
```java
// 订阅主题，subExpression参数为订阅的消息标签，如'*'、'tagA'等
public void subscribe(String topic, String subExpression) throws MQClientException {
    try {
        // 根据消费者的参数创建SubscriptionData对象，该对象保存了消费者订阅的topic和该topic的标签配置，即
        // 一个SubscriptionData对象表示消费者的某个topic订阅
        SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
            topic, subExpression);
        // 保存订阅配置
        this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
        if (this.mQClientFactory != null) {
            // 向broker发送心跳，心跳中会包含消费者的组名和消费配置、订阅配置
            this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}

// 上面用到的FilterAPI类的buildSubscriptionData方法
public static SubscriptionData buildSubscriptionData(final String consumerGroup, String topic,
    String subString) throws Exception {
    SubscriptionData subscriptionData = new SubscriptionData();
    subscriptionData.setTopic(topic);
    subscriptionData.setSubString(subString);

    if (null == subString || subString.equals(SubscriptionData.SUB_ALL) || subString.length() == 0) {
        subscriptionData.setSubString(SubscriptionData.SUB_ALL);
    } else {
        // 标签以||分割，这里将所有的标签保存到subscriptionData的tagsSet属性
        String[] tags = subString.split("\\|\\|");
        if (tags.length > 0) {
            for (String tag : tags) {
                if (tag.length() > 0) {
                    String trimString = tag.trim();
                    if (trimString.length() > 0) {
                        // tagsSet保存了所有的标签
                        subscriptionData.getTagsSet().add(trimString);
                        // codeSet保存了所有的标签的hashCode
                        subscriptionData.getCodeSet().add(trimString.hashCode());
                    }
                }
            }
        } else {
            throw new Exception("subString split error");
        }
    }

    return subscriptionData;
}
```

消费者的会定期向所有broker发送心跳，心跳包中包含了消费者的订阅信息，对应的实现在`MQClientInstance`类的`sendHeartbeatToAllBroker()`方法：
```java
private void sendHeartbeatToAllBroker() {
    // 创建HeartbeatData对象，HeartbeatData包含了clientId、consumerTable和producerTable属性的值
    // 即对于消费者，HeartbeatData对象保存了当前MQClientInstance对象内（即一个进程内）的所有的消费者组
    // 名称和消费配置（包括订阅配置）
    // 对于生产者，HeartbeatData对象保存了当前MQClientInstance对象内（即一个进程内）的所有生产者组名称
    final HeartbeatData heartbeatData = this.prepareHeartbeatData();
    final boolean producerEmpty = heartbeatData.getProducerDataSet().isEmpty();
    final boolean consumerEmpty = heartbeatData.getConsumerDataSet().isEmpty();
    // 如果没有数据则没有必要发送心跳
    if (producerEmpty && consumerEmpty) {
        log.warn("sending heartbeat, but no consumer and no producer");
        return;
    }

    if (!this.brokerAddrTable.isEmpty()) {
        // 递增心跳次数
        long times = this.sendHeartbeatTimesTotal.getAndIncrement();
        Iterator<Entry<String, HashMap<Long, String>>> it = this.brokerAddrTable.entrySet().iterator();
        while (it.hasNext()) {
            Entry<String, HashMap<Long, String>> entry = it.next();
            String brokerName = entry.getKey();
            // 这里的key为brokerId，value为brokerAddr
            HashMap<Long, String> oneTable = entry.getValue();
            if (oneTable != null) {
                for (Map.Entry<Long, String> entry1 : oneTable.entrySet()) {
                    Long id = entry1.getKey();
                    String addr = entry1.getValue();
                    if (addr != null) {
                        /*
                        rocketmq中的生产者和消费者都需要发送心跳

                        生产者：
                        生产者与namesrv集群中的其中一个节点（随机选择）建立长连接，并定期从namesrv获取topic路由信息，向提供
                        topic服务的master broker建立长连接，且定时向master broker发送心跳

                        消费者：
                        消费者与namesrv集群中的其中一个节点（随机选择）建立长连接，并定期从namesrv获取topic路由信息，向提供
                        topic服务的master broker、slave broker建立长连接，且定时向master broker、slave broker发送心跳

                        当当前MQClientInstance对象的consumerTable为空时，则说明当前MQClientInstance对象是DefaultMQProducerImpl
                        对象创建的，服务于生产者，此时只需要发送心跳给master broker，所以这里跳过了非master的broker
                        */
                        if (consumerEmpty) {
                            if (id != MixAll.MASTER_ID)
                                continue;
                        }

                        try {
                            // 向指定地址的broker发送心跳
                            int version = this.mQClientAPIImpl.sendHearbeat(addr, heartbeatData, 3000);
                            if (!this.brokerVersionTable.containsKey(brokerName)) {
                                this.brokerVersionTable.put(brokerName, new HashMap<String, Integer>(4));
                            }
                            this.brokerVersionTable.get(brokerName).put(addr, version);
                            if (times % 20 == 0) {
                                log.info("send heart beat to broker[{} {} {}] success", brokerName, id, addr);
                                log.info(heartbeatData.toString());
                            }
                        } catch (Exception e) {
                            if (this.isBrokerInNameServer(addr)) {
                                log.info("send heart beat to broker[{} {} {}] failed", brokerName, id, addr, e);
                            } else {
                                log.info("send heart beat to broker[{} {} {}] exception, because the broker not up, forget it", brokerName,
                                    id, addr, e);
                            }
                        }
                    }
                }
            }
        }
    }
}
```

心跳包的数据就是`HeartbeatData`对象，该对象由`prepareHeartbeatData()`方法创建，代码：
```java
private HeartbeatData prepareHeartbeatData() {
    HeartbeatData heartbeatData = new HeartbeatData();

    // clientID
    heartbeatData.setClientID(this.clientId);

    // Consumer
    for (Map.Entry<String, MQConsumerInner> entry : this.consumerTable.entrySet()) {
        MQConsumerInner impl = entry.getValue();
        if (impl != null) {
            ConsumerData consumerData = new ConsumerData();
            consumerData.setGroupName(impl.groupName());
            consumerData.setConsumeType(impl.consumeType());
            consumerData.setMessageModel(impl.messageModel());
            consumerData.setConsumeFromWhere(impl.consumeFromWhere());
            // 获取消费者订阅配置
            consumerData.getSubscriptionDataSet().addAll(impl.subscriptions());
            consumerData.setUnitMode(impl.isUnitMode());

            heartbeatData.getConsumerDataSet().add(consumerData);
        }
    }

    // Producer
    for (Map.Entry<String/* group */, MQProducerInner> entry : this.producerTable.entrySet()) {
        MQProducerInner impl = entry.getValue();
        if (impl != null) {
            ProducerData producerData = new ProducerData();
            producerData.setGroupName(entry.getKey());

            heartbeatData.getProducerDataSet().add(producerData);
        }
    }

    return heartbeatData;
}
```

可以看到`HeartbeatData`对象的`consumerDataSet`属性包含了当前进程中所有消费者的配置，每个消费者对应一个`ConsumerData`对象，而`ConsumerData`对象又包含了`SubscriptionData`对象，即消费者的订阅配置。

当`HeartbeatData`对象发送给broker后，包broker端的处理方法是`ClientManageProcessor`类的`heartBeat()`方法：
```java
public RemotingCommand heartBeat(ChannelHandlerContext ctx, RemotingCommand request) {
    RemotingCommand response = RemotingCommand.createResponseCommand(null);
    HeartbeatData heartbeatData = HeartbeatData.decode(request.getBody(), HeartbeatData.class);
    // ClientChannelInfo表示一个消费者的连接，主要在于ctx.channel()，这个是netty的channel
    ClientChannelInfo clientChannelInfo = new ClientChannelInfo(
        ctx.channel(),
        heartbeatData.getClientID(),
        request.getLanguage(),
        request.getVersion()
    );

    // ConsumerData包含了一个消费者的配置，包括消费者组名、push还是pull、集群还是广播模式、订阅配置等
    for (ConsumerData data : heartbeatData.getConsumerDataSet()) {
        // SubscriptionGroupConfig表示broker中保存的某个消费者组的配置
        SubscriptionGroupConfig subscriptionGroupConfig =
            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(
                data.getGroupName());
        boolean isNotifyConsumerIdsChangedEnable = true;
        if (null != subscriptionGroupConfig) {
            // isNotifyConsumerIdsChangedEnable表示broker发现某个消费者组的消费者实例数量有变化时，是否通知所有这个消费者组的
            // 消费者实例，默认为true。当消费者收到这个通知后，会立即触发负载均衡
            isNotifyConsumerIdsChangedEnable = subscriptionGroupConfig.isNotifyConsumerIdsChangedEnable();
            int topicSysFlag = 0;
            if (data.isUnitMode()) {
                topicSysFlag = TopicSysFlag.buildSysFlag(false, true);
            }
            String newTopic = MixAll.getRetryTopic(data.getGroupName());
            // 如果retry topic还不存在则创建并发送当前broker的配置给所有的nameSrv，否则createTopicInSendMessageBackMethod
            // 方法会直接返回
            this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(
                newTopic,
                subscriptionGroupConfig.getRetryQueueNums(),
                PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);
        }

        boolean changed = this.brokerController.getConsumerManager().registerConsumer(
            data.getGroupName(),
            clientChannelInfo,
            data.getConsumeType(),
            data.getMessageModel(),
            data.getConsumeFromWhere(),
            data.getSubscriptionDataSet(),
            isNotifyConsumerIdsChangedEnable
        );

        if (changed) {
            log.info("registerConsumer info changed {} {}",
                data.toString(),
                RemotingHelper.parseChannelRemoteAddr(ctx.channel())
            );
        }
    }

    for (ProducerData data : heartbeatData.getProducerDataSet()) {
        this.brokerController.getProducerManager().registerProducer(data.getGroupName(),
            clientChannelInfo);
    }
    response.setCode(ResponseCode.SUCCESS);
    response.setRemark(null);
    return response;
}
```

`heartBeat()`方法中关于订阅配置的语句是：
```java
boolean changed = this.brokerController.getConsumerManager().registerConsumer(
    data.getGroupName(),
    clientChannelInfo,
    data.getConsumeType(),
    data.getMessageModel(),
    data.getConsumeFromWhere(),
    data.getSubscriptionDataSet(),
    isNotifyConsumerIdsChangedEnable
);
```

对应的方法是`ConsumerManager`类的`registerConsumer()`方法：
```java
public boolean registerConsumer(final String group, final ClientChannelInfo clientChannelInfo,
    ConsumeType consumeType, MessageModel messageModel, ConsumeFromWhere consumeFromWhere,
    final Set<SubscriptionData> subList, boolean isNotifyConsumerIdsChangedEnable) {

    // ConsumerGroupInfo对象保存了一个消费者组内消费者的配置，如果不存在当前消费者组的ConsumerGroupInfo则新建一个
    ConsumerGroupInfo consumerGroupInfo = this.consumerTable.get(group);
    if (null == consumerGroupInfo) {
        ConsumerGroupInfo tmp = new ConsumerGroupInfo(group, consumeType, messageModel, consumeFromWhere);
        ConsumerGroupInfo prev = this.consumerTable.putIfAbsent(group, tmp);
        consumerGroupInfo = prev != null ? prev : tmp;
    }

    // 将clientChannelInfo保存下来，这样相当于broker拥有了和消费者通信的能力，因为clientChannelInfo中包含了对应的
    // 消费者的channel，如果已经保存了clientChannelInfo对应的消费者的channel，则updateChannel返回false
    boolean r1 =
        consumerGroupInfo.updateChannel(clientChannelInfo, consumeType, messageModel,
            consumeFromWhere);
    // 更新订阅配置，如果配置没有发生变化则updateSubscription返回false
    boolean r2 = consumerGroupInfo.updateSubscription(subList);

    if (r1 || r2) {
        // r1为true表示有新的消费者注册到了当前broker，r2为true表示消费者的订阅配置变化了，这两种情况的任意一种都通知当前消费者组
        // 的所有消费者实例
        if (isNotifyConsumerIdsChangedEnable) {
            this.consumerIdsChangeListener.handle(ConsumerGroupEvent.CHANGE, group, consumerGroupInfo.getAllChannel());
        }
    }

    // 触发ConsumerGroupEvent.REGISTER事件，对于该事件，主要是更新当前broker的消费过滤配置
    this.consumerIdsChangeListener.handle(ConsumerGroupEvent.REGISTER, group, subList);

    return r1 || r2;
}
```

`registerConsumer`方法将消费者配置保存到`consumerTable`属性中，属性的key是消费者的组名，值为`ConsumerGroupInfo`对象，rocketmq中消费者组内的消费者被认为是相同的，所以只需要一个`ConsumerGroupInfo`对象即可。

保存`ConsumerGroupInfo`对象之后，调用`ConsumerGroupInfo`对象的`updateSubscription()`方法判断消费者订阅配置是否有变化，`updateSubscription()`方法代码：
```java
public boolean updateSubscription(final Set<SubscriptionData> subList) {
    boolean updated = false;

    // 遍历当前消费者的订阅配置，如果版本变化了则更新
    for (SubscriptionData sub : subList) {
        SubscriptionData old = this.subscriptionTable.get(sub.getTopic());
        if (old == null) {
            SubscriptionData prev = this.subscriptionTable.putIfAbsent(sub.getTopic(), sub);
            if (null == prev) {
                updated = true;
                log.info("subscription changed, add new topic, group: {} {}",
                    this.groupName,
                    sub.toString());
            }
        } else if (sub.getSubVersion() > old.getSubVersion()) {
            // 如果消费者是push模式
            if (this.consumeType == ConsumeType.CONSUME_PASSIVELY) {
                log.info("subscription changed, group: {} OLD: {} NEW: {}",
                    this.groupName,
                    old.toString(),
                    sub.toString()
                );
            }

            this.subscriptionTable.put(sub.getTopic(), sub);
        }
    }

    // 遍历已存在的订阅配置，如果这次的心跳请求中不包含已经保存在subscriptionTable属性中的某个topic的配置，则将该topic从
    // subscriptionTable属性删除，即消费者不再消费该topic了
    Iterator<Entry<String, SubscriptionData>> it = this.subscriptionTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<String, SubscriptionData> next = it.next();
        String oldTopic = next.getKey();

        boolean exist = false;
        for (SubscriptionData sub : subList) {
            if (sub.getTopic().equals(oldTopic)) {
                exist = true;
                break;
            }
        }

        if (!exist) {
            log.warn("subscription changed, group: {} remove topic {} {}",
                this.groupName,
                oldTopic,
                next.getValue().toString()
            );

            it.remove();
            updated = true;
        }
    }

    this.lastUpdateTimestamp = System.currentTimeMillis();

    // 如果订阅配置是第一次被保存，或者订阅的topic列表有变化，则返回true
    return updated;
}
```

当消费者配置有变化时，`registerConsumer()`方法会调用`DefaultConsumerIdsChangeListener`对的`handle()`方法发起一个`ConsumerGroupEvent.CHANGE`事件，`handle()`方法对于该事件的处理如下：
```java
case CHANGE: // 有新消费者注册或者订阅配置发送了变化
if (args == null || args.length < 1) {
    return;
}
// 这里获取的参数为consumerGroupInfo.getAllChannel()，即当前消费者所在的消费者组中所有已经注册到当前broker的消
// 费者的Channel
List<Channel> channels = (List<Channel>) args[0];
if (channels != null && brokerController.getBrokerConfig().isNotifyConsumerIdsChangedEnable()) {
    // 遍历消费者的Channel，发送消费者成员变更请求
    for (Channel chl : channels) {
        this.brokerController.getBroker2Client().notifyConsumerIdsChanged(chl, group);
    }
}
break;
```

当发生`ConsumerGroupEvent.CHANGE`事件时，broker会通知所有当前消费者组内的消费者实例，向组内的消费者发送`RequestCode.NOTIFY_CONSUMER_IDS_CHANGED`请求，消费者收到该请求后会发起消费者组内的负载均衡，使得当前消费者组能够根据最新的订阅配置消费消息，这些在笔记[如何实现负载均衡](如何实现负载均衡.md)中已经分析过了。

在发起`ConsumerGroupEvent.CHANGE`事件时后，`registerConsumer()`方法还会发起`ConsumerGroupEvent.REGISTER`事件，对应的处理是：
```java
case REGISTER: // 消费者注册，无论是否是第一次注册，可以认为每次心跳都会触发该事件
if (args == null || args.length < 1) {
    return;
}
// 这里获取的参数为Set<SubscriptionData>，即当前消费者的所有订阅配置
Collection<SubscriptionData> subscriptionDataList = (Collection<SubscriptionData>) args[0];
this.brokerController.getConsumerFilterManager().register(group, subscriptionDataList);
break;
```

上面的逻辑是将订阅配置注册到`ConsumerFilterManager`类，对应的方法是`ConsumerFilterManager`类的`register()`方法：
```java
public void register(final String consumerGroup, final Collection<SubscriptionData> subList) {
    // 遍历消费者发送的心跳中带来的订阅配置
    for (SubscriptionData subscriptionData : subList) {
        // 如果当前订阅配置没有过滤配置，或者过滤的方式为TAG，则直接返回，否则说明过滤的方式为SQL92，此时会为过滤表达式创建布隆过滤器
        // 并和过滤表达式一起保存到新建的ConsumerFilterData对象（如果没有的话），再将ConsumerFilterData对象保存到filterDataByTopic属性
        register(
            subscriptionData.getTopic(),
            consumerGroup,
            subscriptionData.getSubString(),
            subscriptionData.getExpressionType(),
            subscriptionData.getSubVersion()
        );
    }

    // make illegal topic dead.
    // ConsumerFilterData对象表示一个消费者组对一个topic的过滤配置，包含了布隆过滤器、过滤类型、过滤表达式等，目前只支持SQL92类型
    Collection<ConsumerFilterData> groupFilterData = getByGroup(consumerGroup);

    // groupFilterData包含了当前消费者组的所有topic下的配置，一个topic对应一个ConsumerFilterData对象
    Iterator<ConsumerFilterData> iterator = groupFilterData.iterator();
    while (iterator.hasNext()) {
        // 遍历ConsumerFilterData对象，判断ConsumerFilterData对象对应的topic是否包含在传入的subList中
        ConsumerFilterData filterData = iterator.next();

        boolean exist = false;
        for (SubscriptionData subscriptionData : subList) {
            if (subscriptionData.getTopic().equals(filterData.getTopic())) {
                exist = true;
                break;
            }
        }

        // 设置不再被订阅的topic对应的ConsumerFilterData对象的deadTime属性为当前时间，即禁用该ConsumerFilterData对象
        // 设置当前消费者组不再订阅的topic的SubscriptionData对象的deadTime属性，这里不直接删除该配置是因为组内的其他的消费者
        // 成员可能还要用，清除操作会在当前ConsumerFilterManager对象被定时任务持久化时做
        if (!exist && !filterData.isDead()) {
            filterData.setDeadTime(System.currentTimeMillis());
            log.info("Consumer filter changed: {}, make illegal topic dead:{}", consumerGroup, filterData);
        }
    }
}
```

上面实际上都是针对SQL92过滤类型的处理，对于tag类型的过滤方式，没有特殊处理，关于SQL92过滤类型的处理逻辑，在分析SQL92过滤方式的实现时再说。以上是订阅配置被发送到broker后的处理逻辑，下面再看看消息的tag是如何影响消息消费的。

从笔记[如何实现消息查询](如何实现消息查询.md)可知，对于消息的tag过滤，发生在