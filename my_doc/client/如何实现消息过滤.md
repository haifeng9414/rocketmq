rocketmq的消息过滤有以下几种方法：
- tag过滤：Consumer端在订阅消息时除了指定topic还可以指定tag，如果一个消息有多个tag，可以用||分隔。其中，Consumer端会将这个订阅请求构建成一个`SubscriptionData`对象，发送一个Pull消息的请求给Broker端。Broker端从rocketmq的文件存储层Store读取数据之前，会用这些数据先构建一个`MessageFilter`对象，然后传给Store。Store从`ConsumeQueue`读取到一条记录后，会用它记录的消息tag hash值去做过滤，由于在服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤，故在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。
- SQL92过滤：这种方式的大致做法和上面的Tag过滤方式一样，只是在Store层的具体过滤过程不太一样，真正的SQL expression的构建和执行由rocketmq-filter模块负责的。每次过滤都去执行SQL表达式会影响效率，所以rocketmq使用了BloomFilter避免了每次都去执行。SQL92的表达式上下文为消息的属性。
- FilterServer过滤：rocketmq允许消费者上传一个Java类给FilterServer进行过滤。
  - FilterServer只能运行在Broker所在的机器
  - 可以有若干个FilterServer进程
  - 拉取消息的时候，消息先经过FilterServer，FilterServer靠上传的Java类过滤消息后才推给Consumer消费
  - 客户端完全可以消费消息的时候做过滤，不需要FilterServer
  - FilterServer存在的目的是用Broker的CPU资源换取网卡资源，因为Broker的瓶颈往往在网卡，而且CPU资源很闲。在客户端过滤会导致无用的消息在占用网卡资源
  - 使用Java类作为过滤表达式是一个双刃剑，一方面方便了应用的过滤操作且节省网卡资源，另一方面也带来了服务器端的安全风险。这就需要应用来保证过滤代码安全，例如在过滤程序里尽可能不做申请大内存，创建线程等操作。避免Broker服务器资源泄漏
  
下面介绍以上几种消息过滤的实现。

## tag过滤
tag过滤发生在broker处理消费者的拉取消息请求的过程中，处理拉取消息请求时，broker从consumequeue文件读取到消息索引，之后根据消息索引中的tag hash判断是否返回消息，所以tag过滤实际上发生在broker端处理消息消费请求的过程，这一过程在笔记[如何实现消息消费](如何实现消息消费.md)中已经分析过了，这里只对tag过滤的相关实现做分析。

消费者在启动之前需要设置其订阅的topic和tag，代码如下：
```java
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name_4");
/*
* Subscribe one more more topics to consume.
*/
consumer.subscribe("TopicTest", "*");
```

`DefaultMQPushConsumer`类的`subscribe()`方法最终会将订阅信息保存到`SubscriptionData`对象，代码在`DefaultMQPushConsumerImpl`类的`subscribe()`方法：
```java
// 订阅主题，subExpression参数为订阅的消息标签，如'*'、'tagA'等
public void subscribe(String topic, String subExpression) throws MQClientException {
    try {
        // 根据消费者的参数创建SubscriptionData对象，该对象保存了消费者订阅的topic和该topic的标签配置，即
        // 一个SubscriptionData对象表示消费者的某个topic订阅
        SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
            topic, subExpression);
        // 保存订阅配置
        this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
        if (this.mQClientFactory != null) {
            // 向broker发送心跳，心跳中会包含消费者的组名和消费配置、订阅配置
            this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}

// 上面用到的FilterAPI类的buildSubscriptionData方法
public static SubscriptionData buildSubscriptionData(final String consumerGroup, String topic,
    String subString) throws Exception {
    SubscriptionData subscriptionData = new SubscriptionData();
    subscriptionData.setTopic(topic);
    subscriptionData.setSubString(subString);

    if (null == subString || subString.equals(SubscriptionData.SUB_ALL) || subString.length() == 0) {
        subscriptionData.setSubString(SubscriptionData.SUB_ALL);
    } else {
        // 标签以||分割，这里将所有的标签保存到subscriptionData的tagsSet属性
        String[] tags = subString.split("\\|\\|");
        if (tags.length > 0) {
            for (String tag : tags) {
                if (tag.length() > 0) {
                    String trimString = tag.trim();
                    if (trimString.length() > 0) {
                        // tagsSet保存了所有的标签
                        subscriptionData.getTagsSet().add(trimString);
                        // codeSet保存了所有的标签的hashCode
                        subscriptionData.getCodeSet().add(trimString.hashCode());
                    }
                }
            }
        } else {
            throw new Exception("subString split error");
        }
    }

    return subscriptionData;
}
```

消费者的会定期向所有broker发送心跳，心跳包中包含了消费者的订阅信息，对应的实现在`MQClientInstance`类的`sendHeartbeatToAllBroker()`方法：
```java
private void sendHeartbeatToAllBroker() {
    // 创建HeartbeatData对象，HeartbeatData包含了clientId、consumerTable和producerTable属性的值
    // 即对于消费者，HeartbeatData对象保存了当前MQClientInstance对象内（即一个进程内）的所有的消费者组
    // 名称和消费配置（包括订阅配置）
    // 对于生产者，HeartbeatData对象保存了当前MQClientInstance对象内（即一个进程内）的所有生产者组名称
    final HeartbeatData heartbeatData = this.prepareHeartbeatData();
    final boolean producerEmpty = heartbeatData.getProducerDataSet().isEmpty();
    final boolean consumerEmpty = heartbeatData.getConsumerDataSet().isEmpty();
    // 如果没有数据则没有必要发送心跳
    if (producerEmpty && consumerEmpty) {
        log.warn("sending heartbeat, but no consumer and no producer");
        return;
    }

    if (!this.brokerAddrTable.isEmpty()) {
        // 递增心跳次数
        long times = this.sendHeartbeatTimesTotal.getAndIncrement();
        Iterator<Entry<String, HashMap<Long, String>>> it = this.brokerAddrTable.entrySet().iterator();
        while (it.hasNext()) {
            Entry<String, HashMap<Long, String>> entry = it.next();
            String brokerName = entry.getKey();
            // 这里的key为brokerId，value为brokerAddr
            HashMap<Long, String> oneTable = entry.getValue();
            if (oneTable != null) {
                for (Map.Entry<Long, String> entry1 : oneTable.entrySet()) {
                    Long id = entry1.getKey();
                    String addr = entry1.getValue();
                    if (addr != null) {
                        /*
                        rocketmq中的生产者和消费者都需要发送心跳

                        生产者：
                        生产者与namesrv集群中的其中一个节点（随机选择）建立长连接，并定期从namesrv获取topic路由信息，向提供
                        topic服务的master broker建立长连接，且定时向master broker发送心跳

                        消费者：
                        消费者与namesrv集群中的其中一个节点（随机选择）建立长连接，并定期从namesrv获取topic路由信息，向提供
                        topic服务的master broker、slave broker建立长连接，且定时向master broker、slave broker发送心跳

                        当当前MQClientInstance对象的consumerTable为空时，则说明当前MQClientInstance对象是DefaultMQProducerImpl
                        对象创建的，服务于生产者，此时只需要发送心跳给master broker，所以这里跳过了非master的broker
                        */
                        if (consumerEmpty) {
                            if (id != MixAll.MASTER_ID)
                                continue;
                        }

                        try {
                            // 向指定地址的broker发送心跳
                            int version = this.mQClientAPIImpl.sendHearbeat(addr, heartbeatData, 3000);
                            if (!this.brokerVersionTable.containsKey(brokerName)) {
                                this.brokerVersionTable.put(brokerName, new HashMap<String, Integer>(4));
                            }
                            this.brokerVersionTable.get(brokerName).put(addr, version);
                            if (times % 20 == 0) {
                                log.info("send heart beat to broker[{} {} {}] success", brokerName, id, addr);
                                log.info(heartbeatData.toString());
                            }
                        } catch (Exception e) {
                            if (this.isBrokerInNameServer(addr)) {
                                log.info("send heart beat to broker[{} {} {}] failed", brokerName, id, addr, e);
                            } else {
                                log.info("send heart beat to broker[{} {} {}] exception, because the broker not up, forget it", brokerName,
                                    id, addr, e);
                            }
                        }
                    }
                }
            }
        }
    }
}
```

心跳包的数据就是`HeartbeatData`对象，该对象由`prepareHeartbeatData()`方法创建，代码：
```java
private HeartbeatData prepareHeartbeatData() {
    HeartbeatData heartbeatData = new HeartbeatData();

    // clientID
    heartbeatData.setClientID(this.clientId);

    // Consumer
    for (Map.Entry<String, MQConsumerInner> entry : this.consumerTable.entrySet()) {
        MQConsumerInner impl = entry.getValue();
        if (impl != null) {
            ConsumerData consumerData = new ConsumerData();
            consumerData.setGroupName(impl.groupName());
            consumerData.setConsumeType(impl.consumeType());
            consumerData.setMessageModel(impl.messageModel());
            consumerData.setConsumeFromWhere(impl.consumeFromWhere());
            // 获取消费者订阅配置
            consumerData.getSubscriptionDataSet().addAll(impl.subscriptions());
            consumerData.setUnitMode(impl.isUnitMode());

            heartbeatData.getConsumerDataSet().add(consumerData);
        }
    }

    // Producer
    for (Map.Entry<String/* group */, MQProducerInner> entry : this.producerTable.entrySet()) {
        MQProducerInner impl = entry.getValue();
        if (impl != null) {
            ProducerData producerData = new ProducerData();
            producerData.setGroupName(entry.getKey());

            heartbeatData.getProducerDataSet().add(producerData);
        }
    }

    return heartbeatData;
}
```

可以看到`HeartbeatData`对象的`consumerDataSet`属性包含了当前进程中所有消费者的配置，每个消费者对应一个`ConsumerData`对象，而`ConsumerData`对象又包含了`SubscriptionData`对象，即消费者的订阅配置。

当`HeartbeatData`对象发送给broker后，包broker端的处理方法是`ClientManageProcessor`类的`heartBeat()`方法：
```java
public RemotingCommand heartBeat(ChannelHandlerContext ctx, RemotingCommand request) {
    RemotingCommand response = RemotingCommand.createResponseCommand(null);
    HeartbeatData heartbeatData = HeartbeatData.decode(request.getBody(), HeartbeatData.class);
    // ClientChannelInfo表示一个消费者的连接，主要在于ctx.channel()，这个是netty的channel
    ClientChannelInfo clientChannelInfo = new ClientChannelInfo(
        ctx.channel(),
        heartbeatData.getClientID(),
        request.getLanguage(),
        request.getVersion()
    );

    // ConsumerData包含了一个消费者的配置，包括消费者组名、push还是pull、集群还是广播模式、订阅配置等
    for (ConsumerData data : heartbeatData.getConsumerDataSet()) {
        // SubscriptionGroupConfig表示broker中保存的某个消费者组的配置
        SubscriptionGroupConfig subscriptionGroupConfig =
            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(
                data.getGroupName());
        boolean isNotifyConsumerIdsChangedEnable = true;
        if (null != subscriptionGroupConfig) {
            // isNotifyConsumerIdsChangedEnable表示broker发现某个消费者组的消费者实例数量有变化时，是否通知所有这个消费者组的
            // 消费者实例，默认为true。当消费者收到这个通知后，会立即触发负载均衡
            isNotifyConsumerIdsChangedEnable = subscriptionGroupConfig.isNotifyConsumerIdsChangedEnable();
            int topicSysFlag = 0;
            if (data.isUnitMode()) {
                topicSysFlag = TopicSysFlag.buildSysFlag(false, true);
            }
            String newTopic = MixAll.getRetryTopic(data.getGroupName());
            // 如果retry topic还不存在则创建并发送当前broker的配置给所有的nameSrv，否则createTopicInSendMessageBackMethod
            // 方法会直接返回
            this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(
                newTopic,
                subscriptionGroupConfig.getRetryQueueNums(),
                PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);
        }

        boolean changed = this.brokerController.getConsumerManager().registerConsumer(
            data.getGroupName(),
            clientChannelInfo,
            data.getConsumeType(),
            data.getMessageModel(),
            data.getConsumeFromWhere(),
            data.getSubscriptionDataSet(),
            isNotifyConsumerIdsChangedEnable
        );

        if (changed) {
            log.info("registerConsumer info changed {} {}",
                data.toString(),
                RemotingHelper.parseChannelRemoteAddr(ctx.channel())
            );
        }
    }

    for (ProducerData data : heartbeatData.getProducerDataSet()) {
        this.brokerController.getProducerManager().registerProducer(data.getGroupName(),
            clientChannelInfo);
    }
    response.setCode(ResponseCode.SUCCESS);
    response.setRemark(null);
    return response;
}
```

`heartBeat()`方法中关于订阅配置的语句是：
```java
boolean changed = this.brokerController.getConsumerManager().registerConsumer(
    data.getGroupName(),
    clientChannelInfo,
    data.getConsumeType(),
    data.getMessageModel(),
    data.getConsumeFromWhere(),
    data.getSubscriptionDataSet(),
    isNotifyConsumerIdsChangedEnable
);
```

对应的方法是`ConsumerManager`类的`registerConsumer()`方法：
```java
public boolean registerConsumer(final String group, final ClientChannelInfo clientChannelInfo,
    ConsumeType consumeType, MessageModel messageModel, ConsumeFromWhere consumeFromWhere,
    final Set<SubscriptionData> subList, boolean isNotifyConsumerIdsChangedEnable) {

    // ConsumerGroupInfo对象保存了一个消费者组内消费者的配置，如果不存在当前消费者组的ConsumerGroupInfo则新建一个
    ConsumerGroupInfo consumerGroupInfo = this.consumerTable.get(group);
    if (null == consumerGroupInfo) {
        ConsumerGroupInfo tmp = new ConsumerGroupInfo(group, consumeType, messageModel, consumeFromWhere);
        ConsumerGroupInfo prev = this.consumerTable.putIfAbsent(group, tmp);
        consumerGroupInfo = prev != null ? prev : tmp;
    }

    // 将clientChannelInfo保存下来，这样相当于broker拥有了和消费者通信的能力，因为clientChannelInfo中包含了对应的
    // 消费者的channel，如果已经保存了clientChannelInfo对应的消费者的channel，则updateChannel返回false
    boolean r1 =
        consumerGroupInfo.updateChannel(clientChannelInfo, consumeType, messageModel,
            consumeFromWhere);
    // 更新订阅配置，如果配置没有发生变化则updateSubscription返回false
    boolean r2 = consumerGroupInfo.updateSubscription(subList);

    if (r1 || r2) {
        // r1为true表示有新的消费者注册到了当前broker，r2为true表示消费者的订阅配置变化了，这两种情况的任意一种都通知当前消费者组
        // 的所有消费者实例
        if (isNotifyConsumerIdsChangedEnable) {
            this.consumerIdsChangeListener.handle(ConsumerGroupEvent.CHANGE, group, consumerGroupInfo.getAllChannel());
        }
    }

    // 触发ConsumerGroupEvent.REGISTER事件，对于该事件，主要是更新当前broker的消费过滤配置
    this.consumerIdsChangeListener.handle(ConsumerGroupEvent.REGISTER, group, subList);

    return r1 || r2;
}
```

`registerConsumer`方法将消费者配置保存到`consumerTable`属性中，属性的key是消费者的组名，值为`ConsumerGroupInfo`对象，rocketmq中消费者组内的消费者被认为是相同的，所以只需要一个`ConsumerGroupInfo`对象即可。

保存`ConsumerGroupInfo`对象之后，调用`ConsumerGroupInfo`对象的`updateSubscription()`方法判断消费者订阅配置是否有变化，`updateSubscription()`方法代码：
```java
public boolean updateSubscription(final Set<SubscriptionData> subList) {
    boolean updated = false;

    // 遍历当前消费者的订阅配置，如果版本变化了则更新
    for (SubscriptionData sub : subList) {
        SubscriptionData old = this.subscriptionTable.get(sub.getTopic());
        if (old == null) {
            SubscriptionData prev = this.subscriptionTable.putIfAbsent(sub.getTopic(), sub);
            if (null == prev) {
                updated = true;
                log.info("subscription changed, add new topic, group: {} {}",
                    this.groupName,
                    sub.toString());
            }
        } else if (sub.getSubVersion() > old.getSubVersion()) {
            // 如果消费者是push模式
            if (this.consumeType == ConsumeType.CONSUME_PASSIVELY) {
                log.info("subscription changed, group: {} OLD: {} NEW: {}",
                    this.groupName,
                    old.toString(),
                    sub.toString()
                );
            }

            this.subscriptionTable.put(sub.getTopic(), sub);
        }
    }

    // 遍历已存在的订阅配置，如果这次的心跳请求中不包含已经保存在subscriptionTable属性中的某个topic的配置，则将该topic从
    // subscriptionTable属性删除，即消费者不再消费该topic了
    Iterator<Entry<String, SubscriptionData>> it = this.subscriptionTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<String, SubscriptionData> next = it.next();
        String oldTopic = next.getKey();

        boolean exist = false;
        for (SubscriptionData sub : subList) {
            if (sub.getTopic().equals(oldTopic)) {
                exist = true;
                break;
            }
        }

        if (!exist) {
            log.warn("subscription changed, group: {} remove topic {} {}",
                this.groupName,
                oldTopic,
                next.getValue().toString()
            );

            it.remove();
            updated = true;
        }
    }

    this.lastUpdateTimestamp = System.currentTimeMillis();

    // 如果订阅配置是第一次被保存，或者订阅的topic列表有变化，则返回true
    return updated;
}
```

当消费者配置有变化时，`registerConsumer()`方法会调用`DefaultConsumerIdsChangeListener`对的`handle()`方法发起一个`ConsumerGroupEvent.CHANGE`事件，`handle()`方法对于该事件的处理如下：
```java
case CHANGE: // 有新消费者注册或者订阅配置发送了变化
if (args == null || args.length < 1) {
    return;
}
// 这里获取的参数为consumerGroupInfo.getAllChannel()，即当前消费者所在的消费者组中所有已经注册到当前broker的消
// 费者的Channel
List<Channel> channels = (List<Channel>) args[0];
if (channels != null && brokerController.getBrokerConfig().isNotifyConsumerIdsChangedEnable()) {
    // 遍历消费者的Channel，发送消费者成员变更请求
    for (Channel chl : channels) {
        this.brokerController.getBroker2Client().notifyConsumerIdsChanged(chl, group);
    }
}
break;
```

当发生`ConsumerGroupEvent.CHANGE`事件时，broker会通知所有当前消费者组内的消费者实例，向组内的消费者发送`RequestCode.NOTIFY_CONSUMER_IDS_CHANGED`请求，消费者收到该请求后会发起消费者组内的负载均衡，使得当前消费者组能够根据最新的订阅配置消费消息，这些在笔记[如何实现负载均衡](如何实现负载均衡.md)中已经分析过了。

在发起`ConsumerGroupEvent.CHANGE`事件时后，`registerConsumer()`方法还会发起`ConsumerGroupEvent.REGISTER`事件，对应的处理是：
```java
case REGISTER: // 消费者注册，无论是否是第一次注册，可以认为每次心跳都会触发该事件
if (args == null || args.length < 1) {
    return;
}
// 这里获取的参数为Set<SubscriptionData>，即当前消费者的所有订阅配置
Collection<SubscriptionData> subscriptionDataList = (Collection<SubscriptionData>) args[0];
this.brokerController.getConsumerFilterManager().register(group, subscriptionDataList);
break;
```

上面的逻辑是将订阅配置注册到`ConsumerFilterManager`类，对应的方法是`ConsumerFilterManager`类的`register()`方法：
```java
public void register(final String consumerGroup, final Collection<SubscriptionData> subList) {
    // 遍历消费者发送的心跳中带来的订阅配置
    for (SubscriptionData subscriptionData : subList) {
        // 如果当前订阅配置没有过滤配置，或者过滤的方式为TAG，则直接返回，否则说明过滤的方式为SQL92，此时会使用布隆过滤器为consumerGroup + "#" + topic
        // 字符串创建字节数组，并和过滤表达式一起保存到新建的ConsumerFilterData对象（如果没有的话），再将ConsumerFilterData对象保存到filterDataByTopic属性
        register(
            subscriptionData.getTopic(),
            consumerGroup,
            subscriptionData.getSubString(),
            subscriptionData.getExpressionType(),
            subscriptionData.getSubVersion()
        );
    }

    // make illegal topic dead.
    // ConsumerFilterData对象表示一个消费者组对一个topic的过滤配置，包含了布隆过滤器计算结果、过滤类型、过滤表达式等，目前只支持SQL92类型
    Collection<ConsumerFilterData> groupFilterData = getByGroup(consumerGroup);

    // groupFilterData包含了当前消费者组的所有topic下的配置，一个topic对应一个ConsumerFilterData对象
    Iterator<ConsumerFilterData> iterator = groupFilterData.iterator();
    while (iterator.hasNext()) {
        // 遍历ConsumerFilterData对象，判断ConsumerFilterData对象对应的topic是否包含在传入的subList中
        ConsumerFilterData filterData = iterator.next();

        boolean exist = false;
        for (SubscriptionData subscriptionData : subList) {
            if (subscriptionData.getTopic().equals(filterData.getTopic())) {
                exist = true;
                break;
            }
        }

        // 设置不再被订阅的topic对应的ConsumerFilterData对象的deadTime属性为当前时间，即禁用该ConsumerFilterData对象
        // 设置当前消费者组不再订阅的topic的SubscriptionData对象的deadTime属性，这里不直接删除该配置是因为组内的其他的消费者
        // 成员可能还要用，清除操作会在当前ConsumerFilterManager对象被定时任务持久化时做
        if (!exist && !filterData.isDead()) {
            filterData.setDeadTime(System.currentTimeMillis());
            log.info("Consumer filter changed: {}, make illegal topic dead:{}", consumerGroup, filterData);
        }
    }
}
```

上面实际上都是针对SQL92过滤类型的处理，对于tag类型的过滤方式，没有特殊处理，关于SQL92过滤类型的处理逻辑，在分析SQL92过滤方式的实现时再说。以上是订阅配置被发送到broker后的处理逻辑，下面再看看消息的tag是如何影响消息消费的。

根据笔记[如何实现消息消费](如何实现消息消费.md)可知，broker在处理消费者拉取消息请求时，对应的处理方法是`PullMessageProcessor`类的`processRequest()`方法，其中关于消息过滤的实现如下：
```java
private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend)
    throws RemotingCommandException {
    
    // 略...

    // 这次发送拉取消息请求的消费者是否设置了消息标签，即是否需要根据标签进行过滤
    final boolean hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag());

    // 略...

    SubscriptionData subscriptionData = null;
    // consumerFilterData对象保存了当前消费者组对于当前topic的订阅配置（保存的是SQL92过滤方式的过滤配置）
    ConsumerFilterData consumerFilterData = null;
    // 如果需要根据消息标签进行过滤
    if (hasSubscriptionFlag) {
        try {
            // SubscriptionData对象保存的数据就是传入build方法的参数
            subscriptionData = FilterAPI.build(
                requestHeader.getTopic(), requestHeader.getSubscription(), requestHeader.getExpressionType()
            );
            // 如果不是根据消息标签的hash进行过滤
            if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {
                // 创建consumerFilterData对象
                consumerFilterData = ConsumerFilterManager.build(
                    requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getSubscription(),
                    requestHeader.getExpressionType(), requestHeader.getSubVersion()
                );
                assert consumerFilterData != null;
            }
        } catch (Exception e) {
            log.warn("Parse the consumer's subscription[{}] failed, group: {}", requestHeader.getSubscription(),
                requestHeader.getConsumerGroup());
            response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);
            response.setRemark("parse the consumer's subscription failed");
            return response;
        }
    }

    // 略...

    // MessageFilter对象负责实现消息过滤
    MessageFilter messageFilter;
    if (this.brokerController.getBrokerConfig().isFilterSupportRetry()) {
        messageFilter = new ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,
            this.brokerController.getConsumerFilterManager());
    } else {
        messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,
            this.brokerController.getConsumerFilterManager());
    }

    // 根据位移获取消息，返回的消息最多requestHeader.getMaxMsgNums()条或者800条
    final GetMessageResult getMessageResult =
        this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),
            requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter);
    
    // 略...
}
```

`PullMessageProcessor`类的`processRequest()`方法会创建`SubscriptionData`对象和`ConsumerFilterData`对象，这两个对象的作用就是保存消费者的订阅配置，这个在前面说过了。之后`processRequest()`方法创建`ExpressionMessageFilter`对象并传入`DefaultMessageStore`类的`getMessage()`方法获取消息，消息过滤的实现关键就在于`ExpressionMessageFilter`类，这里先看看`DefaultMessageStore`类的`getMessage()`方法在什么情况下通过`ExpressionMessageFilter`对象过滤消息的：
```java
public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset,
    final int maxMsgNums,
    final MessageFilter messageFilter) {
    if (this.shutdown) {
        log.warn("message store has shutdown, so getMessage is forbidden");
        return null;
    }

    if (!this.runningFlags.isReadable()) {
        log.warn("message store is not readable, so getMessage is forbidden " + this.runningFlags.getFlagBits());
        return null;
    }

    long beginTime = this.getSystemClock().now();

    GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;
    long nextBeginOffset = offset;
    long minOffset = 0;
    long maxOffset = 0;

    GetMessageResult getResult = new GetMessageResult();

    // 获取当前broker中所有消息的最大位移
    final long maxOffsetPy = this.commitLog.getMaxOffset();

    // 根据topic和队列id找到对应的consumeQueue
    ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);
    if (consumeQueue != null) {
        // 当前队列中消息的最小位移
        minOffset = consumeQueue.getMinOffsetInQueue();
        // 当前队列中消息的最大位移
        maxOffset = consumeQueue.getMaxOffsetInQueue();

        // 验证拉取请求的消息位移是否合法，即是否在minOffset和maxOffset之间
        if (maxOffset == 0) {
            status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;
            nextBeginOffset = nextOffsetCorrection(offset, 0);
        } else if (offset < minOffset) {
            status = GetMessageStatus.OFFSET_TOO_SMALL;
            nextBeginOffset = nextOffsetCorrection(offset, minOffset);
        } else if (offset == maxOffset) {
            status = GetMessageStatus.OFFSET_OVERFLOW_ONE;
            nextBeginOffset = nextOffsetCorrection(offset, offset);
        } else if (offset > maxOffset) {
            status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;
            if (0 == minOffset) {
                nextBeginOffset = nextOffsetCorrection(offset, minOffset);
            } else {
                nextBeginOffset = nextOffsetCorrection(offset, maxOffset);
            }
        } else {
            // 根据消息位移获取具体的ConsumeQueue文件的字节数据
            SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);
            if (bufferConsumeQueue != null) {
                try {
                    status = GetMessageStatus.NO_MATCHED_MESSAGE;

                    // 表示可以拉取的消息的最小值，初始为Long.MIN_VALUE即还没有限制
                    long nextPhyFileStartOffset = Long.MIN_VALUE;
                    // 当前ConsumeQueue文件中遍历到的消息位移的最大值
                    long maxPhyOffsetPulling = 0;

                    int i = 0;
                    // 最大可以拉取的消息个数（其实是消息大小，可以看下面for循环的条件，i的值是每次递增ConsumeQueue.CQ_STORE_UNIT_SIZE，
                    // 即20个字节，所以一次拉取请求最多能够拉取16000/20=800条消息）
                    final int maxFilterMessageCount = Math.max(16000, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);
                    // 是否统计这次拉取的消息的最大值和broker保存的消息的最大值之间的差到brokerStatsManager，默认为true
                    final boolean diskFallRecorded = this.messageStoreConfig.isDiskFallRecorded();
                    ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit();
                    // 遍历consumeQueue的记录
                    for (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {
                        // 消息在commitLog文件中的位移
                        long offsetPy = bufferConsumeQueue.getByteBuffer().getLong();
                        // 消息的大小
                        int sizePy = bufferConsumeQueue.getByteBuffer().getInt();
                        // 消息标签的hashCode
                        long tagsCode = bufferConsumeQueue.getByteBuffer().getLong();

                        // 更新遍历到的消息的最大位移值
                        maxPhyOffsetPulling = offsetPy;

                        // nextPhyFileStartOffset会在下面被更新，主要用于判断当前遍历的位移所在的CommitLog文件是否存在
                        if (nextPhyFileStartOffset != Long.MIN_VALUE) {
                            // 如果nextPhyFileStartOffset的值被设置了并且offsetPy < nextPhyFileStartOffset，说明offsetPy
                            // 这个位移所在的CommitLog文件已经被删除了，没必要执行下面的逻辑了
                            if (offsetPy < nextPhyFileStartOffset)
                                continue;
                        }

                        // 判断当前消息位移值对应的消息是否在磁盘中（如果isInDisk为false表示消息在内存中）
                        boolean isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);

                        // 判断是否应该停止拉取消息了，判断依据是已经保存在getResult中的消息数量或者消息大小加上这次遍历到的消息
                        // 大小是否超过了指定的值，传入isInDisk是因为指定的值在消息存在于磁盘和存在于内存时是不一样的
                        if (this.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),
                            isInDisk)) {
                            break;
                        }

                        boolean extRet = false, isTagsCodeLegal = true;
                        // 这里的判断在理解ConsumeQueue类的putMessagePositionInfoWrapper方法的实现之后就能理解，如果isExtAddr
                        // 方法返回true，说明consumequeue文件中保存的tagsCode值不是消息的tag的hash，而是消息的ConsumeQueueExt.CqExtUnit
                        // 对象在consumequeue_ext文件中的位移加上Long.MIN_VALUE的值
                        if (consumeQueue.isExtAddr(tagsCode)) {
                            // 此时根据tagsCode的值从consumequeue_ext文件读取消息的ConsumeQueueExt.CqExtUnit对象的值，并将
                            // 值保存到传入的cqExtUnit对象，ConsumeQueueExt.CqExtUnit对象保存了消息的bitmap数据、消息的保存时间
                            // 和消息标签的hash值（如果消息被保存在定时消息的topic，则tagsCode属性为消息应该被消费的时间戳）
                            // 如果没有ConsumeQueueExt.CqExtUnit对象，则一条消息在consumequeue中正常只有消息的位移、大小和消
                            // 息标签的hash
                            extRet = consumeQueue.getExt(tagsCode, cqExtUnit);
                            if (extRet) { // 读取成功
                                tagsCode = cqExtUnit.getTagsCode();
                            } else {
                                // can't find ext content.Client will filter messages by tag also.
                                log.error("[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}, topic={}, group={}",
                                    tagsCode, offsetPy, sizePy, topic, group);
                                isTagsCodeLegal = false;
                            }
                        }

                        // 根据tagHashCode执行消息过滤（或者ConsumeQueueExt.CqExtUnit对象，如果存在的话）
                        if (messageFilter != null
                            && !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) {
                            if (getResult.getBufferTotalSize() == 0) {
                                // 如果消息不匹配并且还没有成功拉取到消息，设置状态为NO_MATCHED_MESSAGE
                                status = GetMessageStatus.NO_MATCHED_MESSAGE;
                            }

                            continue;
                        }

                        // 从commitLog读取指定位移的消息，只要offsetPy的位移所在的CommitLog文件还存在（即还没有从磁盘中被删除）
                        // 则selectResult就不会为空
                        SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);
                        if (null == selectResult) {
                            // 如果结果为空并且这次拉取操作还没有读到过消息，说明当前遍历到的位移所在的CommitLog文件已经被删除了，
                            // rocketmq是有定期删除CommitLog文件的逻辑的
                            if (getResult.getBufferTotalSize() == 0) {
                                status = GetMessageStatus.MESSAGE_WAS_REMOVING;
                            }

                            // 此时将nextPhyFileStartOffset设置为下一个CommitLog文件的起始位移，循环开始会跳过小于
                            // nextPhyFileStartOffset的位移，这样就使得后续不存在对应CommitLog文件的位移会被跳过
                            nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy);
                            continue;
                        }

                        // 按照消息内容进行过滤
                        if (messageFilter != null
                            && !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), null)) {
                            if (getResult.getBufferTotalSize() == 0) {
                                status = GetMessageStatus.NO_MATCHED_MESSAGE;
                            }
                            // release...
                            selectResult.release();
                            continue;
                        }

                        this.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();
                        // 保存消息到结果集
                        getResult.addMessage(selectResult);
                        status = GetMessageStatus.FOUND;
                        nextPhyFileStartOffset = Long.MIN_VALUE;
                    }

                    if (diskFallRecorded) {
                        long fallBehind = maxOffsetPy - maxPhyOffsetPulling;
                        brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);
                    }

                    // 更新下一次应该拉取的消息位移
                    nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);

                    // 计算当前broker的消息的最大位移和这次拉取到的消息的位移的差值
                    long diff = maxOffsetPy - maxPhyOffsetPulling;
                    // 计算允许保存在内存中的消息的大小，默认为物理内存的40%
                    long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE
                        * (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0));
                    // 如果diff > memory说明消费者拉取的消息的消费位移和broker保存的消息中位移最大的值的差大于broker能够用于
                    // 保存消息的内存值，导致当前消费者拉取的消息需要从磁盘读取，此时设置suggestPullingFromSlave为true表示建议
                    // 之后的拉取请求从slave拉取
                    getResult.setSuggestPullingFromSlave(diff > memory);
                } finally {
                    bufferConsumeQueue.release();
                }
            } else {
                status = GetMessageStatus.OFFSET_FOUND_NULL;
                nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));
                log.warn("consumer request topic: " + topic + "offset: " + offset + " minOffset: " + minOffset + " maxOffset: "
                    + maxOffset + ", but access logic queue failed.");
            }
        }
    } else {
        // 看findConsumeQueue方法的实现，好像不会存在consumeQueue对象为空的情况
        status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;
        nextBeginOffset = nextOffsetCorrection(offset, 0);
    }

    // 记录统计数据
    if (GetMessageStatus.FOUND == status) {
        this.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();
    } else {
        this.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();
    }
    long elapsedTime = this.getSystemClock().now() - beginTime;
    this.storeStatsService.setGetMessageEntireTimeMax(elapsedTime);

    getResult.setStatus(status);
    // nextBeginOffset为下一次拉取消息时应该拉取的起始位移
    getResult.setNextBeginOffset(nextBeginOffset);
    // maxOffset为当前consumeQueue的消息位移的最大值
    getResult.setMaxOffset(maxOffset);
    // maxOffset为当前consumeQueue的消息位移的最小值
    getResult.setMinOffset(minOffset);
    return getResult;
}
```

对于`DefaultMessageStore`类的`getMessage()`方法的调用时机和其它实现细节可以看笔记[如何实现消息消费](如何实现消息消费.md)，这里只针对消息过滤的代码进行分析，对应语句：
```java
ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit();

// 略...

// extRet表示是否存在ConsumeQueueExt.CqExtUnit对象，isTagsCodeLegal表示tagsCode的值是否合法
boolean extRet = false, isTagsCodeLegal = true;
// 这里的判断在理解ConsumeQueue类的putMessagePositionInfoWrapper方法的实现之后就能理解，如果isExtAddr
// 方法返回true，说明consumequeue文件中保存的tagsCode值不是消息的tag的hash，而是消息的ConsumeQueueExt.CqExtUnit
// 对象在consumequeue_ext文件中的位移加上Long.MIN_VALUE的值
if (consumeQueue.isExtAddr(tagsCode)) {
    // 此时根据tagsCode的值从consumequeue_ext文件读取消息的ConsumeQueueExt.CqExtUnit对象的值，并将
    // 值保存到传入的cqExtUnit对象，ConsumeQueueExt.CqExtUnit对象保存了消息的bitmap数据、消息的保存时间
    // 和消息标签的hash值（如果消息被保存在定时消息的topic，则tagsCode属性为消息应该被消费的时间戳）
    // 如果没有ConsumeQueueExt.CqExtUnit对象，则一条消息在consumequeue中正常只有消息的位移、大小和消
    // 息标签的hash
    extRet = consumeQueue.getExt(tagsCode, cqExtUnit);
    if (extRet) { // 读取成功
        tagsCode = cqExtUnit.getTagsCode();
    } else {
        // can't find ext content.Client will filter messages by tag also.
        log.error("[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}, topic={}, group={}",
            tagsCode, offsetPy, sizePy, topic, group);
        // 获取ConsumeQueueExt.CqExtUnit对象失败则设置isTagsCodeLegal为false
        isTagsCodeLegal = false;
    }
}

// 根据tagHashCode执行消息过滤（或者ConsumeQueueExt.CqExtUnit对象，如果存在的话）
// messageFilter默认实现为ExpressionMessageFilter
if (messageFilter != null
    && !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) {
    if (getResult.getBufferTotalSize() == 0) {
        // 如果消息不匹配并且还没有成功拉取到消息，设置状态为NO_MATCHED_MESSAGE
        status = GetMessageStatus.NO_MATCHED_MESSAGE;
    }

    continue;
}
```

`consumeQueue.isExtAddr(tagsCode)`方法用于判断当前消息在consumequeue文件中保存的tagsCode的值是否是该消息的`ConsumeQueueExt.CqExtUnit`对象在consumequeue_ext文件的位移而不是正常情况下消息标签的hash，`ConsumeQueueExt.CqExtUnit`对象保存了消息的bitmap、创建时间和标签的hash，关于`ConsumeQueueExt.CqExtUnit`对象的创建可以看笔记[如何实现消息存储](../broker/如何实现消息存储.md)。

这里假设最复杂的情况，`consumeQueue.isExtAddr(tagsCode)`语句返回true，此时消息标签的hash保存在`ConsumeQueueExt.CqExtUnit`对象，不能通过tagsCode直接获取。在获取到`ConsumeQueueExt.CqExtUnit`对象后，通过`messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)`语句执行过滤逻辑，`messageFilter`对象的实现就是前面分析过的`PullMessageProcessor`类的`processRequest()`方法创建的`ExpressionMessageFilter`类，`ExpressionMessageFilter`类的`isMatchedByConsumeQueue()`方法：
```java
@Override
public boolean isMatchedByConsumeQueue(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit) {
    if (null == subscriptionData) {
        return true;
    }

    if (subscriptionData.isClassFilterMode()) {
        return true;
    }

    // by tags code.
    // 如果是根据消息标签的hashCode进行过滤
    if (ExpressionType.isTagType(subscriptionData.getExpressionType())) {

        if (tagsCode == null) {
            return true;
        }

        // 如果过滤表达式是*，则直接返回true
        if (subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)) {
            return true;
        }

        // 否则返回消费者订阅的tag的hash中是否包含当前tagsCode值
        return subscriptionData.getCodeSet().contains(tagsCode.intValue());
    } else {
        // no expression or no bloom
        // 非标签过滤，则为SQL92过滤方式
        // 如果SQL92的配置为空，则直接返回
        if (consumerFilterData == null || consumerFilterData.getExpression() == null
            || consumerFilterData.getCompiledExpression() == null || consumerFilterData.getBloomFilterData() == null) {
            return true;
        }

        // message is before consumer
        // 如果consumerFilterData的创建时间小于消息的存储时间，则直接返回true
        if (cqExtUnit == null || !consumerFilterData.isMsgInLive(cqExtUnit.getMsgStoreTime())) {
            log.debug("Pull matched because not in live: {}, {}", consumerFilterData, cqExtUnit);
            return true;
        }

        byte[] filterBitMap = cqExtUnit.getFilterBitMap();
        BloomFilter bloomFilter = this.consumerFilterManager.getBloomFilter();
        if (filterBitMap == null || !this.bloomDataValid
            || filterBitMap.length * Byte.SIZE != consumerFilterData.getBloomFilterData().getBitNum()) {
            return true;
        }

        BitsArray bitsArray = null;
        try {
            bitsArray = BitsArray.create(filterBitMap);
            boolean ret = bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray);
            log.debug("Pull {} by bit map:{}, {}, {}", ret, consumerFilterData, bitsArray, cqExtUnit);
            return ret;
        } catch (Throwable e) {
            log.error("bloom filter error, sub=" + subscriptionData
                + ", filter=" + consumerFilterData + ", bitMap=" + bitsArray, e);
        }
    }

    return true;
}
```

关于消息tag的过滤方式的实现从上面的代码中就能看出，简单来说就是根据从消费者心跳包中获取到的消费者的订阅配置判断当前消息是否在消费者订阅的tag的hash列表中。

以上是消息tag过滤的实现

## SQL92过滤
SQL92过滤和tag过滤的实现都在`ExpressionMessageFilter`类的`isMatchedByConsumeQueue()`方法，下面承接上面分析的tag过滤的实现过程，直接从`ExpressionMessageFilter`类的`isMatchedByConsumeQueue()`方法开始分析rocketmq如何实现SQL92过滤的，对应的语句：
```java
// no expression or no bloom
// 非标签过滤，则为SQL92过滤方式
// 如果SQL92的配置为空，则直接返回
if (consumerFilterData == null || consumerFilterData.getExpression() == null
    || consumerFilterData.getCompiledExpression() == null || consumerFilterData.getBloomFilterData() == null) {
    return true;
}

// message is before consumer
// 如果consumerFilterData的创建时间小于消息的存储时间，则直接返回true
if (cqExtUnit == null || !consumerFilterData.isMsgInLive(cqExtUnit.getMsgStoreTime())) {
    log.debug("Pull matched because not in live: {}, {}", consumerFilterData, cqExtUnit);
    return true;
}

// 获取bitmap，也就是CommitLogDispatcherCalcBitMap类中根据consumerGroup + "#" + topic字符串经过布隆过滤器得到的结果
byte[] filterBitMap = cqExtUnit.getFilterBitMap();
// 获取布隆过滤器
BloomFilter bloomFilter = this.consumerFilterManager.getBloomFilter();

if (filterBitMap == null || !this.bloomDataValid
    || filterBitMap.length * Byte.SIZE != consumerFilterData.getBloomFilterData().getBitNum()) {
    return true;
}

BitsArray bitsArray = null;
try {
    // BitsArray对象表示一个字节数组，能够方便的执行or、and、xor、not等操作
    bitsArray = BitsArray.create(filterBitMap);
    // consumerFilterData.getBloomFilterData()是使用布隆过滤器计算consumerGroup + "#" + topic字符串的计算结果
    // 这里判断consumerFilterData.getBloomFilterData()中保存的所有位置在bitsArray中是否都是1，注意根据CommitLogDispatcherCalcBitMap
    // 的实现，bitsArray只是保存了表达式结果为true的consumerFilterData的结果，所以当这里的isHit方法返回false，即consumerFilterData.getBloomFilterData()
    // 不在bitsArray这个布隆过滤器的结果之内，此时消息应该被过滤
    boolean ret = bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray);
    log.debug("Pull {} by bit map:{}, {}, {}", ret, consumerFilterData, bitsArray, cqExtUnit);
    return ret;
} catch (Throwable e) {
    log.error("bloom filter error, sub=" + subscriptionData
        + ", filter=" + consumerFilterData + ", bitMap=" + bitsArray, e);
}
```

上面的实现的关键语句在于`bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray)`，其中`consumerFilterData.getBloomFilterData()`表示的是当前topic在当前消费者组内的订阅配置经过布隆过滤器计算后的结果，即consumerGroup + "#" + topic字符串的计算结果，这个值的计算过程发生在broker处理消费者的心跳时调用的`ConsumerFilterManager`类的`register()`方法：
```java
public boolean register(final String topic, final String consumerGroup, final String expression,
    final String type, final long clientVersion) {
    if (ExpressionType.isTagType(type)) {
        return false;
    }

    if (expression == null || expression.length() == 0) {
        return false;
    }

    // FilterDataMapByTopic对象包含了一个topic在所有消费者组中的订阅配置
    FilterDataMapByTopic filterDataMapByTopic = this.filterDataByTopic.get(topic);

    if (filterDataMapByTopic == null) {
        FilterDataMapByTopic temp = new FilterDataMapByTopic(topic);
        FilterDataMapByTopic prev = this.filterDataByTopic.putIfAbsent(topic, temp);
        filterDataMapByTopic = prev != null ? prev : temp;
    }

    // 使用布隆过滤器创建BloomFilterData对象，该对象包含了根据consumerGroup + "#" + topic计算得到的字节位置
    BloomFilterData bloomFilterData = bloomFilter.generate(consumerGroup + "#" + topic);

    return filterDataMapByTopic.register(consumerGroup, expression, type, bloomFilterData, clientVersion);
}
```

也就是说每次消费者发送心跳时，broker会调用`ConsumerFilterManager`类的`register()`方法将心跳中的订阅配置保存下来，并且通过计算心跳的consumerGroup + "#" + topic字符串的字节位置，并保存到`BloomFilterData`对象，以该对象标识某个消费者组对于某个topic的订阅配置，便于之后在布隆过滤器中判断该订阅配置是否被放置到了布隆过滤器中（即是否所有字节位置在布隆过滤器中都为true）

回到`bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray)`语句，`consumerFilterData.getBloomFilterData()`表示的就是一个消费者组对于某个topic的订阅配置的字节值，而`bitsArray`为某条消息的布隆过滤器的值，这个值的计算发生在`CommitLogDispatcherCalcBitMap`类，关于`CommitLogDispatcherCalcBitMap`类的调用实际可以看笔记[如何实现消息存储](../broker/如何实现消息存储.md)，这里只关心`CommitLogDispatcherCalcBitMap`类的实现，该类的代码如下：
```java
public class CommitLogDispatcherCalcBitMap implements CommitLogDispatcher {

    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.FILTER_LOGGER_NAME);

    protected final BrokerConfig brokerConfig;
    protected final ConsumerFilterManager consumerFilterManager;

    public CommitLogDispatcherCalcBitMap(BrokerConfig brokerConfig, ConsumerFilterManager consumerFilterManager) {
        this.brokerConfig = brokerConfig;
        this.consumerFilterManager = consumerFilterManager;
    }

    @Override
    public void dispatch(DispatchRequest request) {
        // broker的enableCalcFilterBitMap属性为true时CommitLogDispatcherCalcBitMap类才生效，默认为false
        if (!this.brokerConfig.isEnableCalcFilterBitMap()) {
            return;
        }

        try {
            // 获取当前消息的topic的在所有消费者组下的过滤配置
            Collection<ConsumerFilterData> filterDatas = consumerFilterManager.get(request.getTopic());

            if (filterDatas == null || filterDatas.isEmpty()) {
                return;
            }

            Iterator<ConsumerFilterData> iterator = filterDatas.iterator();
            BitsArray filterBitMap = BitsArray.create(
                this.consumerFilterManager.getBloomFilter().getM()
            );

            long startTime = System.currentTimeMillis();
            // 遍历当前topic在所有消费者组下的过滤配置
            while (iterator.hasNext()) {
                ConsumerFilterData filterData = iterator.next();

                if (filterData.getCompiledExpression() == null) {
                    log.error("[BUG] Consumer in filter manager has no compiled expression! {}", filterData);
                    continue;
                }

                // filterData.getBloomFilterData()保存的是consumerGroup + "#" + topic这个字符串经过布隆过滤器计算得到的结果
                if (filterData.getBloomFilterData() == null) {
                    log.error("[BUG] Consumer in filter manager has no bloom data! {}", filterData);
                    continue;
                }

                Object ret = null;
                try {
                    // 根据消息的属性计算表达式的结果
                    MessageEvaluationContext context = new MessageEvaluationContext(request.getPropertiesMap());

                    ret = filterData.getCompiledExpression().evaluate(context);
                } catch (Throwable e) {
                    log.error("Calc filter bit map error!commitLogOffset={}, consumer={}, {}", request.getCommitLogOffset(), filterData, e);
                }

                log.debug("Result of Calc bit map:ret={}, data={}, props={}, offset={}", ret, filterData, request.getPropertiesMap(), request.getCommitLogOffset());

                // eval true
                // 表达式结果为true，说明消息不应该被过滤，此时将consumerGroup + "#" + topic这个字符串布隆过滤器计算得到的结果保存到
                // filterBitMap中，表示consumerGroup这个消费者组的指定topic已经计算过SQL92表达式并且结果为true
                // 为false的不应该被放进去，这和布隆过滤器的工作原理有关，true和false都放到布隆过滤器那就起不到过滤消息的效果，具体可以看
                // ExpressionMessageFilter中如何使用布隆过滤器的
                if (ret != null && ret instanceof Boolean && (Boolean) ret) {
                    consumerFilterManager.getBloomFilter().hashTo(
                        filterData.getBloomFilterData(),
                        filterBitMap
                    );
                }
            }

            // 保存filterBitMap
            request.setBitMap(filterBitMap.bytes());

            long elapsedTime = UtilAll.computeElapsedTimeMilliseconds(startTime);
            // 1ms
            if (elapsedTime >= 1) {
                log.warn("Spend {} ms to calc bit map, consumerNum={}, topic={}", elapsedTime, filterDatas.size(), request.getTopic());
            }
        } catch (Throwable e) {
            log.error("Calc bit map error! topic={}, offset={}, queueId={}, {}", request.getTopic(), request.getCommitLogOffset(), request.getQueueId(), e);
        }
    }
}
```

`CommitLogDispatcherCalcBitMap`类的实现并不复杂，其`dispatch()`方法的参数`DispatchRequest`对象表示的是某条从commitlog文件读取到的消息，`CommitLogDispatcherCalcBitMap`类的目的是计算消息的bitmap，这个值将被作为布隆过滤器中被使用的字节数组，也就是上面说的`bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray)`语句的`bitsArray`参数，计算过程是遍历传入的消息所在的topic在所有消费者组下的过滤配置，即`ConsumerFilterData`对象，之后根据保存在`ConsumerFilterData`对象中的`Expression`对象进行表达式计算，即：
```java
// 根据消息的属性计算表达式的结果
MessageEvaluationContext context = new MessageEvaluationContext(request.getPropertiesMap());

ret = filterData.getCompiledExpression().evaluate(context);
```

计算的结果会被保存到`DispatchRequest`对象：
```java
// 表达式结果为true，说明消息不应该被过滤，此时将consumerGroup + "#" + topic这个字符串布隆过滤器计算得到的结果保存到
// filterBitMap中，表示consumerGroup这个消费者组的指定topic已经计算过SQL92表达式并且结果为true
// 为false的不应该被放进去，这和布隆过滤器的工作原理有关，true和false都放到布隆过滤器那就起不到过滤消息的效果，具体可以看
// ExpressionMessageFilter中如何使用布隆过滤器的
if (ret != null && ret instanceof Boolean && (Boolean) ret) {
    consumerFilterManager.getBloomFilter().hashTo(
        filterData.getBloomFilterData(),
        filterBitMap
    );
}
```

这里只保存表达式结果为true的，而保存的数据是`filterData.getBloomFilterData()`，也就是根据consumerGroup + "#" + topic字符串的字节位置，代表当前topic的一个消费者组的配置，这和前面看到的消息过滤过程中通过`bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray)`语句判断消息是否应该被过滤是相呼应的。当`bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray)`语句返回true，说明传入的消费者组的订阅配置在`CommitLogDispatcherCalcBitMap`类中已经计算过表达式并且表达式结果为true，说明当前消息应该被当前消费者组消费。

以上是根据`ExpressionMessageFilter`类的`isMatchedByConsumeQueue()`方法实现的SQL92消息过滤，但是这种过滤方式有个前提，就是broker的`enableConsumeQueueExt`属性为true，即保存消息的consumequeue记录时，需要额外创建`ConsumeQueueExt.CqExtUnit`对象记录消息在`CommitLogDispatcherCalcBitMap`类中的计算结果并保存到consumequeue_ext文件。如果`enableConsumeQueueExt`属性为false，则消息不会创建`ConsumeQueueExt.CqExtUnit`对象，前面分析的`DefaultMessageStore`类的`getMessage()`方法调用`isMatchedByConsumeQueue()`方法时传入的`ConsumeQueueExt.CqExtUnit`对象也就是空：
```java
boolean extRet = false, isTagsCodeLegal = true;
// 这里的判断在理解ConsumeQueue类的putMessagePositionInfoWrapper方法的实现之后就能理解，如果isExtAddr
// 方法返回true，说明consumequeue文件中保存的tagsCode值不是消息的tag的hash，而是消息的ConsumeQueueExt.CqExtUnit
// 对象在consumequeue_ext文件中的位移加上Long.MIN_VALUE的值
if (consumeQueue.isExtAddr(tagsCode)) {
    // 此时根据tagsCode的值从consumequeue_ext文件读取消息的ConsumeQueueExt.CqExtUnit对象的值，并将
    // 值保存到传入的cqExtUnit对象，ConsumeQueueExt.CqExtUnit对象保存了消息的bitmap数据、消息的保存时间
    // 和消息标签的hash值（如果消息被保存在定时消息的topic，则tagsCode属性为消息应该被消费的时间戳）
    // 如果没有ConsumeQueueExt.CqExtUnit对象，则一条消息在consumequeue中正常只有消息的位移、大小和消
    // 息标签的hash
    extRet = consumeQueue.getExt(tagsCode, cqExtUnit);
    if (extRet) { // 读取成功
        tagsCode = cqExtUnit.getTagsCode();
    } else {
        // can't find ext content.Client will filter messages by tag also.
        log.error("[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}, topic={}, group={}",
            tagsCode, offsetPy, sizePy, topic, group);
        // 获取ConsumeQueueExt.CqExtUnit对象失败则设置isTagsCodeLegal为false
        isTagsCodeLegal = false;
    }
}

// 根据tagHashCode执行消息过滤（或者ConsumeQueueExt.CqExtUnit对象，如果存在的话）
// messageFilter默认实现为ExpressionMessageFilter，这里判断消息是否应该被过滤掉
if (messageFilter != null
    && !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) {
    if (getResult.getBufferTotalSize() == 0) {
        // 如果消息不匹配并且还没有成功拉取到消息，设置状态为NO_MATCHED_MESSAGE
        status = GetMessageStatus.NO_MATCHED_MESSAGE;
    }

    continue;
}
```

默认情况下broker的`enableConsumeQueueExt`属性为false，所以默认情况下`ExpressionMessageFilter`类的`isMatchedByConsumeQueue()`方法对于SQL92的过滤方式是不起作用的，下面看看默认情况下SQL92的过滤是如何实现的，代码还是在`DefaultMessageStore`类的`getMessage()`方法中：
```java
// extRet表示是否存在ConsumeQueueExt.CqExtUnit对象，isTagsCodeLegal表示tagsCode的值是否合法
boolean extRet = false, isTagsCodeLegal = true;
// 这里的判断在理解ConsumeQueue类的putMessagePositionInfoWrapper方法的实现之后就能理解，如果isExtAddr
// 方法返回true，说明consumequeue文件中保存的tagsCode值不是消息的tag的hash，而是消息的ConsumeQueueExt.CqExtUnit
// 对象在consumequeue_ext文件中的位移加上Long.MIN_VALUE的值
if (consumeQueue.isExtAddr(tagsCode)) {
    // 此时根据tagsCode的值从consumequeue_ext文件读取消息的ConsumeQueueExt.CqExtUnit对象的值，并将
    // 值保存到传入的cqExtUnit对象，ConsumeQueueExt.CqExtUnit对象保存了消息的bitmap数据、消息的保存时间
    // 和消息标签的hash值（如果消息被保存在定时消息的topic，则tagsCode属性为消息应该被消费的时间戳）
    // 如果没有ConsumeQueueExt.CqExtUnit对象，则一条消息在consumequeue中正常只有消息的位移、大小和消
    // 息标签的hash
    extRet = consumeQueue.getExt(tagsCode, cqExtUnit);
    if (extRet) { // 读取成功
        tagsCode = cqExtUnit.getTagsCode();
    } else {
        // can't find ext content.Client will filter messages by tag also.
        log.error("[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}, topic={}, group={}",
            tagsCode, offsetPy, sizePy, topic, group);
        // 获取ConsumeQueueExt.CqExtUnit对象失败则设置isTagsCodeLegal为false
        isTagsCodeLegal = false;
    }
}

// 根据tagHashCode执行消息过滤（或者ConsumeQueueExt.CqExtUnit对象，如果存在的话）
// messageFilter默认实现为ExpressionMessageFilter，这里判断消息是否应该被过滤掉
if (messageFilter != null
    && !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) {
    if (getResult.getBufferTotalSize() == 0) {
        // 如果消息不匹配并且还没有成功拉取到消息，设置状态为NO_MATCHED_MESSAGE
        status = GetMessageStatus.NO_MATCHED_MESSAGE;
    }

    continue;
}

// 从commitLog读取指定位移的消息，只要offsetPy的位移所在的CommitLog文件还存在（即还没有从磁盘中被删除）
// 则selectResult就不会为空
SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);
if (null == selectResult) {
    // 如果结果为空并且这次拉取操作还没有读到过消息，说明当前遍历到的位移所在的CommitLog文件已经被删除了，
    // rocketmq是有定期删除CommitLog文件的逻辑的
    if (getResult.getBufferTotalSize() == 0) {
        status = GetMessageStatus.MESSAGE_WAS_REMOVING;
    }

    // 此时将nextPhyFileStartOffset设置为下一个CommitLog文件的起始位移，循环开始会跳过小于
    // nextPhyFileStartOffset的位移，这样就使得后续不存在对应CommitLog文件的位移会被跳过
    nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy);
    continue;
}

// 按照消息内容进行过滤
if (messageFilter != null
    && !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), null)) {
    if (getResult.getBufferTotalSize() == 0) {
        status = GetMessageStatus.NO_MATCHED_MESSAGE;
    }
    // release...
    selectResult.release();
    continue;
}
```

在`messageFilter.isMatchedByConsumeQueue()`过滤不起作用时，`getMessage()`方法会从commitlog文件获取消息并调用`messageFilter.isMatchedByCommitLog()`语句再次尝试消息过滤，对应的方法是`ExpressionMessageFilter`类的`isMatchedByCommitLog()`方法：
```java
@Override
public boolean isMatchedByCommitLog(ByteBuffer msgBuffer, Map<String, String> properties) {
    if (subscriptionData == null) {
        return true;
    }

    if (subscriptionData.isClassFilterMode()) {
        return true;
    }

    if (ExpressionType.isTagType(subscriptionData.getExpressionType())) {
        return true;
    }

    ConsumerFilterData realFilterData = this.consumerFilterData;
    Map<String, String> tempProperties = properties;

    // no expression
    if (realFilterData == null || realFilterData.getExpression() == null
        || realFilterData.getCompiledExpression() == null) {
        return true;
    }

    // 获取消息的属性
    if (tempProperties == null && msgBuffer != null) {
        tempProperties = MessageDecoder.decodeProperties(msgBuffer);
    }

    Object ret = null;
    try {
        // 计算表达式
        MessageEvaluationContext context = new MessageEvaluationContext(tempProperties);

        ret = realFilterData.getCompiledExpression().evaluate(context);
    } catch (Throwable e) {
        log.error("Message Filter error, " + realFilterData + ", " + tempProperties, e);
    }

    log.debug("Pull eval result: {}, {}, {}", ret, realFilterData, tempProperties);

    if (ret == null || !(ret instanceof Boolean)) {
        return false;
    }

    return (Boolean) ret;
}
```

上面的实现和`CommitLogDispatcherCalcBitMap`类的`dispatch()`方法的计算过程是一样的，通过消息的属性构建`MessageEvaluationContext`对象并计算表达式，以此作为消息过滤的依据，所以可以看到在默认情况下，每次消费消息都会计算一次SQL92，可以考虑开启broker的`enableConsumeQueueExt`属性避免重复计算，根据`CommitLogDispatcherCalcBitMap`类中`dispatch()`方法的判断还要设置broker的`enableCalcFilterBitMap`属性为true，使`CommitLogDispatcherCalcBitMap`类生效。

消息过滤过程中的表达式计算语句如下：
```java
MessageEvaluationContext context = new MessageEvaluationContext(tempProperties);
ret = realFilterData.getCompiledExpression().evaluate(context);
```

这里不对表达式的计算做分析，有必要的话再看`SqlFilter`类的实现即可，rocketmq的官网也有一章对SQL92实现的简单介绍：https://rocketmq.apache.org/rocketmq/filter-messages-by-sql92-in-rocketmq/，可以看看。

以上是SQL92过滤的实现方式。

## FilterServer过滤
rocketmq 4.3.0删除了这种过滤方式，略