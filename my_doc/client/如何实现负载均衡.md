负载均衡分别作用域生产者和消费者，下面对这两种情况分别分析。


## 生产者
对于生产者中的负载均衡，是为了生产者能够将消息平均的发往多个broker中的队列，这里假设有如下场景：

有个由两个broker节点组成的集群，有topic1，默认在每个broker上创建4个队列，分别是：master-a（q0,q1,q2,q3）、master-b（q0,q1,q2,q3），上一次发送消息到master-a的q0队列，根据rocketmq的生产者实现，当再次发送消息时，会轮询下一个队列也就是master-a的q1队列进行消息发送，但是如果master-a宕机了，如果继续发送topic1消息并且继续轮询队列的话，rocketmq如果避免再次发送到master-a？

以上问题引出了rocketmq发送消息时如何选择队列的一些机制，选择队列有两种方式，通过`sendLatencyFaultEnable`的值来控制，默认值为false，不启动broker故障延迟机制，值为true时启用broker故障延迟机制。

根据笔记[如何实现消息发送](如何实现消息发送.md)可知，发送消息过程中调用的`DefaultMQProducerImpl`类的`sendDefaultImpl()`方法在获取到路由信息后，需要选择一个队列发送消息，选择过程在`DefaultMQProducerImpl`类的`selectOneMessageQueue()`方法，代码如下：
```java
public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {
    return this.mqFaultStrategy.selectOneMessageQueue(tpInfo, lastBrokerName);
}
```

真正调用的是`MQFaultStrategy`类的`selectOneMessageQueue()`方法，关于该方法，可以先看下面测试代码的输出，对发送消息时的故障转移过程有个认识：
```java
public class MQFaultStrategyTest {
    public static void main(String[] args) {
        // 以该参数表示每次发送是成功还是失败，来分别观察MQFaultStrategy类在这两种情况下的不同
        boolean fail = false;
        System.out.println("假设每次发送" + (fail ? "失败" : "成功"));

        final MQFaultStrategy mqFaultStrategy = new MQFaultStrategy();
        mqFaultStrategy.setSendLatencyFaultEnable(true);

        final TopicPublishInfo topicPublishInfo = new TopicPublishInfo();
        topicPublishInfo.setHaveTopicRouterInfo(true);
        TopicRouteData topicRouteData = new TopicRouteData();
        topicRouteData.setQueueDatas(new ArrayList<>());
        topicPublishInfo.setMessageQueueList(new ArrayList<>());
        topicPublishInfo.setTopicRouteData(topicRouteData);

        Map<String, Integer> latencyMap = new HashMap<>();

        addBroker(topicPublishInfo, latencyMap, 30000, "topic-a", "broker1", 4);
        addBroker(topicPublishInfo, latencyMap, 50000, "topic-a", "broker2", 4);

        for (int i = 0; i < 10; i++) {
            System.out.println(String.format("第%d次开始循环", i));
            String lastBrokerName = null;
            for (int j = 0; j < 2; j++) {
                final MessageQueue messageQueue = mqFaultStrategy.selectOneMessageQueue(topicPublishInfo, lastBrokerName);
                lastBrokerName = messageQueue.getBrokerName();
                System.out.println(String.format("第%d次发送使用broker: %s", j, lastBrokerName));

                try {
                    sendMessage(messageQueue, fail);
                    mqFaultStrategy.updateFaultItem(lastBrokerName, latencyMap.get(lastBrokerName), false);
                } catch (Exception e) {
                    mqFaultStrategy.updateFaultItem(lastBrokerName, latencyMap.get(lastBrokerName), true);
                }
            }
        }
    }

    private static void sendMessage(MessageQueue messageQueue, boolean fail) {
        if (fail) {
            throw new RuntimeException("发送失败");
        }
    }

    private static void addBroker(TopicPublishInfo topicPublishInfo, Map<String, Integer> latencyMap, int latency, String topic, String brokerName, int num) {
        QueueData queueData = new QueueData();
        queueData.setBrokerName(brokerName);
        queueData.setWriteQueueNums(num);
        queueData.setReadQueueNums(num);
        topicPublishInfo.getTopicRouteData().getQueueDatas().add(queueData);

        latencyMap.put(brokerName, latency);

        for (int i = 0; i < num; i++) {
            MessageQueue messageQueue = new MessageQueue();
            messageQueue.setBrokerName(brokerName);
            messageQueue.setQueueId(i);
            messageQueue.setTopic(topic);
            topicPublishInfo.getMessageQueueList().add(messageQueue);

        }
    }
}

/*
测试输出1：
假设每次发送成功
第0次开始循环
第0次发送使用broker: broker1
第1次开始循环
第0次发送使用broker: broker2
第2次开始循环
第0次发送使用broker: broker1
第3次开始循环
第0次发送使用broker: broker1
第4次开始循环
第0次发送使用broker: broker1
第5次开始循环
第0次发送使用broker: broker1
第6次开始循环
第0次发送使用broker: broker1
第7次开始循环
第0次发送使用broker: broker1
第8次开始循环
第0次发送使用broker: broker1
第9次开始循环
第0次发送使用broker: broker1

测试输出2：
假设每次发送失败
第0次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第1次开始循环
第0次发送使用broker: broker2
第1次发送使用broker: broker1
第2次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第3次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第4次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第5次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第6次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第7次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第8次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第9次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
*/
```

上面的代码模拟了10次发送消息的过程，在假设每次发送成功的情况下，可以看到输出，第一次循环选择了broker1，第二次broker选择了broker2，但之后的发送都选择了broker1，这是因为上面的代码设置了broker1的延迟时间为30000（这里的延迟时间为了简单起见，即表示了发送成功情况下的延迟，也表示了发送失败情况下的延迟），broker2的延迟时间为50000，证明`MQFaultStrategy`类根据延迟时间维护了优先级，broker1优先于broker2。

在假设每次发送失败的情况下，可以看到输出，，第一次循环选择了broker1，第二次broker选择了broker2，但第二次循环的重试选择的是broker1，并且之后的循环选择的都是broker1。

下面开始分析`MQFaultStrategy`类的实现，并解释上面输出的原理。

测试代码模拟了发送消息的代码，发送消息的逻辑在一个循环中，以达到失败重试的目的。每次发送消息时，都会调用`MQFaultStrategy`类的`selectOneMessageQueue()`方法选择一个队列进行发送。假设场景如测试代码中所示：topic-a在broker1中有4个写队列，在broker2中有4个写队列，向broker1发送消息时假设无论成功和失败，延迟都是30000，而broker2延迟时50000。

### 默认机制
在默认情况下，即`sendLatencyFaultEnable`的值为false时，不开启broker容错延迟开关，此时`MQFaultStrategy`类的`selectOneMessageQueue()`执行的代码是：
```java
public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {
    if (this.sendLatencyFaultEnable) {
      // 略
    }

    return tpInfo.selectOneMessageQueue(lastBrokerName);
}
```

不开启broker容错延迟时直接执行`tpInfo.selectOneMessageQueue(lastBrokerName)`选择队列，该方法代码如下：
```java
public MessageQueue selectOneMessageQueue(final String lastBrokerName) {
    if (lastBrokerName == null) {
        return selectOneMessageQueue();
    } else {
        // 获取保存在ThreadLocal中的counter值并递增，以便于轮询选择队列
        int index = this.sendWhichQueue.getAndIncrement();
        for (int i = 0; i < this.messageQueueList.size(); i++) {
            int pos = Math.abs(index++) % this.messageQueueList.size();
            if (pos < 0)
                pos = 0;
            MessageQueue mq = this.messageQueueList.get(pos);
            // 如果选择的队列的broker和上次失败的broker是同一个，则跳过，否则返回
            if (!mq.getBrokerName().equals(lastBrokerName)) {
                return mq;
            }
        }
        // 如果没有选中队列则直接使用sendWhichQueue变量轮询一个队列返回
        return selectOneMessageQueue();
    }
}

public MessageQueue selectOneMessageQueue() {
    int index = this.sendWhichQueue.getAndIncrement();
    int pos = Math.abs(index) % this.messageQueueList.size();
    if (pos < 0)
        pos = 0;
    return this.messageQueueList.get(pos);
}
```

上面的逻辑很简单，用一个保存在`ThreadLocal`中的counter值实现轮询队列的效果，如果`lastBrokerName`的值不为空，则该值就是当前发送消息期间上次循环选中的broker，当轮询到的队列的broker和上次失败的broker是同一个时则跳过，以上就是默认情况下rocketmq选择队列的机制，可以将测试代码中的`mqFaultStrategy.setSendLatencyFaultEnable(true);`改为false观察效果。

### broker故障延迟机制

当`sendLatencyFaultEnable`的值为true时，开启broker容错延迟开关，此时`MQFaultStrategy`类的`selectOneMessageQueue()`执行的逻辑是：
```java
try {
    // 获取并自增保存在ThreadLocal中的counter值
    int index = tpInfo.getSendWhichQueue().getAndIncrement();
    for (int i = 0; i < tpInfo.getMessageQueueList().size(); i++) {
        // 用index对队列长度取余，选取一个位置
        int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();
        if (pos < 0)
            pos = 0;
        // 获取该位置的队列
        MessageQueue mq = tpInfo.getMessageQueueList().get(pos);
        // latencyFaultTolerance对象保存了若干broker的延迟时间，这里判断是否存在当前broker的延迟时间，如果不存在则
        // 表示该broker还没有被使用过，isAvailable方法会返回true，否则isAvailable方法会根据broker的延迟信息判断broker
        // 是否可用
        if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) {
            // 根据sendDefaultImpl方法的逻辑，重试的时候lastBrokerName是上次失败的brokerName，非重试的时候lastBrokerName
            // 为null
            // 这里在lastBrokerName为null时直接返回队列，即在非重试的情况下直接使用轮询到的队列
            // 或者如果上次使用的broker和这次选中的队列的broker名称相同，则直接返回，这也是在isAvailable为true的情况下
            // 这里这么判断的效果是，此次轮询到的broker和上次失败的broker是同一个才使用，否则这个的broker延迟时间可能不是
            // 比较低的那个，所以不返回该broker，这个循环选不出来broker，会在下面再选
            if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))
                return mq;
        }
    }

    // 根据latencyFaultTolerance中的延迟信息选一个延迟相对较少的那个
    final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();
    // 获取当前topic在该broker中的写队列数量
    int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);
    // 当notBestBroker为null时，writeQueueNums = -1，否则notBestBroker就是根据latencyFaultTolerance对象中的broker
    // 延迟信息选择的一个延迟相对较少的broker，此时将使用该broker
    if (writeQueueNums > 0) {
        // 轮询选择一个队列并返回
        final MessageQueue mq = tpInfo.selectOneMessageQueue();
        if (notBestBroker != null) {
            mq.setBrokerName(notBestBroker);
            mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);
        }
        return mq;
    } else {
        latencyFaultTolerance.remove(notBestBroker);
    }
} catch (Exception e) {
    log.error("Error occurred when selecting message queue", e);
}

// 选择失败则直接轮询选择一个队列
return tpInfo.selectOneMessageQueue();
```

上面的逻辑是在循环中先用`sendWhichQueue`变量轮询一个队列，循环中用到了`latencyFaultTolerance.isAvailable()`方法，该方法的代码如下：
```java
@Override
public boolean isAvailable(final String name) {
    final FaultItem faultItem = this.faultItemTable.get(name);
    if (faultItem != null) {
        return faultItem.isAvailable();
    }
    return true;
}
```

该方法逻辑并不复杂，值得注意的是当`faultItemTable`中找不到指定broker的`FaultItem`对象，则直接返回true表示该broker可用。对于`faultItemTable`中元素的维护，则是在每次尝试发送消息后，无论成功还是失败，都会调用`updateFaultItem()`方法：
```java
public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) {
    this.mqFaultStrategy.updateFaultItem(brokerName, currentLatency, isolation);
}

public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) {
    if (this.sendLatencyFaultEnable) {
        long duration = computeNotAvailableDuration(isolation ? 30000 : currentLatency);
        this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);
    }
}
```

当发送消息成功时`sendDefaultImpl()`方法会执行`this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);`，而失败时会执行`this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);`。第二个参数为本次发送消息的耗时，第三个参数为当前的broker是否需要进行故障延迟，该参数会影响`computeNotAvailableDuration()`方法计算`duration`时的值，该方法代码如下：
```java
private long computeNotAvailableDuration(final long currentLatency) {
    for (int i = latencyMax.length - 1; i >= 0; i--) {
        if (currentLatency >= latencyMax[i])
            return this.notAvailableDuration[i];
    }

    return 0;
}
```

逻辑很简单，从`latencyMax`数组的末尾开始找不小于参数的位置，并返回该位置的`notAvailableDuration`数组的值，这两个数组值如下：
```java
private long[] latencyMax = {50L, 100L, 550L, 1000L, 2000L, 3000L, 15000L};
private long[] notAvailableDuration = {0L, 0L, 30000L, 60000L, 120000L, 180000L, 600000L};
```

所以在发送失败的情况下，默认`duration`值为600000，如果发送成功，则会根据发送耗时返回对应的`notAvailableDuration`数组的值。

计算`duration`之后，执行的是`LatencyFaultTolerance`类的`updateFaultItem()`方法：
```java
@Override
public void updateFaultItem(final String name, final long currentLatency, final long notAvailableDuration) {
    FaultItem old = this.faultItemTable.get(name);
    if (null == old) {
        final FaultItem faultItem = new FaultItem(name);
        // 保存延迟级别，实际上是发送请求到结束的耗时
        faultItem.setCurrentLatency(currentLatency);
        // 设置延迟时间
        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);

        // 保存结果
        old = this.faultItemTable.putIfAbsent(name, faultItem);
        if (old != null) {
            old.setCurrentLatency(currentLatency);
            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);
        }
    } else {
        old.setCurrentLatency(currentLatency);
        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);
    }
}
```

逻辑很简单，根据传入的参数创建`FaultItem`对象，对于`FaultItem`对象，其代码声明如下：
```java
class FaultItem implements Comparable<FaultItem> {
    private final String name;
    // 耗时时间
    private volatile long currentLatency;
    // broker的可用时间
    private volatile long startTimestamp;

    public FaultItem(final String name) {
        this.name = name;
    }

    @Override
    public int compareTo(final FaultItem other) {
        if (this.isAvailable() != other.isAvailable()) {
            if (this.isAvailable())
                return -1;

            if (other.isAvailable())
                return 1;
        }

        if (this.currentLatency < other.currentLatency)
            return -1;
        else if (this.currentLatency > other.currentLatency) {
            return 1;
        }

        if (this.startTimestamp < other.startTimestamp)
            return -1;
        else if (this.startTimestamp > other.startTimestamp) {
            return 1;
        }

        return 0;
    }

    public boolean isAvailable() {
        return (System.currentTimeMillis() - startTimestamp) >= 0;
    }

    // 略
}
```

`FaultItem`类实现了`Comparable`接口，`currentLatency`属性的优先级大于`startTimestamp`。`FaultItem`类的`isAvailable()`方法能够判断`FaultItem`对象是否到了可用时间。

每次发送消息都会调用`updateFaultItem()`方法，使得每次发送消息使用的broker的延迟信息都能够保存到`LatencyFaultTolerance`类中，为之后选择相对较优的队列提供依据。现在来看看在开启broker故障延迟机制的情况下`selectOneMessageQueue()`方法的执行逻辑。第一次发送消息时调用该方法时`LatencyFaultTolerance`对象中还没有broker对应的`FaultItem`对象，首先执行的逻辑时根据`sendWhichQueue`轮询一个队列，此时`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`结果将为true，并且`lastBrokerName`为null，则被轮询到的队列会被返回使用，假设此时发送失败，则`DefaultMQProducerImpl`类的`sendDefaultImpl()`方法会执行重试，`lastBrokerName`就是刚刚选中的broker的值，假设该值为broker1，此时`LatencyFaultTolerance`对象会包含broker1的`FaultItem`对象，当再次调用`selectOneMessageQueue()`方法选择队列时，假设下一个轮询到的队列还是broker1中的队列，由于broker1的延迟时间还没到，所以`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`返回false，此时再次进行轮询。当轮询到broker2的queue0时由于broker2还未被使用过，所以`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`返回true，但是此时`lastBrokerName`等于broker1，`mq.getBrokerName().equals(lastBrokerName)`为false，所以选择失败，这样循环结束后，轮询的位置会到第一次选择的队列的前一个队列。这样实现的效果是循环中选出的队列，要么broker可用的情况下`lastBrokerName`为空，即当前发送消息非重试，要么选中的队列的broker可用并且名字和`lastBrokerName`相等。当循环无法选出队列时，表明`lastBrokerName`对应的broker一定不可用，则会执行下面的逻辑：
```java
// 根据latencyFaultTolerance中的延迟信息选一个延迟相对较少的那个
final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();
// 获取当前topic在该broker中的写队列数量
int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);
// 当notBestBroker为null时，writeQueueNums = -1，否则notBestBroker就是根据latencyFaultTolerance对象中的broker
// 延迟信息选择的一个延迟相对较少的broker，此时将使用该broker
if (writeQueueNums > 0) {
    // 轮询选择一个队列并返回
    final MessageQueue mq = tpInfo.selectOneMessageQueue();
    if (notBestBroker != null) {
        mq.setBrokerName(notBestBroker);
        mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);
    }
    return mq;
} else {
    latencyFaultTolerance.remove(notBestBroker);
}
```

上面的逻辑是，从`pickOneAtLeast()`方法中选择一个broker，之后用该broker作为选中队列的broker返回，`pickOneAtLeast()`方法代码如下：
```java
@Override
public String pickOneAtLeast() {
    final Enumeration<FaultItem> elements = this.faultItemTable.elements();
    List<FaultItem> tmpList = new LinkedList<FaultItem>();
    while (elements.hasMoreElements()) {
        final FaultItem faultItem = elements.nextElement();
        tmpList.add(faultItem);
    }

    if (!tmpList.isEmpty()) {
        // 打乱列表
        Collections.shuffle(tmpList);

        // 以FaultItem对象的currentLatency和startTimestamp属性为依据进行排序，currentLatency优先级更高
        // 这打乱再排序是个啥意思
        Collections.sort(tmpList);

        final int half = tmpList.size() / 2;
        if (half <= 0) {
            return tmpList.get(0).getName();
        } else {
            // 返回前50%的FaultItem中的一个
            final int i = this.whichItemWorst.getAndIncrement() % half;
            return tmpList.get(i).getName();
        }
    }

    return null;
}
```

逻辑很简单，根据`faultItemTable`属性保存的所有broker的延迟记录，对broker进行排序，并在前50%中选一个返回，这就实现了在`selectOneMessageQueue()`的循环没有选择到合适队列的情况下，选择一个延迟相对较小的broker使用。但是需要注意的是，由于第一个发送消息时`LatencyFaultTolerance`的`faultItemTable`属性中没有数据，假设第一次发送选中的时broker1的队列，如果发送失败，`faultItemTable`属性中只有broker1的延迟信息，此时重试发送，由于`lastBrokerName`等于broker1，导致`selectOneMessageQueue()`的循环选中broker2的队列时，`if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))`条件不满足，无法返回，而当再次轮询到broker1的队列时，由于broker1的`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`条件不满足，也无法返回，使得循环结束。在循环结束后，执行循环之外的逻辑时，由于`faultItemTable`属性中只有broker1的延迟信息，所以最终返回的还是broker1的队列，这就是最开始的测试代码在设置`sendLatencyFaultEnable`为true的情况下，第0次循环的输出中选中的broker始终是第一次选中的那个的原因。`MQFaultStrategy`类这么实现的原因其实是考虑在broker能够发送成功的情况下，选择一个好一点的broker，这个在后面会解释。

继续上面的场景，当再次重新开始发送消息，由于broker1的延迟时间还没到，而`lastBrokerName`属性为null，所以轮询到的broker2的队列可以使用，这就是测试代码中第1次（实际上是第2次，从0开始计数）发送消息能够使用到broker2的原因，假设此时broker2也发送失败了，这个时候重试发送消息，`faultItemTable`属性中同时拥有broker1和broker2的延迟信息，而`selectOneMessageQueue()`的循环中由于broker1和broker2的延迟时间都还没到，所以无法选出一个队列，此时执行循环外的逻辑，根据broker1和broker2的延迟时间选一个较好的broker返回，这就是测试代码中在使用了一次broker2后，一直使用broker1的原因。

那么在broker1和broker2都能使用的情况下，测试代码的输出又如何解释呢？为什么`selectOneMessageQueue`方法的循环中要加上`mq.getBrokerName().equals(lastBrokerName)`的条件，导致当第一次发送消息失败后，后续的重试过程选择的broker始终是同一个呢？下面来分析这两个问题，当第一次发送消息选中broker1的队列后，发送成功，调用`updateFaultItem()`方法将broker1的延迟信息保存到`faultItemTable`属性。当再次开始发送消息，假设此时刚好轮询到了broker2的队列，由于`faultItemTable`属性中还没有broker2的延迟信息，并且此时`lastBrokerName`为null，所以broker2的queue0能够返回。假设发送成功，`updateFaultItem()`方法将broker2的延迟信息保存到`faultItemTable`属性。当再次开始发送消息，轮询的还是broker2的队列，假设由于broker1和broker2发送成功但是发送延迟很高，导致两个broker的`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`条件都为fasle，此时会执行循环外的代码逻辑，从broker1和broker2中选一个相对较好的broker，这就是测试代码的输出的原因。反之如果broker1和broker2延迟时间较低使得`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`为true，那么`selectOneMessageQueue`方法执行的将是正常的轮询逻辑。

当然broker随时有可能挂掉，假设选中了broker1后发送失败，此时重试发送消息执行`selectOneMessageQueue`方法时，轮询到的broker1的队列都因为`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`为false而无法使用，当轮询到broker2的队列，即使`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`为true，由于`if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))`为false，也无法使用。再扩充下场景，假设还存在broker3和broker4，即使这两个broker都可用，也会和broker2一样在`selectOneMessageQueue`方法的循环中无法返回。这样会执行循环外的逻辑，从broker1、broker2、broker3、broker4中选一个相对较好的broker使用，这就是`mq.getBrokerName().equals(lastBrokerName)`条件存在的原因，当`lastBrokerName`不为null的情况下，如果`lastBrokerName`对应的broker在循环期间一直都不可用，会使得`selectOneMessageQueue`方法执行循环外的逻辑，根据`faultItemTable`属性从多个broker中选一个较好的使用。不过`mq.getBrokerName().equals(lastBrokerName)`条件也导致了前面说的当第一次发送消息失败后，后续的重试过程选择的broker始终是同一个的结果，这个结果的直接原因是`faultItemTable`属性的broker延迟信息不全，第一次发送消息时只有一个broker的延迟信息，不过这个问题会在之后发送消息使得`faultItemTable`属性的数据越来越多最后所有broker的延迟信息都在`faultItemTable`属性中而解决。以上是生产者选择队列的过程。
