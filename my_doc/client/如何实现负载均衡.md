负载均衡分别作用域生产者和消费者，下面对这两种情况分别分析。

## 生产者
对于生产者中的负载均衡，是为了生产者能够将消息平均的发往多个broker中的队列，这里假设有如下场景：

有个由两个broker节点组成的集群，有topic1，默认在每个broker上创建4个队列，分别是：master-a（q0,q1,q2,q3）、master-b（q0,q1,q2,q3），上一次发送消息到master-a的q0队列，根据rocketmq的生产者实现，当再次发送消息时，会轮询下一个队列也就是master-a的q1队列进行消息发送，但是如果master-a宕机了，如果继续发送topic1消息并且继续轮询队列的话，rocketmq如果避免再次发送到master-a？

以上问题引出了rocketmq发送消息时如何选择队列的一些机制，选择队列有两种方式，通过`sendLatencyFaultEnable`的值来控制，默认值为false，不启动broker故障延迟机制，值为true时启用broker故障延迟机制。

根据笔记[如何实现消息发送](如何实现消息发送.md)可知，发送消息过程中调用的`DefaultMQProducerImpl`类的`sendDefaultImpl()`方法在获取到路由信息后，需要选择一个队列发送消息，选择过程在`DefaultMQProducerImpl`类的`selectOneMessageQueue()`方法，代码如下：
```java
public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {
    return this.mqFaultStrategy.selectOneMessageQueue(tpInfo, lastBrokerName);
}
```

真正调用的是`MQFaultStrategy`类的`selectOneMessageQueue()`方法，关于该方法，可以先看下面测试代码的输出，对发送消息时的故障转移过程有个认识：
```java
public class MQFaultStrategyTest {
    public static void main(String[] args) {
        // 以该参数表示每次发送是成功还是失败，来分别观察MQFaultStrategy类在这两种情况下的不同
        boolean fail = false;
        System.out.println("假设每次发送" + (fail ? "失败" : "成功"));

        final MQFaultStrategy mqFaultStrategy = new MQFaultStrategy();
        mqFaultStrategy.setSendLatencyFaultEnable(true);

        final TopicPublishInfo topicPublishInfo = new TopicPublishInfo();
        topicPublishInfo.setHaveTopicRouterInfo(true);
        TopicRouteData topicRouteData = new TopicRouteData();
        topicRouteData.setQueueDatas(new ArrayList<>());
        topicPublishInfo.setMessageQueueList(new ArrayList<>());
        topicPublishInfo.setTopicRouteData(topicRouteData);

        Map<String, Integer> latencyMap = new HashMap<>();

        addBroker(topicPublishInfo, latencyMap, 30000, "topic-a", "broker1", 4);
        addBroker(topicPublishInfo, latencyMap, 50000, "topic-a", "broker2", 4);

        for (int i = 0; i < 10; i++) {
            System.out.println(String.format("第%d次开始循环", i));
            String lastBrokerName = null;
            for (int j = 0; j < 2; j++) {
                final MessageQueue messageQueue = mqFaultStrategy.selectOneMessageQueue(topicPublishInfo, lastBrokerName);
                lastBrokerName = messageQueue.getBrokerName();
                System.out.println(String.format("第%d次发送使用broker: %s", j, lastBrokerName));

                try {
                    sendMessage(messageQueue, fail);
                    mqFaultStrategy.updateFaultItem(lastBrokerName, latencyMap.get(lastBrokerName), false);
                } catch (Exception e) {
                    mqFaultStrategy.updateFaultItem(lastBrokerName, latencyMap.get(lastBrokerName), true);
                }
            }
        }
    }

    private static void sendMessage(MessageQueue messageQueue, boolean fail) {
        if (fail) {
            throw new RuntimeException("发送失败");
        }
    }

    private static void addBroker(TopicPublishInfo topicPublishInfo, Map<String, Integer> latencyMap, int latency, String topic, String brokerName, int num) {
        QueueData queueData = new QueueData();
        queueData.setBrokerName(brokerName);
        queueData.setWriteQueueNums(num);
        queueData.setReadQueueNums(num);
        topicPublishInfo.getTopicRouteData().getQueueDatas().add(queueData);

        latencyMap.put(brokerName, latency);

        for (int i = 0; i < num; i++) {
            MessageQueue messageQueue = new MessageQueue();
            messageQueue.setBrokerName(brokerName);
            messageQueue.setQueueId(i);
            messageQueue.setTopic(topic);
            topicPublishInfo.getMessageQueueList().add(messageQueue);

        }
    }
}

/*
测试输出1：
假设每次发送成功
第0次开始循环
第0次发送使用broker: broker1
第1次开始循环
第0次发送使用broker: broker2
第2次开始循环
第0次发送使用broker: broker1
第3次开始循环
第0次发送使用broker: broker1
第4次开始循环
第0次发送使用broker: broker1
第5次开始循环
第0次发送使用broker: broker1
第6次开始循环
第0次发送使用broker: broker1
第7次开始循环
第0次发送使用broker: broker1
第8次开始循环
第0次发送使用broker: broker1
第9次开始循环
第0次发送使用broker: broker1

测试输出2：
假设每次发送失败
第0次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第1次开始循环
第0次发送使用broker: broker2
第1次发送使用broker: broker1
第2次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第3次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第4次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第5次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第6次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第7次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第8次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
第9次开始循环
第0次发送使用broker: broker1
第1次发送使用broker: broker1
*/
```

上面的代码模拟了10次发送消息的过程，在假设每次发送成功的情况下，可以看到输出，第一次循环选择了broker1，第二次broker选择了broker2，但之后的发送都选择了broker1，这是因为上面的代码设置了broker1的延迟时间为30000（这里的延迟时间为了简单起见，即表示了发送成功情况下的延迟，也表示了发送失败情况下的延迟），broker2的延迟时间为50000，证明`MQFaultStrategy`类根据延迟时间维护了优先级，broker1优先于broker2。

在假设每次发送失败的情况下，可以看到输出，，第一次循环选择了broker1，第二次broker选择了broker2，但第二次循环的重试选择的是broker1，并且之后的循环选择的都是broker1。

下面开始分析`MQFaultStrategy`类的实现，并解释上面输出的原理。

测试代码模拟了发送消息的代码，发送消息的逻辑在一个循环中，以达到失败重试的目的。每次发送消息时，都会调用`MQFaultStrategy`类的`selectOneMessageQueue()`方法选择一个队列进行发送。假设场景如测试代码中所示：topic-a在broker1中有4个写队列，在broker2中有4个写队列，向broker1发送消息时假设无论成功和失败，延迟都是30000，而broker2延迟时50000。

### 默认机制
在默认情况下，即`sendLatencyFaultEnable`的值为false时，不开启broker容错延迟开关，此时`MQFaultStrategy`类的`selectOneMessageQueue()`执行的代码是：
```java
public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {
    if (this.sendLatencyFaultEnable) {
      // 略
    }

    return tpInfo.selectOneMessageQueue(lastBrokerName);
}
```

不开启broker容错延迟时直接执行`tpInfo.selectOneMessageQueue(lastBrokerName)`选择队列，该方法代码如下：
```java
public MessageQueue selectOneMessageQueue(final String lastBrokerName) {
    if (lastBrokerName == null) {
        return selectOneMessageQueue();
    } else {
        // 获取保存在ThreadLocal中的counter值并递增，以便于轮询选择队列
        int index = this.sendWhichQueue.getAndIncrement();
        for (int i = 0; i < this.messageQueueList.size(); i++) {
            int pos = Math.abs(index++) % this.messageQueueList.size();
            if (pos < 0)
                pos = 0;
            MessageQueue mq = this.messageQueueList.get(pos);
            // 如果选择的队列的broker和上次失败的broker是同一个，则跳过，否则返回
            if (!mq.getBrokerName().equals(lastBrokerName)) {
                return mq;
            }
        }
        // 如果没有选中队列则直接使用sendWhichQueue变量轮询一个队列返回
        return selectOneMessageQueue();
    }
}

public MessageQueue selectOneMessageQueue() {
    int index = this.sendWhichQueue.getAndIncrement();
    int pos = Math.abs(index) % this.messageQueueList.size();
    if (pos < 0)
        pos = 0;
    return this.messageQueueList.get(pos);
}
```

上面的逻辑很简单，用一个保存在`ThreadLocal`中的counter值实现轮询队列的效果，如果`lastBrokerName`的值不为空，则该值就是当前发送消息期间上次循环选中的broker，当轮询到的队列的broker和上次失败的broker是同一个时则跳过，以上就是默认情况下rocketmq选择队列的机制，可以将测试代码中的`mqFaultStrategy.setSendLatencyFaultEnable(true);`改为false观察效果。

### broker故障延迟机制

当`sendLatencyFaultEnable`的值为true时，开启broker容错延迟开关，此时`MQFaultStrategy`类的`selectOneMessageQueue()`执行的逻辑是：
```java
try {
    // 获取并自增保存在ThreadLocal中的counter值
    int index = tpInfo.getSendWhichQueue().getAndIncrement();
    for (int i = 0; i < tpInfo.getMessageQueueList().size(); i++) {
        // 用index对队列长度取余，选取一个位置
        int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();
        if (pos < 0)
            pos = 0;
        // 获取该位置的队列
        MessageQueue mq = tpInfo.getMessageQueueList().get(pos);
        // latencyFaultTolerance对象保存了若干broker的延迟时间，这里判断是否存在当前broker的延迟时间，如果不存在则
        // 表示该broker还没有被使用过，isAvailable方法会返回true，否则isAvailable方法会根据broker的延迟信息判断broker
        // 是否可用
        if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) {
            // 根据sendDefaultImpl方法的逻辑，重试的时候lastBrokerName是上次失败的brokerName，非重试的时候lastBrokerName
            // 为null
            // 这里在lastBrokerName为null时直接返回队列，即在非重试的情况下直接使用轮询到的队列
            // 或者如果上次使用的broker和这次选中的队列的broker名称相同，则直接返回，这也是在isAvailable为true的情况下
            // 这里这么判断的效果是，此次轮询到的broker和上次失败的broker是同一个才使用，否则这个的broker延迟时间可能不是
            // 比较低的那个，所以不返回该broker，这个循环选不出来broker，会在下面再选
            if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))
                return mq;
        }
    }

    // 根据latencyFaultTolerance中的延迟信息选一个延迟相对较少的那个
    final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();
    // 获取当前topic在该broker中的写队列数量
    int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);
    // 当notBestBroker为null时，writeQueueNums = -1，否则notBestBroker就是根据latencyFaultTolerance对象中的broker
    // 延迟信息选择的一个延迟相对较少的broker，此时将使用该broker
    if (writeQueueNums > 0) {
        // 轮询选择一个队列并返回
        final MessageQueue mq = tpInfo.selectOneMessageQueue();
        if (notBestBroker != null) {
            mq.setBrokerName(notBestBroker);
            mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);
        }
        return mq;
    } else {
        latencyFaultTolerance.remove(notBestBroker);
    }
} catch (Exception e) {
    log.error("Error occurred when selecting message queue", e);
}

// 选择失败则直接轮询选择一个队列
return tpInfo.selectOneMessageQueue();
```

上面的逻辑是在循环中先用`sendWhichQueue`变量轮询一个队列，循环中用到了`latencyFaultTolerance.isAvailable()`方法，该方法的代码如下：
```java
@Override
public boolean isAvailable(final String name) {
    final FaultItem faultItem = this.faultItemTable.get(name);
    if (faultItem != null) {
        return faultItem.isAvailable();
    }
    return true;
}
```

该方法逻辑并不复杂，值得注意的是当`faultItemTable`中找不到指定broker的`FaultItem`对象，则直接返回true表示该broker可用。对于`faultItemTable`中元素的维护，则是在每次尝试发送消息后，无论成功还是失败，都会调用`updateFaultItem()`方法：
```java
public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) {
    this.mqFaultStrategy.updateFaultItem(brokerName, currentLatency, isolation);
}

public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) {
    if (this.sendLatencyFaultEnable) {
        long duration = computeNotAvailableDuration(isolation ? 30000 : currentLatency);
        this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);
    }
}
```

当发送消息成功时`sendDefaultImpl()`方法会执行`this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);`，而失败时会执行`this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);`。第二个参数为本次发送消息的耗时，第三个参数为当前的broker是否需要进行故障延迟，该参数会影响`computeNotAvailableDuration()`方法计算`duration`时的值，该方法代码如下：
```java
private long computeNotAvailableDuration(final long currentLatency) {
    for (int i = latencyMax.length - 1; i >= 0; i--) {
        if (currentLatency >= latencyMax[i])
            return this.notAvailableDuration[i];
    }

    return 0;
}
```

逻辑很简单，从`latencyMax`数组的末尾开始找不小于参数的位置，并返回该位置的`notAvailableDuration`数组的值，这两个数组值如下：
```java
private long[] latencyMax = {50L, 100L, 550L, 1000L, 2000L, 3000L, 15000L};
private long[] notAvailableDuration = {0L, 0L, 30000L, 60000L, 120000L, 180000L, 600000L};
```

所以在发送失败的情况下，默认`duration`值为600000，如果发送成功，则会根据发送耗时返回对应的`notAvailableDuration`数组的值。

计算`duration`之后，执行的是`LatencyFaultTolerance`类的`updateFaultItem()`方法：
```java
@Override
public void updateFaultItem(final String name, final long currentLatency, final long notAvailableDuration) {
    FaultItem old = this.faultItemTable.get(name);
    if (null == old) {
        final FaultItem faultItem = new FaultItem(name);
        // 保存延迟级别，实际上是发送请求到结束的耗时
        faultItem.setCurrentLatency(currentLatency);
        // 设置延迟时间
        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);

        // 保存结果
        old = this.faultItemTable.putIfAbsent(name, faultItem);
        if (old != null) {
            old.setCurrentLatency(currentLatency);
            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);
        }
    } else {
        old.setCurrentLatency(currentLatency);
        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);
    }
}
```

逻辑很简单，根据传入的参数创建`FaultItem`对象，对于`FaultItem`对象，其代码声明如下：
```java
class FaultItem implements Comparable<FaultItem> {
    private final String name;
    // 耗时时间
    private volatile long currentLatency;
    // broker的可用时间
    private volatile long startTimestamp;

    public FaultItem(final String name) {
        this.name = name;
    }

    @Override
    public int compareTo(final FaultItem other) {
        if (this.isAvailable() != other.isAvailable()) {
            if (this.isAvailable())
                return -1;

            if (other.isAvailable())
                return 1;
        }

        if (this.currentLatency < other.currentLatency)
            return -1;
        else if (this.currentLatency > other.currentLatency) {
            return 1;
        }

        if (this.startTimestamp < other.startTimestamp)
            return -1;
        else if (this.startTimestamp > other.startTimestamp) {
            return 1;
        }

        return 0;
    }

    public boolean isAvailable() {
        return (System.currentTimeMillis() - startTimestamp) >= 0;
    }

    // 略
}
```

`FaultItem`类实现了`Comparable`接口，`currentLatency`属性的优先级大于`startTimestamp`。`FaultItem`类的`isAvailable()`方法能够判断`FaultItem`对象是否到了可用时间。

每次发送消息都会调用`updateFaultItem()`方法，使得每次发送消息使用的broker的延迟信息都能够保存到`LatencyFaultTolerance`类中，为之后选择相对较优的队列提供依据。现在来看看在开启broker故障延迟机制的情况下`selectOneMessageQueue()`方法的执行逻辑。第一次发送消息时调用该方法时`LatencyFaultTolerance`对象中还没有broker对应的`FaultItem`对象，首先执行的逻辑时根据`sendWhichQueue`轮询一个队列，此时`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`结果将为true，并且`lastBrokerName`为null，则被轮询到的队列会被返回使用，假设此时发送失败，则`DefaultMQProducerImpl`类的`sendDefaultImpl()`方法会执行重试，`lastBrokerName`就是刚刚选中的broker的值，假设该值为broker1，此时`LatencyFaultTolerance`对象会包含broker1的`FaultItem`对象，当再次调用`selectOneMessageQueue()`方法选择队列时，假设下一个轮询到的队列还是broker1中的队列，由于broker1的延迟时间还没到，所以`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`返回false，此时再次进行轮询。当轮询到broker2的queue0时由于broker2还未被使用过，所以`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`返回true，但是此时`lastBrokerName`等于broker1，`mq.getBrokerName().equals(lastBrokerName)`为false，所以选择失败，这样循环结束后，轮询的位置会到第一次选择的队列的前一个队列。这样实现的效果是循环中选出的队列，要么broker可用的情况下`lastBrokerName`为空，即当前发送消息非重试，要么选中的队列的broker可用并且名字和`lastBrokerName`相等。当循环无法选出队列时，表明`lastBrokerName`对应的broker一定不可用，则会执行下面的逻辑：
```java
// 根据latencyFaultTolerance中的延迟信息选一个延迟相对较少的那个
final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();
// 获取当前topic在该broker中的写队列数量
int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);
// 当notBestBroker为null时，writeQueueNums = -1，否则notBestBroker就是根据latencyFaultTolerance对象中的broker
// 延迟信息选择的一个延迟相对较少的broker，此时将使用该broker
if (writeQueueNums > 0) {
    // 轮询选择一个队列并返回
    final MessageQueue mq = tpInfo.selectOneMessageQueue();
    if (notBestBroker != null) {
        mq.setBrokerName(notBestBroker);
        mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);
    }
    return mq;
} else {
    latencyFaultTolerance.remove(notBestBroker);
}
```

上面的逻辑是，从`pickOneAtLeast()`方法中选择一个broker，之后用该broker作为选中队列的broker返回，`pickOneAtLeast()`方法代码如下：
```java
@Override
public String pickOneAtLeast() {
    final Enumeration<FaultItem> elements = this.faultItemTable.elements();
    List<FaultItem> tmpList = new LinkedList<FaultItem>();
    while (elements.hasMoreElements()) {
        final FaultItem faultItem = elements.nextElement();
        tmpList.add(faultItem);
    }

    if (!tmpList.isEmpty()) {
        // 打乱列表
        Collections.shuffle(tmpList);

        // 以FaultItem对象的currentLatency和startTimestamp属性为依据进行排序，currentLatency优先级更高
        // 这打乱再排序是个啥意思
        Collections.sort(tmpList);

        final int half = tmpList.size() / 2;
        if (half <= 0) {
            return tmpList.get(0).getName();
        } else {
            // 返回前50%的FaultItem中的一个
            final int i = this.whichItemWorst.getAndIncrement() % half;
            return tmpList.get(i).getName();
        }
    }

    return null;
}
```

逻辑很简单，根据`faultItemTable`属性保存的所有broker的延迟记录，对broker进行排序，并在前50%中选一个返回，这就实现了在`selectOneMessageQueue()`的循环没有选择到合适队列的情况下，选择一个延迟相对较小的broker使用。但是需要注意的是，由于第一个发送消息时`LatencyFaultTolerance`的`faultItemTable`属性中没有数据，假设第一次发送选中的时broker1的队列，如果发送失败，`faultItemTable`属性中只有broker1的延迟信息，此时重试发送，由于`lastBrokerName`等于broker1，导致`selectOneMessageQueue()`的循环选中broker2的队列时，`if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))`条件不满足，无法返回，而当再次轮询到broker1的队列时，由于broker1的`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`条件不满足，也无法返回，使得循环结束。在循环结束后，执行循环之外的逻辑时，由于`faultItemTable`属性中只有broker1的延迟信息，所以最终返回的还是broker1的队列，这就是最开始的测试代码在设置`sendLatencyFaultEnable`为true的情况下，第0次循环的输出中选中的broker始终是第一次选中的那个的原因。`MQFaultStrategy`类这么实现的原因其实是考虑在broker能够发送成功的情况下，选择一个好一点的broker，这个在后面会解释。

继续上面的场景，当再次重新开始发送消息，由于broker1的延迟时间还没到，而`lastBrokerName`属性为null，所以轮询到的broker2的队列可以使用，这就是测试代码中第1次（实际上是第2次，从0开始计数）发送消息能够使用到broker2的原因，假设此时broker2也发送失败了，这个时候重试发送消息，`faultItemTable`属性中同时拥有broker1和broker2的延迟信息，而`selectOneMessageQueue()`的循环中由于broker1和broker2的延迟时间都还没到，所以无法选出一个队列，此时执行循环外的逻辑，根据broker1和broker2的延迟时间选一个较好的broker返回，这就是测试代码中在使用了一次broker2后，一直使用broker1的原因。

那么在broker1和broker2都能使用的情况下，测试代码的输出又如何解释呢？为什么`selectOneMessageQueue`方法的循环中要加上`mq.getBrokerName().equals(lastBrokerName)`的条件，导致当第一次发送消息失败后，后续的重试过程选择的broker始终是同一个呢？下面来分析这两个问题，当第一次发送消息选中broker1的队列后，发送成功，调用`updateFaultItem()`方法将broker1的延迟信息保存到`faultItemTable`属性。当再次开始发送消息，假设此时刚好轮询到了broker2的队列，由于`faultItemTable`属性中还没有broker2的延迟信息，并且此时`lastBrokerName`为null，所以broker2的queue0能够返回。假设发送成功，`updateFaultItem()`方法将broker2的延迟信息保存到`faultItemTable`属性。当再次开始发送消息，轮询的还是broker2的队列，假设由于broker1和broker2发送成功但是发送延迟很高，导致两个broker的`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`条件都为fasle，此时会执行循环外的代码逻辑，从broker1和broker2中选一个相对较好的broker，这就是测试代码的输出的原因。反之如果broker1和broker2延迟时间较低使得`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`为true，那么`selectOneMessageQueue`方法执行的将是正常的轮询逻辑。

当然broker随时有可能挂掉，假设选中了broker1后发送失败，此时重试发送消息执行`selectOneMessageQueue`方法时，轮询到的broker1的队列都因为`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`为false而无法使用，当轮询到broker2的队列，即使`if (latencyFaultTolerance.isAvailable(mq.getBrokerName()))`为true，由于`if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))`为false，也无法使用。再扩充下场景，假设还存在broker3和broker4，即使这两个broker都可用，也会和broker2一样在`selectOneMessageQueue`方法的循环中无法返回。这样会执行循环外的逻辑，从broker1、broker2、broker3、broker4中选一个相对较好的broker使用，这就是`mq.getBrokerName().equals(lastBrokerName)`条件存在的原因，当`lastBrokerName`不为null的情况下，如果`lastBrokerName`对应的broker在循环期间一直都不可用，会使得`selectOneMessageQueue`方法执行循环外的逻辑，根据`faultItemTable`属性从多个broker中选一个较好的使用。不过`mq.getBrokerName().equals(lastBrokerName)`条件也导致了前面说的当第一次发送消息失败后，后续的重试过程选择的broker始终是同一个的结果，这个结果的直接原因是`faultItemTable`属性的broker延迟信息不全，第一次发送消息时只有一个broker的延迟信息，不过这个问题会在之后发送消息使得`faultItemTable`属性的数据越来越多最后所有broker的延迟信息都在`faultItemTable`属性中而解决。以上是生产者选择队列的过程。


## 消费者
在rocketmq中，Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。在两种基于拉模式的消费方式（Push/Pull）中，均需要Consumer端在知道从Broker端的哪一个消息队列—队列中去获取消息，Consumer端的负载均衡就是负责实现这一点的，即Broker端中多个队列（在Consumer端就是MessageQueue对象）分配给同一个consumerGroup中的哪些Consumer消费。

Consumer负载均衡的关键点：
- Consumer端的心跳包发送：在Consumer启动后，它就会通过定时任务不断地向RocketMQ集群中的所有Broker实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）。Broker端在收到Consumer的心跳消息后，会将它维护在ConsumerManager的本地缓存变量`consumerTable`，同时将封装后的客户端网络通道信息（Netty的`Channel`）保存在本地缓存变量`channelInfoTable`中，为之后做Consumer端的负载均衡提供可以依据的元数据信息，也使得Broker能够主动要求Consumer端开始负载均衡。
- Consumer端实现负载均衡实现类`RebalanceImpl`：在Consumer实例的启动流程中的启动`MQClientInstance`实例，会完成负载均衡服务线程`RebalanceService`的启动（每隔20s执行一次）。`RebalanceService`线程的`run()`方法最终调用的是`RebalanceImpl`类的`rebalanceByTopic()`方法，该方法是实现Consumer端负载均衡的核心。消息消费队列在同一消费组不同消费者之间的负载均衡，目的是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。

下面从源码中分析消费者的负载均衡，这里只分析push模式下的消费者的实现，pull模式的消费者通常不会使用，而且在了解push模式的实现后，pull模式也不难理解。

首先看看broker是如何知道一个消费者组内有哪些消费者和消费者组内的消费者是如何知道彼此的存在的，下面的分析假设已经看过笔记[如何实现消息消费](如何实现消息消费.md)了。

消费者的`subscribe()`方法用于设置订阅配置，一个普通的push模式的消费者如下：
```java
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name_4");
consumer.setNamesrvAddr("127.0.0.1:9876");
consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);

consumer.subscribe("TopicTest", "*");

consumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                    ConsumeConcurrentlyContext context) {
        if (CollectionUtils.isNotEmpty(msgs)) {
            final List<String> msgBodies = msgs.stream().map((item) -> new String(item.getBody())).collect(Collectors.toList());

            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgBodies);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }

        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
});

consumer.start();
System.out.printf("Consumer Started.%n");

```

`DefaultMQPushConsumer`类的`subscribe()`方法最终会调用`DefaultMQPushConsumerImpl`类的`subscribe()`方法，代码如下：
```java
// 订阅主题，subExpression参数为订阅的消息标签，如'*'、'tagA'等
public void subscribe(String topic, String subExpression) throws MQClientException {
    try {
        // 根据消费者的参数创建SubscriptionData对象，该对象保存了消费者订阅的topic和该topic的标签配置，即
        // 一个SubscriptionData对象表示消费者的某个topic订阅
        SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
            topic, subExpression);
        // 保存订阅配置
        this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
        if (this.mQClientFactory != null) {
            // 向broker发送心跳，心跳中会包含消费者的组名和消费配置、订阅配置
            this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}
```

消费者的订阅配置最终被保存到了`RebalanceImpl`类的`subscriptionInner`属性，`DefaultMQPushConsumer`类的`start()`方法会向broker发送心跳：
```java
public synchronized void start() throws MQClientException {
    // 略...

    // 向所有broker发送心跳
    this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();

    // 略...
}
```

`MQClientInstance`类的`sendHeartbeatToAllBrokerWithLock()`方法代码：
```java
public void sendHeartbeatToAllBrokerWithLock() {
    if (this.lockHeartbeat.tryLock()) {
        try {
            // 向所有broker发送心跳
            this.sendHeartbeatToAllBroker();
            // 如果以class作为消息过滤机制，则发送类定义给filterServer，通常不会使用class进行消息过滤
            // 可以在https://blog.csdn.net/prestigeding/article/details/79287382了解一些class
            // 过滤的实现原理
            this.uploadFilterClassSource();
        } catch (final Exception e) {
            log.error("sendHeartbeatToAllBroker exception", e);
        } finally {
            this.lockHeartbeat.unlock();
        }
    } else {
        log.warn("lock heartBeat, but failed.");
    }
}

// 上面调用的sendHeartbeatToAllBroker方法
private void sendHeartbeatToAllBroker() {
    // 创建HeartbeatData对象，HeartbeatData包含了clientId、consumerTable和producerTable属性的值
    // 即对于消费者，HeartbeatData对象保存了当前MQClientInstance对象内（即一个进程内）的所有的消费者组
    // 名称和消费配置（包括订阅配置）
    // 对于生产者，HeartbeatData对象保存了当前MQClientInstance对象内（即一个进程内）的所有生产者组名称
    final HeartbeatData heartbeatData = this.prepareHeartbeatData();
    final boolean producerEmpty = heartbeatData.getProducerDataSet().isEmpty();
    final boolean consumerEmpty = heartbeatData.getConsumerDataSet().isEmpty();
    // 如果没有数据则没有必要发送心跳
    if (producerEmpty && consumerEmpty) {
        log.warn("sending heartbeat, but no consumer and no producer");
        return;
    }

    if (!this.brokerAddrTable.isEmpty()) {
        // 递增心跳次数
        long times = this.sendHeartbeatTimesTotal.getAndIncrement();
        Iterator<Entry<String, HashMap<Long, String>>> it = this.brokerAddrTable.entrySet().iterator();
        while (it.hasNext()) {
            Entry<String, HashMap<Long, String>> entry = it.next();
            String brokerName = entry.getKey();
            // 这里的key为brokerId，value为brokerAddr
            HashMap<Long, String> oneTable = entry.getValue();
            if (oneTable != null) {
                for (Map.Entry<Long, String> entry1 : oneTable.entrySet()) {
                    Long id = entry1.getKey();
                    String addr = entry1.getValue();
                    if (addr != null) {
                        /*
                        rocketmq中的生产者和消费者都需要发送心跳

                        生产者：
                        生产者与namesrv集群中的其中一个节点（随机选择）建立长连接，并定期从namesrv获取topic路由信息，向提供
                        topic服务的master broker建立长连接，且定时向master broker发送心跳

                        消费者：
                        消费者与namesrv集群中的其中一个节点（随机选择）建立长连接，并定期从namesrv获取topic路由信息，向提供
                        topic服务的master broker、slave broker建立长连接，且定时向master broker、slave broker发送心跳

                        当当前MQClientInstance对象的consumerTable为空时，则说明当前MQClientInstance对象是DefaultMQProducerImpl
                        对象创建的，服务于生产者，此时只需要发送心跳给master broker，所以这里跳过了非master的broker
                        */
                        if (consumerEmpty) {
                            if (id != MixAll.MASTER_ID)
                                continue;
                        }

                        try {
                            // 向指定地址的broker发送心跳
                            int version = this.mQClientAPIImpl.sendHearbeat(addr, heartbeatData, 3000);
                            if (!this.brokerVersionTable.containsKey(brokerName)) {
                                this.brokerVersionTable.put(brokerName, new HashMap<String, Integer>(4));
                            }
                            this.brokerVersionTable.get(brokerName).put(addr, version);
                            if (times % 20 == 0) {
                                log.info("send heart beat to broker[{} {} {}] success", brokerName, id, addr);
                                log.info(heartbeatData.toString());
                            }
                        } catch (Exception e) {
                            if (this.isBrokerInNameServer(addr)) {
                                log.info("send heart beat to broker[{} {} {}] failed", brokerName, id, addr, e);
                            } else {
                                log.info("send heart beat to broker[{} {} {}] exception, because the broker not up, forget it", brokerName,
                                    id, addr, e);
                            }
                        }
                    }
                }
            }
        }
    }
}
```

上面的实现就是获取`HeartbeatData`对象并将该对象发送给所有的broker，下面是创建`HeartbeatData`对象的`prepareHeartbeatData()`方法：
```java
private HeartbeatData prepareHeartbeatData() {
    HeartbeatData heartbeatData = new HeartbeatData();

    // clientID
    heartbeatData.setClientID(this.clientId);

    // Consumer
    for (Map.Entry<String, MQConsumerInner> entry : this.consumerTable.entrySet()) {
        MQConsumerInner impl = entry.getValue();
        if (impl != null) {
            ConsumerData consumerData = new ConsumerData();
            consumerData.setGroupName(impl.groupName());
            consumerData.setConsumeType(impl.consumeType());
            consumerData.setMessageModel(impl.messageModel());
            consumerData.setConsumeFromWhere(impl.consumeFromWhere());
            // 获取消费者订阅配置
            consumerData.getSubscriptionDataSet().addAll(impl.subscriptions());
            consumerData.setUnitMode(impl.isUnitMode());

            heartbeatData.getConsumerDataSet().add(consumerData);
        }
    }

    // Producer
    for (Map.Entry<String/* group */, MQProducerInner> entry : this.producerTable.entrySet()) {
        MQProducerInner impl = entry.getValue();
        if (impl != null) {
            ProducerData producerData = new ProducerData();
            producerData.setGroupName(entry.getKey());

            heartbeatData.getProducerDataSet().add(producerData);
        }
    }

    return heartbeatData;
}
```

对于消费者，`producerTable`属性是空的，所以不用关心，而`consumerTable`属性是以consumeGroup为key，`DefaultMQPushConsumerImpl`对象为value的map，`HeartbeatData`对象的`consumerDataSet`属性包含了当前进程中所有消费者组的`DefaultMQPushConsumerImpl`对象对应的`ConsumerData`对象，`ConsumerData`对象表示的是一个消费者的配置，关于消费者的订阅配置，是通过`DefaultMQPushConsumerImpl`类的`subscriptions()`方法获取的，该方法代码如下：
```java
@Override
public Set<SubscriptionData> subscriptions() {
    Set<SubscriptionData> subSet = new HashSet<SubscriptionData>();

    subSet.addAll(this.rebalanceImpl.getSubscriptionInner().values());

    return subSet;
}
```

`DefaultMQPushConsumerImpl`类的`subscriptions()`方法又从`RebalanceImpl`类获取了之前说的消费者的订阅配置。通过上面的分析可知，消费者发送的心跳除了能够将自己注册到broker以外，还能够告知broker自己的订阅配置，下面再看看broker是如何处理消费者的心跳的。

心跳请求的code为`RequestCode.HEART_BEAT`，broker端的处理方式是`ClientManageProcessor`类的`heartBeat()`方法：
```java
public RemotingCommand heartBeat(ChannelHandlerContext ctx, RemotingCommand request) {
    RemotingCommand response = RemotingCommand.createResponseCommand(null);
    HeartbeatData heartbeatData = HeartbeatData.decode(request.getBody(), HeartbeatData.class);
    // ClientChannelInfo表示一个消费者的连接，主要在于ctx.channel()，这个是netty的channel
    ClientChannelInfo clientChannelInfo = new ClientChannelInfo(
        ctx.channel(),
        heartbeatData.getClientID(),
        request.getLanguage(),
        request.getVersion()
    );

    // ConsumerData包含了一个消费者的配置，包括消费者组名、push还是pull、集群还是广播模式、订阅配置等
    for (ConsumerData data : heartbeatData.getConsumerDataSet()) {
        // SubscriptionGroupConfig表示broker中保存的某个消费者组的配置
        SubscriptionGroupConfig subscriptionGroupConfig =
            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(
                data.getGroupName());
        boolean isNotifyConsumerIdsChangedEnable = true;
        if (null != subscriptionGroupConfig) {
            // isNotifyConsumerIdsChangedEnable表示broker发现某个消费者组的消费者实例数量有变化时，是否通知所有这个消费者组的
            // 消费者实例，默认为true。当消费者收到这个通知后，会立即触发负载均衡
            isNotifyConsumerIdsChangedEnable = subscriptionGroupConfig.isNotifyConsumerIdsChangedEnable();
            int topicSysFlag = 0;
            if (data.isUnitMode()) {
                topicSysFlag = TopicSysFlag.buildSysFlag(false, true);
            }
            String newTopic = MixAll.getRetryTopic(data.getGroupName());
            // 如果retry topic还不存在则创建并发送当前broker的配置给所有的nameSrv，否则createTopicInSendMessageBackMethod
            // 方法会直接返回
            this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(
                newTopic,
                subscriptionGroupConfig.getRetryQueueNums(),
                PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);
        }

        boolean changed = this.brokerController.getConsumerManager().registerConsumer(
            data.getGroupName(),
            clientChannelInfo,
            data.getConsumeType(),
            data.getMessageModel(),
            data.getConsumeFromWhere(),
            data.getSubscriptionDataSet(),
            isNotifyConsumerIdsChangedEnable
        );

        if (changed) {
            log.info("registerConsumer info changed {} {}",
                data.toString(),
                RemotingHelper.parseChannelRemoteAddr(ctx.channel())
            );
        }
    }

    for (ProducerData data : heartbeatData.getProducerDataSet()) {
        this.brokerController.getProducerManager().registerProducer(data.getGroupName(),
            clientChannelInfo);
    }
    response.setCode(ResponseCode.SUCCESS);
    response.setRemark(null);
    return response;
}
```

`heartBeat()`方法首先创建`ClientChannelInfo`对象用于表示一个消费者实例，之后从`HeartbeatData`对象中获取消费者的配置，也就是`ConsumerData`对象，调用`ConsumerManager`类的`registerConsumer()`方法完成消费者注册逻辑，`registerConsumer()`方法接收`ClientChannelInfo`对象作为参数，`ClientChannelInfo`对象持有能够向消费者发送请求的`Channel`，所以持有`ClientChannelInfo`对象拥有了主动和消费者通信的能力，`registerConsumer()`方法代码如下：
```java
public boolean registerConsumer(final String group, final ClientChannelInfo clientChannelInfo,
    ConsumeType consumeType, MessageModel messageModel, ConsumeFromWhere consumeFromWhere,
    final Set<SubscriptionData> subList, boolean isNotifyConsumerIdsChangedEnable) {

    // ConsumerGroupInfo对象保存了一个消费者组内消费者的配置，如果不存在当前消费者组的ConsumerGroupInfo则新建一个
    ConsumerGroupInfo consumerGroupInfo = this.consumerTable.get(group);
    if (null == consumerGroupInfo) {
        ConsumerGroupInfo tmp = new ConsumerGroupInfo(group, consumeType, messageModel, consumeFromWhere);
        ConsumerGroupInfo prev = this.consumerTable.putIfAbsent(group, tmp);
        consumerGroupInfo = prev != null ? prev : tmp;
    }

    // 将clientChannelInfo保存下来，这样相当于broker拥有了和消费者通信的能力，因为clientChannelInfo中包含了对应的
    // 消费者的channel，如果已经保存了clientChannelInfo对应的消费者的channel，则updateChannel返回false
    boolean r1 =
        consumerGroupInfo.updateChannel(clientChannelInfo, consumeType, messageModel,
            consumeFromWhere);
    // 更新订阅配置，如果配置没有发生变化则updateSubscription返回false
    boolean r2 = consumerGroupInfo.updateSubscription(subList);

    if (r1 || r2) {
        // r1为true表示有新的消费者注册到了当前broker，r2为true表示消费者的订阅配置变化了，这两种情况的任意一种都通知当前消费者组
        // 的所有消费者实例
        if (isNotifyConsumerIdsChangedEnable) {
            this.consumerIdsChangeListener.handle(ConsumerGroupEvent.CHANGE, group, consumerGroupInfo.getAllChannel());
        }
    }

    // 触发ConsumerGroupEvent.REGISTER事件，对于该事件，主要是更新当前broker的消费过滤配置
    this.consumerIdsChangeListener.handle(ConsumerGroupEvent.REGISTER, group, subList);

    return r1 || r2;
}
```

`registerConsumer()`方法首先检查时候存在当前消费者所在的消费者组的`ConsumerGroupInfo`对象，没有则创建一个。`ConsumerGroupInfo`对象的作用从其成员变量就能看出来：
```java
public class ConsumerGroupInfo {
    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
    private final String groupName;
    private final ConcurrentMap<String/* Topic */, SubscriptionData> subscriptionTable =
        new ConcurrentHashMap<String, SubscriptionData>();
    private final ConcurrentMap<Channel, ClientChannelInfo> channelInfoTable =
        new ConcurrentHashMap<Channel, ClientChannelInfo>(16);
    private volatile ConsumeType consumeType;
    private volatile MessageModel messageModel;
    private volatile ConsumeFromWhere consumeFromWhere;
    private volatile long lastUpdateTimestamp = System.currentTimeMillis();

    // 略...
}
```

`ConsumerGroupInfo`对象的`groupName`属性就是其代表的消费者组的组名，`subscriptionTable`属性保存了该组的所有消费者订阅的topic及订阅配置，这是用topic作为key而不是消费者的clientId是因为消费者组内的消费者在rocketmq中被认为是相同的，所以对于某个topic，消费者组内的消费者的订阅配置应该是一样的。`ConsumerGroupInfo`对象的另外一个关键属性`channelInfoTable`用于保存`Channel`对象和上面说到的`ClientChannelInfo`对象，其他属性从属性类型就能看出作用了。回到`registerConsumer()`方法，在获取到`ConsumerGroupInfo`对象后，`registerConsumer()`方法调用`ConsumerGroupInfo`对象的`updateChannel()`方法保存这次发送心跳请求的消费者的`ClientChannelInfo`对象，代码：
```java
public boolean updateChannel(final ClientChannelInfo infoNew, ConsumeType consumeType,
    MessageModel messageModel, ConsumeFromWhere consumeFromWhere) {
    boolean updated = false;
    this.consumeType = consumeType;
    this.messageModel = messageModel;
    this.consumeFromWhere = consumeFromWhere;

    ClientChannelInfo infoOld = this.channelInfoTable.get(infoNew.getChannel());
    if (null == infoOld) {
        ClientChannelInfo prev = this.channelInfoTable.put(infoNew.getChannel(), infoNew);
        // 这个消费者是第一次发送心跳
        if (null == prev) {
            log.info("new consumer connected, group: {} {} {} channel: {}", this.groupName, consumeType,
                messageModel, infoNew.toString());
            updated = true;
        }

        infoOld = infoNew;
    } else {
        // 理论上不会出现这个情况，即某个消费者的clientId在不同的心跳请求中的值不同
        if (!infoOld.getClientId().equals(infoNew.getClientId())) {
            log.error("[BUG] consumer channel exist in broker, but clientId not equal. GROUP: {} OLD: {} NEW: {} ",
                this.groupName,
                infoOld.toString(),
                infoNew.toString());
            this.channelInfoTable.put(infoNew.getChannel(), infoNew);
        }
    }

    this.lastUpdateTimestamp = System.currentTimeMillis();
    infoOld.setLastUpdateTimestamp(this.lastUpdateTimestamp);

    return updated;
}
```

`updateChannel()`方法将`ClientChannelInfo`对象保存到其`channelInfoTable`属性，并在当前消费者为第一次发送心跳请求的情况下返回true。在`updateChannel()`方法之后，`registerConsumer()`方法又调用了`ConsumerGroupInfo`对象的`updateSubscription()`方法更新订阅配置：
```java
public boolean updateSubscription(final Set<SubscriptionData> subList) {
    boolean updated = false;

    // 遍历当前消费者的订阅配置，如果版本变化了则更新
    for (SubscriptionData sub : subList) {
        SubscriptionData old = this.subscriptionTable.get(sub.getTopic());
        if (old == null) {
            SubscriptionData prev = this.subscriptionTable.putIfAbsent(sub.getTopic(), sub);
            if (null == prev) {
                updated = true;
                log.info("subscription changed, add new topic, group: {} {}",
                    this.groupName,
                    sub.toString());
            }
        } else if (sub.getSubVersion() > old.getSubVersion()) {
            // 如果消费者是push模式
            if (this.consumeType == ConsumeType.CONSUME_PASSIVELY) {
                log.info("subscription changed, group: {} OLD: {} NEW: {}",
                    this.groupName,
                    old.toString(),
                    sub.toString()
                );
            }

            this.subscriptionTable.put(sub.getTopic(), sub);
        }
    }

    // 遍历已存在的订阅配置，如果这次的心跳请求中不包含已经保存在subscriptionTable属性中的某个topic的配置，则将该topic从
    // subscriptionTable属性删除，即消费者不再消费该topic了
    Iterator<Entry<String, SubscriptionData>> it = this.subscriptionTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<String, SubscriptionData> next = it.next();
        String oldTopic = next.getKey();

        boolean exist = false;
        for (SubscriptionData sub : subList) {
            if (sub.getTopic().equals(oldTopic)) {
                exist = true;
                break;
            }
        }

        if (!exist) {
            log.warn("subscription changed, group: {} remove topic {} {}",
                this.groupName,
                oldTopic,
                next.getValue().toString()
            );

            it.remove();
            updated = true;
        }
    }

    this.lastUpdateTimestamp = System.currentTimeMillis();

    // 如果订阅配置是第一次被保存，或者订阅的topic列表有变化，则返回true
    return updated;
}
```

`updateSubscription()`方法保存传入的订阅配置，并根据新的配置移除消费者不再订阅的topic，之后在这个消费者组订阅的topic列表有变化的情况下返回true。再回到`registerConsumer()`方法，接下来执行的逻辑是：
```java
if (r1 || r2) {
    // r1为true表示有新的消费者注册到了当前broker，r2为true表示消费者的订阅配置变化了，这两种情况的任意一种都通知当前消费者组
    // 的所有消费者实例
    if (isNotifyConsumerIdsChangedEnable) {
        this.consumerIdsChangeListener.handle(ConsumerGroupEvent.CHANGE, group, consumerGroupInfo.getAllChannel());
    }
}

// 触发ConsumerGroupEvent.REGISTER事件，对于该事件，主要是更新当前broker的消费过滤配置
this.consumerIdsChangeListener.handle(ConsumerGroupEvent.REGISTER, group, subList);

return r1 || r2;
```

即在消费者是第一次发送心跳的情况下，或者消费者组订阅的topic列表有变化的情况下，执行`DefaultConsumerIdsChangeListener`类的`handle()`方法触发`ConsumerGroupEvent.CHANGE`事件，在`registerConsumer()`方法的最后，还会无条件的调用这个`handle()`方法触发`ConsumerGroupEvent.REGISTER`事件，这两次`handle()`方法的调用对应的是同一个方法实现，该方法代码：
```java
@Override
public void handle(ConsumerGroupEvent event, String group, Object... args) {
    if (event == null) {
        return;
    }
    switch (event) {
        case CHANGE: // 有新消费者注册或者订阅配置发送了变化
            if (args == null || args.length < 1) {
                return;
            }
            // 这里获取的参数为consumerGroupInfo.getAllChannel()，即当前消费者所在的消费者组中所有已经注册到当前broker的消
            // 费者的Channel
            List<Channel> channels = (List<Channel>) args[0];
            if (channels != null && brokerController.getBrokerConfig().isNotifyConsumerIdsChangedEnable()) {
                // 遍历消费者的Channel，发送消费者成员变更请求
                for (Channel chl : channels) {
                    this.brokerController.getBroker2Client().notifyConsumerIdsChanged(chl, group);
                }
            }
            break;
        case UNREGISTER:
            this.brokerController.getConsumerFilterManager().unRegister(group);
            break;
        case REGISTER: // 消费者注册，无论是否是第一次注册，可以认为每次心跳都会触发该事件
            if (args == null || args.length < 1) {
                return;
            }
            // 这里获取的参数为Set<SubscriptionData>，即当前消费者的所有订阅配置
            Collection<SubscriptionData> subscriptionDataList = (Collection<SubscriptionData>) args[0];
            this.brokerController.getConsumerFilterManager().register(group, subscriptionDataList);
            break;
        default:
            throw new RuntimeException("Unknown event " + event);
    }
}
```

`handle()`方法的实现并不复杂，对于`ConsumerGroupEvent.REGISTER`事件，主要是处理订阅配置的过滤相关逻辑，不是负载均衡的重点，这里看看对于`ConsumerGroupEvent.CHANGE`事件的处理，对于该事件，`handle()`方法调用`Broker2Client`类的`notifyConsumerIdsChanged()`方法向所有当前消费者所在的消费者组成员发送`RequestCode.NOTIFY_CONSUMER_IDS_CHANGED`请求，代码：
```java
public void notifyConsumerIdsChanged(
    final Channel channel,
    final String consumerGroup) {
    if (null == consumerGroup) {
        log.error("notifyConsumerIdsChanged consumerGroup is null");
        return;
    }

    NotifyConsumerIdsChangedRequestHeader requestHeader = new NotifyConsumerIdsChangedRequestHeader();
    requestHeader.setConsumerGroup(consumerGroup);
    RemotingCommand request =
        RemotingCommand.createRequestCommand(RequestCode.NOTIFY_CONSUMER_IDS_CHANGED, requestHeader);

    try {
        this.brokerController.getRemotingServer().invokeOneway(channel, request, 10);
    } catch (Exception e) {
        log.error("notifyConsumerIdsChanged exception, " + consumerGroup, e.getMessage());
    }
}
```

消费者对于该请求的处理在`ClientRemotingProcessor`类的`notifyConsumerIdsChanged()`方法，代码：
```java
public RemotingCommand notifyConsumerIdsChanged(ChannelHandlerContext ctx,
    RemotingCommand request) throws RemotingCommandException {
    try {
        final NotifyConsumerIdsChangedRequestHeader requestHeader =
            (NotifyConsumerIdsChangedRequestHeader) request.decodeCommandCustomHeader(NotifyConsumerIdsChangedRequestHeader.class);
        log.info("receive broker's notification[{}], the consumer group: {} changed, rebalance immediately",
            RemotingHelper.parseChannelRemoteAddr(ctx.channel()),
            requestHeader.getConsumerGroup());
        this.mqClientFactory.rebalanceImmediately();
    } catch (Exception e) {
        log.error("notifyConsumerIdsChanged exception", RemotingHelper.exceptionSimpleDesc(e));
    }
    return null;
}
```

上面的实现就是简单的调用`MQClientInstance`类的`rebalanceImmediately()`方法：
```java
public void rebalanceImmediately() {
    this.rebalanceService.wakeup();
}
```

`rebalanceImmediately()`方法调用`RebalanceService`类的`wakeup()`方法，时期立刻从wait状态返回，`RebalanceService`类继承自`ServiceThread`类，该类的实现很简单：
```java
public class RebalanceService extends ServiceThread {
    private static long waitInterval =
        Long.parseLong(System.getProperty(
            "rocketmq.client.rebalance.waitInterval", "20000"));
    private final InternalLogger log = ClientLogger.getLog();
    private final MQClientInstance mqClientFactory;

    public RebalanceService(MQClientInstance mqClientFactory) {
        this.mqClientFactory = mqClientFactory;
    }

    @Override
    public void run() {
        log.info(this.getServiceName() + " service started");

        while (!this.isStopped()) {
            this.waitForRunning(waitInterval);
            this.mqClientFactory.doRebalance();
        }

        log.info(this.getServiceName() + " service end");
    }

    @Override
    public String getServiceName() {
        return RebalanceService.class.getSimpleName();
    }
}
```

`RebalanceService`类就是不断的调用`MQClientInstance`类的`doRebalance()`方法，下面是`doRebalance()`方法的实现：
```java
public void doRebalance() {
    for (Map.Entry<String, MQConsumerInner> entry : this.consumerTable.entrySet()) {
        MQConsumerInner impl = entry.getValue();
        if (impl != null) {
            try {
                impl.doRebalance();
            } catch (Throwable e) {
                log.error("doRebalance exception", e);
            }
        }
    }
}
```

`doRebalance()`方法遍历`DefaultMQPushConsumerImpl`对象并调用`doRebalance()`方法，该方法代码：
```java
@Override
public void doRebalance() {
    if (!this.pause) {
        // isConsumeOrderly方法返回值表示当前消费者是否是顺序消费
        this.rebalanceImpl.doRebalance(this.isConsumeOrderly());
    }
}
```

最终到了负载均衡的核心实现类`RebalanceImpl`，下面看看该类是如何实现负载均衡的。