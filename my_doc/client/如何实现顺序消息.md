顺序消息能够保证消息被有序的消费，消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的，RocketMQ可以严格的保证消息有序。

实现顺序消息，rocketmq需要解决三个问题：
#### 异步发送消息可能会导致消息最终保存在Broker的时间不一致，后发送的消息可能先被保存到broker，使得消息存储顺序和发送顺序不一致
解决方案：采取同步发送的方式按照顺序发送消息

#### 默认消息的发送是同步的，但是默认是轮询队列的方式发送消息，使得消息会存储到不同的队列中，这就无法保证消息被消费的顺序
解决方案：同步发送消息 + `MessageQueueSelector`实现一个业务的消息被存储在一个队列中

#### 消费者负载均衡20s执行一次，消费者A从队列X拉取到5条消息后，由于消费者A的负载过高，不能及时消费这些消息，消费堆积在内存中，此时重新更新了负载策略，队列X分给了消费者B，消费者B拉取到了第6到10条消息，并且消费者B负载低，直接消费编号6到10的消息，而编号1-5的消息还堆积在消费者A的内存中，此时消息的顺序就乱了
解决方案：通过分布式锁锁住队列，并且每次消费者变更消费的队列时，必须确保消息全部被消费完了，才可以释放锁

上面是在rocketmq中顺序消息的实现，下面来分析这些点。

## 按照顺序同步发送消息
只需要生产者按照如下代码发送消息即可：
```java
String[] tags = new String[] {"TagA", "TagB", "TagC", "TagD", "TagE"};
for (int i = 0; i < 100; i++) {
    // 模拟业务ID
    int orderId = i % 10;
    // 创建消息
    Message msg =
        new Message("TopicTestjjj", tags[i % tags.length], "KEY" + i,
            ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
    // 同步发送消息，使用MessageQueueSelector对象进行队列的选择，选择的依据是业务ID
    SendResult sendResult = producer.send(msg, new MessageQueueSelector() {
        @Override
        public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
            // 这里的arg实际上就是orderId
            Integer id = (Integer) arg;
            int index = id % mqs.size();
            return mqs.get(index);
        }
    }, orderId);

    System.out.printf("%s%n", sendResult);
}
```

这种发送方式和普通的消息发送区别只在于添加了一个`MessageQueueSelector`接口的实现类，实现了选择队列的逻辑，保证同一个业务下的消息被发到同一个队列，而普通的发送方式默认轮训选择队列，关于消息发送的过程可以看笔记[如何实现消息发送](如何实现消息发送.md)。

## 消费者锁住队列
消费者执行负载均衡时会按照负载均衡策略判断其应该消费的队列，根据笔记[如何实现负载均衡](如何实现负载均衡.md)可知，负载均衡的队列选择对应的代码在`RebalanceImpl`类的`rebalanceByTopic()`方法：
```java
private void rebalanceByTopic(final String topic, final boolean isOrder) {
    switch (messageModel) {
        case BROADCASTING: {
            // 略...
        }
        case CLUSTERING: {
            // 略

            if (mqSet != null && cidAll != null) {
                // 略

                // allocateResultSet保存了所有根据负载均衡策略分配到的MessageQueue对象
                boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);
                // 如果这次的负载均衡和上次的结果有变化（新增或移除了需要消费的MessageQueue）
                if (changed) {
                    // 记录下这次负载均衡的结果
                    log.info(
                        "rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}",
                        strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),
                        allocateResultSet.size(), allocateResultSet);
                    // messageQueueChanged方法会根据这次负载均衡的结果更新流控的配置，并发送心跳给broker
                    this.messageQueueChanged(topic, mqSet, allocateResultSet);
                }
            }
            break;
        }
        default:
            break;
    }
}
```

在根据`AllocateMessageQueueStrategy`选择到当前消费者负责的队列后，还需要调用`updateProcessQueueTableInRebalance()`方法对选择的队列进行处理，而`updateProcessQueueTableInRebalance()`方法中的`isOrder`参数用于判断当前消费者是否是顺序消费消息，判断的依据很简单：
```java
// ConsumeMessageService负责持有和配置消费消息的线程池
if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {
    this.consumeOrderly = true;
    this.consumeMessageService =
        new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
} else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {
    this.consumeOrderly = false;
    this.consumeMessageService =
        new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
}
```

上面的语句在`DefaultMQPushConsumerImpl`类的`start()`方法，其中`this.consumeOrderly`的值就是`updateProcessQueueTableInRebalance()`方法中`isOrder`参数的值，而一个顺序消费的消费者，通常是按照如下模式消费消息的：
```java
consumer.registerMessageListener(new MessageListenerOrderly() {
    @Override
    public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {
        // 略
    }
})
```

所以顺序消费的消息的`isOrder`参数为true，这些内容可以看笔记[如何实现消息消费](如何实现消息消费.md)中看到，下面再看看`updateProcessQueueTableInRebalance()`方法中的处理：
```java
private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet,
    final boolean isOrder) {
    boolean changed = false;

    // 略...

    List<PullRequest> pullRequestList = new ArrayList<PullRequest>();
    // mqSet保存在这次负载均衡分配到的所有MessageQueue对象
    for (MessageQueue mq : mqSet) {
        // 如果上一次负载均衡后当前的MessageQueue对象没有分配给当前RebalanceImpl对象所在的DefaultMQPushConsumerImpl对象
        // 则在下面创建这次新分配到的MessageQueue对象对应的PullRequest
        if (!this.processQueueTable.containsKey(mq)) {
            // 顺序消息锁住当前的MessageQueue，也就是对应的Broker中的consumeQueue，从上面removeUnnecessaryMessageQueue方法
            // 的实现可以看出，锁是可能加不上的，此时记录日志，跳过这个分配到的MessageQueue
            if (isOrder && !this.lock(mq)) {
                log.warn("doRebalance, {}, add a new mq failed, {}, because lock failed", consumerGroup, mq);
                continue;
            }

            // 清除OffsetStore中保存的MessageQueue的消费位移，确保新分配的MessageQueue不会被旧数据影响
            this.removeDirtyOffset(mq);
            // ProcessQueue表示当前MessageQueue对象在当前消费者的消费情况，通过ProcessQueue对象能够判断是否需要触发消费者
            // 流控
            ProcessQueue pq = new ProcessQueue();
            // 根据DefaultMQPushConsumer对象的ConsumeFromWhere配置获取消费位移
            long nextOffset = this.computePullFromWhere(mq);
            if (nextOffset >= 0) {
                ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);
                if (pre != null) {
                    log.info("doRebalance, {}, mq already exists, {}", consumerGroup, mq);
                } else {
                    log.info("doRebalance, {}, add a new mq, {}", consumerGroup, mq);
                    // 创建当前MessageQueue对应的PullRequest
                    PullRequest pullRequest = new PullRequest();
                    pullRequest.setConsumerGroup(consumerGroup);
                    pullRequest.setNextOffset(nextOffset);
                    pullRequest.setMessageQueue(mq);
                    pullRequest.setProcessQueue(pq);
                    pullRequestList.add(pullRequest);
                    changed = true;
                }
            } else {
                log.warn("doRebalance, {}, add new mq failed, {}", consumerGroup, mq);
            }
        }
    }

    // pullRequestList保存了这次负载均衡新分配到的所有MessageQueue对应的PullRequest（不包括已经分配到的MessageQueue）
    // 这里开始针对这些PullRequest执行拉取消息操作
    this.dispatchPullRequest(pullRequestList);

    return changed;
}
```

`updateProcessQueueTableInRebalance()`方法会为新分配的队列执行`lock()`方法，该方法会向broker发送锁住队列的请求，代码：
```java
public boolean lock(final MessageQueue mq) {
    // 获取指定brokerName的master broker
    FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);
    if (findBrokerResult != null) {
        LockBatchRequestBody requestBody = new LockBatchRequestBody();
        requestBody.setConsumerGroup(this.consumerGroup);
        requestBody.setClientId(this.mQClientFactory.getClientId());
        requestBody.getMqSet().add(mq);

        try {
            // 向broker发送锁住队列的请求
            Set<MessageQueue> lockedMq =
                this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);
            for (MessageQueue mmqq : lockedMq) {
                ProcessQueue processQueue = this.processQueueTable.get(mmqq);
                if (processQueue != null) {
                    processQueue.setLocked(true);
                    processQueue.setLastLockTimestamp(System.currentTimeMillis());
                }
            }

            boolean lockOK = lockedMq.contains(mq);
            log.info("the message queue lock {}, {} {}",
                lockOK ? "OK" : "Failed",
                this.consumerGroup,
                mq);
            return lockOK;
        } catch (Exception e) {
            log.error("lockBatchMQ exception, " + mq, e);
        }
    }

    return false;
}
```

`lock()`方法将当前队列添加到请求中，并通过`lockBatchMQ()`方法发送`RequestCode.LOCK_BATCH_MQ`请求，对于该请求，broker端的处理在`AdminBrokerProcessor`类的`lockBatchMQ()`方法：
```java
private RemotingCommand lockBatchMQ(ChannelHandlerContext ctx,
    RemotingCommand request) throws RemotingCommandException {
    final RemotingCommand response = RemotingCommand.createResponseCommand(null);
    LockBatchRequestBody requestBody = LockBatchRequestBody.decode(request.getBody(), LockBatchRequestBody.class);

    Set<MessageQueue> lockOKMQSet = this.brokerController.getRebalanceLockManager().tryLockBatch(
        requestBody.getConsumerGroup(),
        requestBody.getMqSet(),
        requestBody.getClientId());

    LockBatchResponseBody responseBody = new LockBatchResponseBody();
    responseBody.setLockOKMQSet(lockOKMQSet);

    response.setBody(responseBody.encode());
    response.setCode(ResponseCode.SUCCESS);
    response.setRemark(null);
    return response;
}
```

执行锁队列逻辑的是`RebalanceLockManager`类的`tryLockBatch()`方法：
```java
public Set<MessageQueue> tryLockBatch(final String group, final Set<MessageQueue> mqs,
    final String clientId) {
    Set<MessageQueue> lockedMqs = new HashSet<MessageQueue>(mqs.size());
    Set<MessageQueue> notLockedMqs = new HashSet<MessageQueue>(mqs.size());

    // 遍历消费者请求需要锁住的队列
    for (MessageQueue mq : mqs) {
        // 判断当前消费者是否已经持有了队列的锁
        if (this.isLocked(group, mq, clientId)) {
            lockedMqs.add(mq);
        } else {
            // 没有则添加到notLockedMqs等待后续处理
            notLockedMqs.add(mq);
        }
    }

    // notLockedMqs为没有被当前消费者锁的队列
    if (!notLockedMqs.isEmpty()) {
        try {
            this.lock.lockInterruptibly();
            try {
                // mqLockTable保存了所有消费者组的队列锁状态，key为队列，value的LockEntry对象保存了持有队列锁的消费者id
                ConcurrentHashMap<MessageQueue, LockEntry> groupValue = this.mqLockTable.get(group);
                if (null == groupValue) {
                    groupValue = new ConcurrentHashMap<>(32);
                    this.mqLockTable.put(group, groupValue);
                }

                for (MessageQueue mq : notLockedMqs) {
                    LockEntry lockEntry = groupValue.get(mq);
                    // 如果lockEntry为null说明该队列还没有被锁
                    if (null == lockEntry) {
                        lockEntry = new LockEntry();
                        // 设置当前队列被当前消费者持有锁
                        lockEntry.setClientId(clientId);
                        groupValue.put(mq, lockEntry);
                        log.info(
                            "tryLockBatch, message queue not locked, I got it. Group: {} NewClientId: {} {}",
                            group,
                            clientId,
                            mq);
                    }

                    // 如果该队列已经被当前消费者锁住了，更新锁的时间，通过LockEntry类的isLocked方法可以发现，队列的锁是有有
                    // 效期的，默认60s，而消费者端的ConsumeMessageOrderlyService类每隔20s也会申请锁住所有其所在消费者分配到的
                    // 队列，以此更新broker中锁的有效期（消费者负载均衡是，新分配到的队列也会发起锁队列请求）
                    if (lockEntry.isLocked(clientId)) {
                        lockEntry.setLastUpdateTimestamp(System.currentTimeMillis());
                        // 保存成功锁住的队列
                        lockedMqs.add(mq);
                        continue;
                    }

                    // 获取原来持有当前队列的锁的消费者id
                    String oldClientId = lockEntry.getClientId();

                    // 如果原来的消费者持有的锁过期了，更新锁为当前消费者持有
                    if (lockEntry.isExpired()) {
                        lockEntry.setClientId(clientId);
                        lockEntry.setLastUpdateTimestamp(System.currentTimeMillis());
                        log.warn(
                            "tryLockBatch, message queue lock expired, I got it. Group: {} OldClientId: {} NewClientId: {} {}",
                            group,
                            oldClientId,
                            clientId,
                            mq);
                        // 保存成功锁住的队列
                        lockedMqs.add(mq);
                        continue;
                    }

                    log.warn(
                        "tryLockBatch, message queue locked by other client. Group: {} OtherClientId: {} NewClientId: {} {}",
                        group,
                        oldClientId,
                        clientId,
                        mq);
                }
            } finally {
                this.lock.unlock();
            }
        } catch (InterruptedException e) {
            log.error("putMessage exception", e);
        }
    }

    // 返回成功锁住的队列
    return lockedMqs;
}
```

`tryLockBatch()`方法遍历需要锁住的队列，在队列没有被其它消费者锁住，或者锁过期的情况下，设置当前消费者为新的锁的持有者，并返回成功加锁的队列。回到`RebalanceImpl`类的`updateProcessQueueTableInRebalance()`方法，只有成功加锁的情况下，`updateProcessQueueTableInRebalance()`方法才会针对队列创建`PullRequest`对象，执行拉取消息逻辑，关于`PullRequest`对象和执行拉取消息逻辑，可以看笔记[如何实现消息消费](如何实现消息消费.md)。

以上是消息对队列加锁的实现，保证了顺序消费的情况下，一个队列在被某个消费者锁住的情况下，其它消费者在负载均衡时也不会消费该队列。下面再看看顺序消费的情况下，是如何释放锁的。