顺序消息能够保证消息被有序的消费，消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的，RocketMQ可以严格的保证消息有序。

实现顺序消息，rocketmq需要解决三个问题：
#### 异步发送消息可能会导致消息最终保存在Broker的时间不一致，后发送的消息可能先被保存到broker，使得消息存储顺序和发送顺序不一致
解决方案：采取同步发送的方式按照顺序发送消息

#### 默认消息的发送是同步的，但是默认是轮询队列的方式发送消息，使得消息会存储到不同的队列中，这就无法保证消息被消费的顺序
解决方案：同步发送消息 + `MessageQueueSelector`实现一个业务的消息被存储在一个队列中

#### 消费者负载均衡20s执行一次，消费者A从队列X拉取到5条消息后，由于消费者A的负载过高，不能及时消费这些消息，消费堆积在内存中，此时重新更新了负载策略，队列X分给了消费者B，消费者B拉取到了第6到10条消息，并且消费者B负载低，直接消费编号6到10的消息，而编号1-5的消息还堆积在消费者A的内存中，此时消息的顺序就乱了
解决方案：通过分布式锁锁住队列，并且每次消费者变更消费的队列时，必须确保消息全部被消费完了，才可以释放锁

上面是在rocketmq中顺序消息的实现，下面来分析这些点。

## 按照顺序同步发送消息
只需要生产者按照如下代码发送消息即可：
```java
String[] tags = new String[] {"TagA", "TagB", "TagC", "TagD", "TagE"};
for (int i = 0; i < 100; i++) {
    // 模拟业务ID
    int orderId = i % 10;
    // 创建消息
    Message msg =
        new Message("TopicTestjjj", tags[i % tags.length], "KEY" + i,
            ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
    // 同步发送消息，使用MessageQueueSelector对象进行队列的选择，选择的依据是业务ID
    SendResult sendResult = producer.send(msg, new MessageQueueSelector() {
        @Override
        public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
            // 这里的arg实际上就是orderId
            Integer id = (Integer) arg;
            int index = id % mqs.size();
            return mqs.get(index);
        }
    }, orderId);

    System.out.printf("%s%n", sendResult);
}
```

这种发送方式和普通的消息发送区别只在于添加了一个`MessageQueueSelector`接口的实现类，实现了选择队列的逻辑，保证同一个业务下的消息被发到同一个队列，而普通的发送方式默认轮训选择队列，关于消息发送的过程可以看笔记[如何实现消息发送](如何实现消息发送.md)。

## 消费者锁住队列
消费者执行负载均衡时会按照负载均衡策略判断其应该消费的队列，根据笔记[如何实现负载均衡](如何实现负载均衡.md)可知，负载均衡的队列选择对应的代码在`RebalanceImpl`类的`rebalanceByTopic()`方法：
```java
private void rebalanceByTopic(final String topic, final boolean isOrder) {
    switch (messageModel) {
        case BROADCASTING: {
            // 略...
        }
        case CLUSTERING: {
            // 略

            if (mqSet != null && cidAll != null) {
                // 略

                // allocateResultSet保存了所有根据负载均衡策略分配到的MessageQueue对象
                boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);
                // 如果这次的负载均衡和上次的结果有变化（新增或移除了需要消费的MessageQueue）
                if (changed) {
                    // 记录下这次负载均衡的结果
                    log.info(
                        "rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}",
                        strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),
                        allocateResultSet.size(), allocateResultSet);
                    // messageQueueChanged方法会根据这次负载均衡的结果更新流控的配置，并发送心跳给broker
                    this.messageQueueChanged(topic, mqSet, allocateResultSet);
                }
            }
            break;
        }
        default:
            break;
    }
}
```

在根据`AllocateMessageQueueStrategy`选择到当前消费者负责的队列后，还需要调用`updateProcessQueueTableInRebalance()`方法对选择的队列进行处理，而`updateProcessQueueTableInRebalance()`方法中的`isOrder`参数用于判断当前消费者是否是顺序消费消息，判断的依据很简单：
```java
// ConsumeMessageService负责持有和配置消费消息的线程池
if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {
    this.consumeOrderly = true;
    this.consumeMessageService =
        new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
} else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {
    this.consumeOrderly = false;
    this.consumeMessageService =
        new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
}
```

上面的语句在`DefaultMQPushConsumerImpl`类的`start()`方法，其中`this.consumeOrderly`的值就是`updateProcessQueueTableInRebalance()`方法中`isOrder`参数的值，而一个顺序消费的消费者，通常是按照如下模式消费消息的：
```java
consumer.registerMessageListener(new MessageListenerOrderly() {
    @Override
    public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {
        // 略
    }
})
```

所以顺序消费的消息的`isOrder`参数为true，这些内容可以看笔记[如何实现消息消费](如何实现消息消费.md)中看到，下面再看看`updateProcessQueueTableInRebalance()`方法中的处理：
```java
private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet,
    final boolean isOrder) {
    boolean changed = false;

    // 略...

    List<PullRequest> pullRequestList = new ArrayList<PullRequest>();
    // mqSet保存在这次负载均衡分配到的所有MessageQueue对象
    for (MessageQueue mq : mqSet) {
        // 如果上一次负载均衡后当前的MessageQueue对象没有分配给当前RebalanceImpl对象所在的DefaultMQPushConsumerImpl对象
        // 则在下面创建这次新分配到的MessageQueue对象对应的PullRequest
        if (!this.processQueueTable.containsKey(mq)) {
            // 顺序消息锁住当前的MessageQueue，也就是对应的Broker中的consumeQueue，从上面removeUnnecessaryMessageQueue方法
            // 的实现可以看出，锁是可能加不上的，此时记录日志，跳过这个分配到的MessageQueue
            if (isOrder && !this.lock(mq)) {
                log.warn("doRebalance, {}, add a new mq failed, {}, because lock failed", consumerGroup, mq);
                continue;
            }

            // 清除OffsetStore中保存的MessageQueue的消费位移，确保新分配的MessageQueue不会被旧数据影响
            this.removeDirtyOffset(mq);
            // ProcessQueue表示当前MessageQueue对象在当前消费者的消费情况，通过ProcessQueue对象能够判断是否需要触发消费者
            // 流控
            ProcessQueue pq = new ProcessQueue();
            // 根据DefaultMQPushConsumer对象的ConsumeFromWhere配置获取消费位移
            long nextOffset = this.computePullFromWhere(mq);
            if (nextOffset >= 0) {
                ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);
                if (pre != null) {
                    log.info("doRebalance, {}, mq already exists, {}", consumerGroup, mq);
                } else {
                    log.info("doRebalance, {}, add a new mq, {}", consumerGroup, mq);
                    // 创建当前MessageQueue对应的PullRequest
                    PullRequest pullRequest = new PullRequest();
                    pullRequest.setConsumerGroup(consumerGroup);
                    pullRequest.setNextOffset(nextOffset);
                    pullRequest.setMessageQueue(mq);
                    pullRequest.setProcessQueue(pq);
                    pullRequestList.add(pullRequest);
                    changed = true;
                }
            } else {
                log.warn("doRebalance, {}, add new mq failed, {}", consumerGroup, mq);
            }
        }
    }

    // pullRequestList保存了这次负载均衡新分配到的所有MessageQueue对应的PullRequest（不包括已经分配到的MessageQueue）
    // 这里开始针对这些PullRequest执行拉取消息操作
    this.dispatchPullRequest(pullRequestList);

    return changed;
}
```

`updateProcessQueueTableInRebalance()`方法会为新分配的队列执行`lock()`方法，该方法会向broker发送锁住队列的请求，代码：
```java
public boolean lock(final MessageQueue mq) {
    // 获取指定brokerName的master broker
    FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);
    if (findBrokerResult != null) {
        LockBatchRequestBody requestBody = new LockBatchRequestBody();
        requestBody.setConsumerGroup(this.consumerGroup);
        requestBody.setClientId(this.mQClientFactory.getClientId());
        requestBody.getMqSet().add(mq);

        try {
            // 向broker发送锁住队列的请求
            Set<MessageQueue> lockedMq =
                this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);
            for (MessageQueue mmqq : lockedMq) {
                ProcessQueue processQueue = this.processQueueTable.get(mmqq);
                if (processQueue != null) {
                    processQueue.setLocked(true);
                    processQueue.setLastLockTimestamp(System.currentTimeMillis());
                }
            }

            boolean lockOK = lockedMq.contains(mq);
            log.info("the message queue lock {}, {} {}",
                lockOK ? "OK" : "Failed",
                this.consumerGroup,
                mq);
            return lockOK;
        } catch (Exception e) {
            log.error("lockBatchMQ exception, " + mq, e);
        }
    }

    return false;
}
```

`lock()`方法将当前队列添加到请求中，并通过`lockBatchMQ()`方法发送`RequestCode.LOCK_BATCH_MQ`请求，对于该请求，broker端的处理在`AdminBrokerProcessor`类的`lockBatchMQ()`方法：
```java
private RemotingCommand lockBatchMQ(ChannelHandlerContext ctx,
    RemotingCommand request) throws RemotingCommandException {
    final RemotingCommand response = RemotingCommand.createResponseCommand(null);
    LockBatchRequestBody requestBody = LockBatchRequestBody.decode(request.getBody(), LockBatchRequestBody.class);

    Set<MessageQueue> lockOKMQSet = this.brokerController.getRebalanceLockManager().tryLockBatch(
        requestBody.getConsumerGroup(),
        requestBody.getMqSet(),
        requestBody.getClientId());

    LockBatchResponseBody responseBody = new LockBatchResponseBody();
    responseBody.setLockOKMQSet(lockOKMQSet);

    response.setBody(responseBody.encode());
    response.setCode(ResponseCode.SUCCESS);
    response.setRemark(null);
    return response;
}
```

执行锁队列逻辑的是`RebalanceLockManager`类的`tryLockBatch()`方法：
```java
public Set<MessageQueue> tryLockBatch(final String group, final Set<MessageQueue> mqs,
    final String clientId) {
    Set<MessageQueue> lockedMqs = new HashSet<MessageQueue>(mqs.size());
    Set<MessageQueue> notLockedMqs = new HashSet<MessageQueue>(mqs.size());

    // 遍历消费者请求需要锁住的队列
    for (MessageQueue mq : mqs) {
        // 判断当前消费者是否已经持有了队列的锁
        if (this.isLocked(group, mq, clientId)) {
            lockedMqs.add(mq);
        } else {
            // 没有则添加到notLockedMqs等待后续处理
            notLockedMqs.add(mq);
        }
    }

    // notLockedMqs为没有被当前消费者锁的队列
    if (!notLockedMqs.isEmpty()) {
        try {
            this.lock.lockInterruptibly();
            try {
                // mqLockTable保存了所有消费者组的队列锁状态，key为队列，value的LockEntry对象保存了持有队列锁的消费者id
                ConcurrentHashMap<MessageQueue, LockEntry> groupValue = this.mqLockTable.get(group);
                if (null == groupValue) {
                    groupValue = new ConcurrentHashMap<>(32);
                    this.mqLockTable.put(group, groupValue);
                }

                for (MessageQueue mq : notLockedMqs) {
                    LockEntry lockEntry = groupValue.get(mq);
                    // 如果lockEntry为null说明该队列还没有被锁
                    if (null == lockEntry) {
                        lockEntry = new LockEntry();
                        // 设置当前队列被当前消费者持有锁
                        lockEntry.setClientId(clientId);
                        groupValue.put(mq, lockEntry);
                        log.info(
                            "tryLockBatch, message queue not locked, I got it. Group: {} NewClientId: {} {}",
                            group,
                            clientId,
                            mq);
                    }

                    // 如果该队列已经被当前消费者锁住了，更新锁的时间，通过LockEntry类的isLocked方法可以发现，队列的锁是有有
                    // 效期的，默认60s，而消费者端的ConsumeMessageOrderlyService类每隔20s也会申请锁住所有其所在消费者分配到的
                    // 队列，以此更新broker中锁的有效期（消费者负载均衡是，新分配到的队列也会发起锁队列请求）
                    if (lockEntry.isLocked(clientId)) {
                        lockEntry.setLastUpdateTimestamp(System.currentTimeMillis());
                        // 保存成功锁住的队列
                        lockedMqs.add(mq);
                        continue;
                    }

                    // 获取原来持有当前队列的锁的消费者id
                    String oldClientId = lockEntry.getClientId();

                    // 如果原来的消费者持有的锁过期了，更新锁为当前消费者持有
                    if (lockEntry.isExpired()) {
                        lockEntry.setClientId(clientId);
                        lockEntry.setLastUpdateTimestamp(System.currentTimeMillis());
                        log.warn(
                            "tryLockBatch, message queue lock expired, I got it. Group: {} OldClientId: {} NewClientId: {} {}",
                            group,
                            oldClientId,
                            clientId,
                            mq);
                        // 保存成功锁住的队列
                        lockedMqs.add(mq);
                        continue;
                    }

                    log.warn(
                        "tryLockBatch, message queue locked by other client. Group: {} OtherClientId: {} NewClientId: {} {}",
                        group,
                        oldClientId,
                        clientId,
                        mq);
                }
            } finally {
                this.lock.unlock();
            }
        } catch (InterruptedException e) {
            log.error("putMessage exception", e);
        }
    }

    // 返回成功锁住的队列
    return lockedMqs;
}
```

`tryLockBatch()`方法遍历需要锁住的队列，在队列没有被其它消费者锁住，或者锁过期的情况下，设置当前消费者为新的锁的持有者，并返回成功加锁的队列。回到`RebalanceImpl`类的`updateProcessQueueTableInRebalance()`方法，只有成功加锁的情况下，`updateProcessQueueTableInRebalance()`方法才会针对队列创建`PullRequest`对象，执行拉取消息逻辑，关于`PullRequest`对象和执行拉取消息逻辑，可以看笔记[如何实现消息消费](如何实现消息消费.md)。

以上是消息对队列加锁的实现，保证了顺序消费的情况下，一个队列在被某个消费者锁住的情况下，其它消费者在负载均衡时也不会消费该队列。下面再看看顺序消费的情况下，是如何释放锁的。对应的解锁过程发生在`RebalanceImpl`类的`updateProcessQueueTableInRebalance()`方法：
```java
private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet,
    final boolean isOrder) {
    boolean changed = false;

    // processQueueTable保存了上一次负载均衡后分配到的MessageQueue及对应的ProcessQueue
    Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<MessageQueue, ProcessQueue> next = it.next();
        MessageQueue mq = next.getKey();
        ProcessQueue pq = next.getValue();

        if (mq.getTopic().equals(topic)) {
            // 如果这次负载均衡没有分配到该MessageQueue
            if (!mqSet.contains(mq)) {
                // 标记ProcessQueue的dropped属性为true
                pq.setDropped(true);
                // removeUnnecessaryMessageQueue方法会提交并清除消费位移，对于顺序消费，会向broker发送解锁consumeQueue的请求
                if (this.removeUnnecessaryMessageQueue(mq, pq)) {
                    // 解锁成功则从processQueueTable中移除该MessageQueue
                    it.remove();
                    changed = true;
                    log.info("doRebalance, {}, remove unnecessary mq, {}", consumerGroup, mq);
                }
                // 当前MessageQueue在上次负载均衡时也被分配到了当前消费者，并且当前MessageQueue的上次拉取消息时间到当前时间的
                // 时间差超过了阈值（默认2分钟）
            } else if (pq.isPullExpired()) {
                switch (this.consumeType()) {
                    case CONSUME_ACTIVELY: // CONSUME_ACTIVELY表示消费者的拉取策略是pull
                        break;
                    case CONSUME_PASSIVELY: // CONSUME_PASSIVELY表示消费者的拉取策略是push
                        // 拉取消息超时了就标记ProcessQueue的dropped属性为true，表示当前消费者不再消费该ProcessQueue对应的
                        // MessageQueue（也就是broker中对应的consumeQueue）
                        pq.setDropped(true);
                        // 既然放弃消费当前MessageQueue，就要提交并移除消费位移，同时对于顺序消费的情况，尝试释放锁
                        if (this.removeUnnecessaryMessageQueue(mq, pq)) {
                            it.remove();
                            changed = true;
                            log.error("[BUG]doRebalance, {}, remove unnecessary mq, {}, because pull is pause, so try to fixed it",
                                consumerGroup, mq);
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    }

    // 略...
}
```

`updateProcessQueueTableInRebalance()`方法的参数`mqSet`为一次负载均衡时根据负载均衡策略分配到的队列集合，`updateProcessQueueTableInRebalance()`方法对比分配结果和当前其正在消费的队列，如果发现有个正在消费的队列不在`mqSet`中，或者拉取消息超时了，则会调用`removeUnnecessaryMessageQueue()`方法取消消费队列，`removeUnnecessaryMessageQueue()`方法代码：
```java
@Override
public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {
    // 持久化即将被移除的MessageQueue的消费位移，对于RemoteBrokerOffsetStore的实现，就是将消费位移提交到broker
    this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);
    // 清除offsetStore中MessageQueue的数据
    this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);
    // 如果是顺序消息并且是集群模式
    if (this.defaultMQPushConsumerImpl.isConsumeOrderly()
        && MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
        try {
            // 尝试获取锁，最多等待1秒
            if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) {
                try {
                    // 发送解锁consumeQueue的请求到broker
                    return this.unlockDelay(mq, pq);
                } finally {
                    pq.getLockConsume().unlock();
                }
            } else {
                log.warn("[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}",
                    mq,
                    pq.getTryUnlockTimes());

                // 如果加锁失败，说明当前MessageQueue的消息还在被消费中，此时记录加锁失败的次数，不做其他操作
                // 获取锁时已经尝试等待1秒了，所以通常不会发生这种情况，如果发生了，只能等下次负载均衡时再来一遍
                // 解锁逻辑
                pq.incTryUnlockTimes();
            }
        } catch (Exception e) {
            log.error("removeUnnecessaryMessageQueue Exception", e);
        }

        return false;
    }
    return true;
}
```

`removeUnnecessaryMessageQueue()`方法的实现已经在注释中说明了，需要注意的是，`removeUnnecessaryMessageQueue()`方法在释放队列锁时会先回去`ProcessQueue`对象的锁，在获取成功之后才会调用`unlockDelay()`方法向broker取消锁定队列，`ProcessQueue`对象表示一个`MessageQueue`对象（也就是某个队列）在当前消费者的消费情况，比如通过`ProcessQueue`对象能够判断是否需要触发消费者流控，`ProcessQueue`对象的创建可以看笔记[如何实现消息消费](如何实现消息消费.md)。这里先看看`unlockDelay()`方法的实现：
```java
private boolean unlockDelay(final MessageQueue mq, final ProcessQueue pq) {

    // 判断当前ProcessQueue对象中是否还有从broker拉取下来后还没有消费完的消息
    if (pq.hasTempMessage()) {
        log.info("[{}]unlockDelay, begin {} ", mq.hashCode(), mq);
        // 如果有还没消费完的消息就20秒后执行unlock，在执行unlockDelay方法之前ProcessQueue对象的dropped属性已经被设置为true了，
        // 所以正在被ConsumeMessageOrderlyService消费的消息没法取消（正在被用户编写的consumeMessage方法消费），但是剩余的在
        // ProcessQueue中的消息不会再被消费了，此时只需要隔一段时间重新解锁即可，没必要重试。当然当前正在被消费的消息可能消费成功
        // 也可能消费失败，如果消费成功的话需要提交消费位移，否则消息顺序还是没法保证。所以ConsumeMessageOrderlyService必须要
        // 在dropped属性是否为true的情况下也要提交位移，而ConsumeMessageOrderlyService类的实现也确实这么做了（这点不同于
        // ConsumeMessageConcurrentlyService的实现，ConsumeMessageConcurrentlyService类在提交位移之前会判断dropped属性是否
        // 为false），同时在ConsumeMessageOrderlyService提交消费位移之前不会释放队列锁（20秒内不会），这就保证了消息的顺序
        this.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(new Runnable() {
            @Override
            public void run() {
                log.info("[{}]unlockDelay, execute at once {}", mq.hashCode(), mq);
                RebalancePushImpl.this.unlock(mq, true);
            }
        }, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS);
    } else {
        // 否则直接执行unlock
        this.unlock(mq, true);
    }
    return true;
}
```

`unlockDelay()`方法在还存在没有消费完成的消息时会隔20秒再解锁队列，这么做的目的是确保消息的顺序，如果直接发送解锁请求，则可能会出现短暂的两个消费者同时消费一个队列的情况，导致消息消费的顺序可能无法保证。

下面再看看解锁请求的发送，即`unlock()`方法：
```java
public void unlock(final MessageQueue mq, final boolean oneway) {
    FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);
    if (findBrokerResult != null) {
        UnlockBatchRequestBody requestBody = new UnlockBatchRequestBody();
        requestBody.setConsumerGroup(this.consumerGroup);
        requestBody.setClientId(this.mQClientFactory.getClientId());
        requestBody.getMqSet().add(mq);

        try {
            this.mQClientFactory.getMQClientAPIImpl().unlockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000, oneway);
            log.warn("unlock messageQueue. group:{}, clientId:{}, mq:{}",
                this.consumerGroup,
                this.mQClientFactory.getClientId(),
                mq);
        } catch (Exception e) {
            log.error("unlockBatchMQ exception, " + mq, e);
        }
    }
}
```

最终调用的`unlockBatchMQ()`方法会发送`RequestCode.UNLOCK_BATCH_MQ`请求到broker，broker端对应的处理方法是`AdminBrokerProcessor`类的`unlockBatchMQ()`方法：
```java
private RemotingCommand unlockBatchMQ(ChannelHandlerContext ctx,
    RemotingCommand request) throws RemotingCommandException {
    final RemotingCommand response = RemotingCommand.createResponseCommand(null);
    UnlockBatchRequestBody requestBody = UnlockBatchRequestBody.decode(request.getBody(), UnlockBatchRequestBody.class);

    this.brokerController.getRebalanceLockManager().unlockBatch(
        requestBody.getConsumerGroup(),
        requestBody.getMqSet(),
        requestBody.getClientId());

    response.setCode(ResponseCode.SUCCESS);
    response.setRemark(null);
    return response;
}
```

解锁逻辑实现在`RebalanceLockManager`类的`unlockBatch()`方法：
```java
public void unlockBatch(final String group, final Set<MessageQueue> mqs, final String clientId) {
    try {
        this.lock.lockInterruptibly();
        try {
            ConcurrentHashMap<MessageQueue, LockEntry> groupValue = this.mqLockTable.get(group);
            if (null != groupValue) {
                for (MessageQueue mq : mqs) {
                    LockEntry lockEntry = groupValue.get(mq);
                    if (null != lockEntry) {
                        if (lockEntry.getClientId().equals(clientId)) {
                            groupValue.remove(mq);
                            log.info("unlockBatch, Group: {} {} {}",
                                group,
                                mq,
                                clientId);
                        } else {
                            log.warn("unlockBatch, but mq locked by other client: {}, Group: {} {} {}",
                                lockEntry.getClientId(),
                                group,
                                mq,
                                clientId);
                        }
                    } else {
                        log.warn("unlockBatch, but mq not locked, Group: {} {} {}",
                            group,
                            mq,
                            clientId);
                    }
                }
            } else {
                log.warn("unlockBatch, group not exist, Group: {} {}",
                    group,
                    clientId);
            }
        } finally {
            this.lock.unlock();
        }
    } catch (InterruptedException e) {
        log.error("putMessage exception", e);
    }
}
```

`unlockBatch()`方法没啥好分析的，就是从`mqLockTable`中删除队列对应的记录。

以上是解锁过程，解锁过程中有一点还没分析，就是解锁时获取`ProcessQueue`对象的锁，下面来分析`ConsumeMessageOrderlyService`类是如何顺序消费消息的，分析完后就能理解解锁队列时为什么要加`ProcessQueue`对象的锁了。下面是`ConsumeMessageOrderlyService`类的代码：
```java
public class ConsumeMessageOrderlyService implements ConsumeMessageService {
    private static final InternalLogger log = ClientLogger.getLog();
    private final static long MAX_TIME_CONSUME_CONTINUOUSLY =
        Long.parseLong(System.getProperty("rocketmq.client.maxTimeConsumeContinuously", "60000"));
    private final DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;
    private final DefaultMQPushConsumer defaultMQPushConsumer;
    // 用户编写的消息处理逻辑
    private final MessageListenerOrderly messageListener;
    private final BlockingQueue<Runnable> consumeRequestQueue;
    private final ThreadPoolExecutor consumeExecutor;
    private final String consumerGroup;
    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
    private final ScheduledExecutorService scheduledExecutorService;
    private volatile boolean stopped = false;

    public ConsumeMessageOrderlyService(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,
        MessageListenerOrderly messageListener) {
        this.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;
        this.messageListener = messageListener;

        this.defaultMQPushConsumer = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();
        this.consumerGroup = this.defaultMQPushConsumer.getConsumerGroup();
        this.consumeRequestQueue = new LinkedBlockingQueue<Runnable>();

        this.consumeExecutor = new ThreadPoolExecutor(
            this.defaultMQPushConsumer.getConsumeThreadMin(), // 默认20
            this.defaultMQPushConsumer.getConsumeThreadMax(), // 默认20
            1000 * 60,
            TimeUnit.MILLISECONDS,
            this.consumeRequestQueue, // 无界队列
            new ThreadFactoryImpl("ConsumeMessageThread_"));

        // 单线程的线程池，专门用于提交消费请求
        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl("ConsumeMessageScheduledThread_"));
    }

    public void start() {
        // 集群模式下，每20秒向broker发送锁住所有正在消费的队列的请求
        if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) {
            this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
                @Override
                public void run() {
                    ConsumeMessageOrderlyService.this.lockMQPeriodically();
                }
            }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
        }
    }

    public void shutdown() {
        this.stopped = true;
        this.scheduledExecutorService.shutdown();
        this.consumeExecutor.shutdown();
        if (MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
            // 停止运行时解锁所有队列
            this.unlockAllMQ();
        }
    }

    public synchronized void unlockAllMQ() {
        this.defaultMQPushConsumerImpl.getRebalanceImpl().unlockAll(false);
    }

    @Override
    public void updateCorePoolSize(int corePoolSize) {
        if (corePoolSize > 0
            && corePoolSize <= Short.MAX_VALUE
            && corePoolSize < this.defaultMQPushConsumer.getConsumeThreadMax()) {
            this.consumeExecutor.setCorePoolSize(corePoolSize);
        }
    }

    @Override
    public void incCorePoolSize() {
    }

    @Override
    public void decCorePoolSize() {
    }

    @Override
    public int getCorePoolSize() {
        return this.consumeExecutor.getCorePoolSize();
    }

    @Override
    public ConsumeMessageDirectlyResult consumeMessageDirectly(MessageExt msg, String brokerName) {
        ConsumeMessageDirectlyResult result = new ConsumeMessageDirectlyResult();
        result.setOrder(true);

        List<MessageExt> msgs = new ArrayList<MessageExt>();
        msgs.add(msg);
        MessageQueue mq = new MessageQueue();
        mq.setBrokerName(brokerName);
        mq.setTopic(msg.getTopic());
        mq.setQueueId(msg.getQueueId());

        ConsumeOrderlyContext context = new ConsumeOrderlyContext(mq);

        this.defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, this.consumerGroup);

        final long beginTime = System.currentTimeMillis();

        log.info("consumeMessageDirectly receive new message: {}", msg);

        try {
            ConsumeOrderlyStatus status = this.messageListener.consumeMessage(msgs, context);
            if (status != null) {
                switch (status) {
                    case COMMIT:
                        result.setConsumeResult(CMResult.CR_COMMIT);
                        break;
                    case ROLLBACK:
                        result.setConsumeResult(CMResult.CR_ROLLBACK);
                        break;
                    case SUCCESS:
                        result.setConsumeResult(CMResult.CR_SUCCESS);
                        break;
                    case SUSPEND_CURRENT_QUEUE_A_MOMENT:
                        result.setConsumeResult(CMResult.CR_LATER);
                        break;
                    default:
                        break;
                }
            } else {
                result.setConsumeResult(CMResult.CR_RETURN_NULL);
            }
        } catch (Throwable e) {
            result.setConsumeResult(CMResult.CR_THROW_EXCEPTION);
            result.setRemark(RemotingHelper.exceptionSimpleDesc(e));

            log.warn(String.format("consumeMessageDirectly exception: %s Group: %s Msgs: %s MQ: %s",
                RemotingHelper.exceptionSimpleDesc(e),
                ConsumeMessageOrderlyService.this.consumerGroup,
                msgs,
                mq), e);
        }

        result.setAutoCommit(context.isAutoCommit());
        result.setSpentTimeMills(System.currentTimeMillis() - beginTime);

        log.info("consumeMessageDirectly Result: {}", result);

        return result;
    }

    @Override
    public void submitConsumeRequest(
        final List<MessageExt> msgs,
        final ProcessQueue processQueue,
        final MessageQueue messageQueue,
        final boolean dispathToConsume) {
        // 可以看ProcessQueue类的putMessage方法，dispathToConsume变量在传入的ProcessQueue对象还有待消费消息，并且ProcessQueue对象
        // 中的消息没有其它线程正在消费时为true
        if (dispathToConsume) {
            // 注意这里没有把msgs变量传到ConsumeRequest中，这点和ConsumeMessageConcurrentlyService的实现不一样，ConsumeMessageConcurrentlyService
            // 类会把每次拉取到的消息保存到其内部类ConsumeRequest中进行消费，而ConsumeMessageOrderlyService是每次拉取到消息后创建一个
            // ConsumeRequest对象对队列进行消费
            ConsumeRequest consumeRequest = new ConsumeRequest(processQueue, messageQueue);
            // 注意ConsumeMessageOrderlyService的消费线程池还是能够并发消费的
            this.consumeExecutor.submit(consumeRequest);
        }
    }

    public synchronized void lockMQPeriodically() {
        if (!this.stopped) {
            this.defaultMQPushConsumerImpl.getRebalanceImpl().lockAll();
        }
    }

    public void tryLockLaterAndReconsume(final MessageQueue mq, final ProcessQueue processQueue,
        final long delayMills) {
        this.scheduledExecutorService.schedule(new Runnable() {
            @Override
            public void run() {
                boolean lockOK = ConsumeMessageOrderlyService.this.lockOneMQ(mq);
                if (lockOK) {
                    ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, mq, 10);
                } else {
                    ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, mq, 3000);
                }
            }
        }, delayMills, TimeUnit.MILLISECONDS);
    }

    public synchronized boolean lockOneMQ(final MessageQueue mq) {
        if (!this.stopped) {
            return this.defaultMQPushConsumerImpl.getRebalanceImpl().lock(mq);
        }

        return false;
    }

    private void submitConsumeRequestLater(
        final ProcessQueue processQueue,
        final MessageQueue messageQueue,
        final long suspendTimeMillis
    ) {
        long timeMillis = suspendTimeMillis;
        if (timeMillis == -1) {
            timeMillis = this.defaultMQPushConsumer.getSuspendCurrentQueueTimeMillis();
        }

        if (timeMillis < 10) {
            timeMillis = 10;
        } else if (timeMillis > 30000) {
            timeMillis = 30000;
        }

        this.scheduledExecutorService.schedule(new Runnable() {

            @Override
            public void run() {
                ConsumeMessageOrderlyService.this.submitConsumeRequest(null, processQueue, messageQueue, true);
            }
        }, timeMillis, TimeUnit.MILLISECONDS);
    }

    public boolean processConsumeResult(
        final List<MessageExt> msgs,
        final ConsumeOrderlyStatus status,
        final ConsumeOrderlyContext context,
        final ConsumeRequest consumeRequest
    ) {
        boolean continueConsume = true;
        long commitOffset = -1L;

        // 默认为true
        if (context.isAutoCommit()) {
            switch (status) {
                case COMMIT:
                case ROLLBACK:
                    log.warn("the message queue consume result is illegal, we think you want to ack these message {}",
                        consumeRequest.getMessageQueue());
                case SUCCESS:
                    // commit方法返回消费结果对应的队列中正在被消费的消息的最大位移值 + 1
                    commitOffset = consumeRequest.getProcessQueue().commit();
                    // 记录统计信息
                    this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
                    break;
                case SUSPEND_CURRENT_QUEUE_A_MOMENT: // 如果消息需要过一段时间再消费
                    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
                    // 更新消息的消费次数
                    if (checkReconsumeTimes(msgs)) {
                        // 将消息重新保存到ProcessQueue对象，这样消息就能够重新被消费
                        consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);
                        // 默认1s后再次消费消息
                        this.submitConsumeRequestLater(
                            consumeRequest.getProcessQueue(),
                            consumeRequest.getMessageQueue(),
                            context.getSuspendCurrentQueueTimeMillis());
                        continueConsume = false;
                    } else {
                        commitOffset = consumeRequest.getProcessQueue().commit();
                    }
                    break;
                default:
                    break;
            }
        } else {
            // 如果不自动提交消息位移
            switch (status) {
                case SUCCESS:
                    // 只更新统计信息，不更新commitOffset的值
                    this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
                    break;
                case COMMIT:
                    // 说明消费结果要求提交消息位移
                    commitOffset = consumeRequest.getProcessQueue().commit();
                    break;
                case ROLLBACK:
                    // rollback方法重新消费所有正在消费的消息
                    consumeRequest.getProcessQueue().rollback();
                    this.submitConsumeRequestLater(
                        consumeRequest.getProcessQueue(),
                        consumeRequest.getMessageQueue(),
                        context.getSuspendCurrentQueueTimeMillis());
                    continueConsume = false;
                    break;
                case SUSPEND_CURRENT_QUEUE_A_MOMENT:
                    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
                    if (checkReconsumeTimes(msgs)) {
                        consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);
                        this.submitConsumeRequestLater(
                            consumeRequest.getProcessQueue(),
                            consumeRequest.getMessageQueue(),
                            context.getSuspendCurrentQueueTimeMillis());
                        continueConsume = false;
                    }
                    break;
                default:
                    break;
            }
        }

        // 提交消息位移
        if (commitOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
            this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false);
        }

        return continueConsume;
    }

    public ConsumerStatsManager getConsumerStatsManager() {
        return this.defaultMQPushConsumerImpl.getConsumerStatsManager();
    }

    // 消息消费失败时最大重试次数
    private int getMaxReconsumeTimes() {
        // default reconsume times: Integer.MAX_VALUE
        // 这里和ConsumeMessageConcurrentlyService的实现不一样了，ConsumeMessageConcurrentlyService类实际上没有实现getMaxReconsumeTimes方法
        // 其sendMessageBack方法直接调用的DefaultMQPushConsumerImpl类的实现，而ConsumeMessageOrderlyService自己实现了sendMessageBack
        // 即消息重试逻辑，重试时调用这里的方法获取最大重试次数，而默认maxReconsumeTimes的值就是-1，所以默认是无限重试，因为顺序消费时必须保证
        // 前面的消息消费成功了才能消费后面的
        if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {
            return Integer.MAX_VALUE;
        } else {
            return this.defaultMQPushConsumer.getMaxReconsumeTimes();
        }
    }

    private boolean checkReconsumeTimes(List<MessageExt> msgs) {
        boolean suspend = false;
        if (msgs != null && !msgs.isEmpty()) {
            for (MessageExt msg : msgs) {
                // 如果消息的重试次数超过了最大值，ConsumeMessageOrderlyService的getMaxReconsumeTimes方法默认不限制消息的最大重试次数
                if (msg.getReconsumeTimes() >= getMaxReconsumeTimes()) {
                    MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));
                    // 将消息发送给broker的retry topic，发送失败时返回false
                    if (!sendMessageBack(msg)) {
                        suspend = true;
                        msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
                    }
                } else {
                    suspend = true;
                    msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
                }
            }
        }
        return suspend;
    }

    public boolean sendMessageBack(final MessageExt msg) {
        try {
            // max reconsume times exceeded then send to dead letter queue.
            Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());
            String originMsgId = MessageAccessor.getOriginMessageId(msg);
            MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);
            newMsg.setFlag(msg.getFlag());
            MessageAccessor.setProperties(newMsg, msg.getProperties());
            MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());
            MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));
            MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));
            MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED);
            newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());

            this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);
            return true;
        } catch (Exception e) {
            log.error("sendMessageBack exception, group: " + this.consumerGroup + " msg: " + msg.toString(), e);
        }

        return false;
    }

    public void resetNamespace(final List<MessageExt> msgs) {
        for (MessageExt msg : msgs) {
            if (StringUtils.isNotEmpty(this.defaultMQPushConsumer.getNamespace())) {
                msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));
            }
        }
    }

    class ConsumeRequest implements Runnable {
        private final ProcessQueue processQueue;
        private final MessageQueue messageQueue;

        public ConsumeRequest(ProcessQueue processQueue, MessageQueue messageQueue) {
            this.processQueue = processQueue;
            this.messageQueue = messageQueue;
        }

        public ProcessQueue getProcessQueue() {
            return processQueue;
        }

        public MessageQueue getMessageQueue() {
            return messageQueue;
        }

        @Override
        public void run() {
            // 队列被取消消费时停止
            if (this.processQueue.isDropped()) {
                log.warn("run, the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
                return;
            }

            // 获取messageQueue对的lock
            final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);
            // 锁住messageQueue对象，DefaultMQPushConsumerImpl的实现不存在锁竞争，DefaultLitePullConsumerImpl中才会竞争这个锁
            synchronized (objLock) {
                // 如果是广播模式则不需要锁，直接消费，因为广播模式就不支持顺序消费。如果processQueue对象正在被锁并且锁没有超时（不一定是当前线程锁住的），也进行消息消费
                if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
                    || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {
                    // 开始消费的时间
                    final long beginTime = System.currentTimeMillis();
                    // 不断的循环消费
                    for (boolean continueConsume = true; continueConsume; ) {
                        // 检查队列是否被取消消费了
                        if (this.processQueue.isDropped()) {
                            log.warn("the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
                            break;
                        }

                        // 如果是集群模式并且processQueue对象没有被锁，则10毫秒后再尝试消费并停止循环
                        if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
                            && !this.processQueue.isLocked()) {
                            log.warn("the message queue not locked, so consume later, {}", this.messageQueue);
                            ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
                            break;
                        }

                        // 如果是集群模式并且processQueue对象的锁超时了，则10毫秒后再尝试消费并停止循环
                        if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
                            && this.processQueue.isLockExpired()) {
                            log.warn("the message queue lock expired, so consume later, {}", this.messageQueue);
                            ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
                            break;
                        }

                        long interval = System.currentTimeMillis() - beginTime;
                        // 如果循环时间超过60s，则10毫秒后再尝试消费并停止循环
                        if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {
                            ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10);
                            break;
                        }

                        // 获取一次最多能消费的消息数量
                        final int consumeBatchSize =
                            ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();

                        // 从processQueue对象获取还未消费的消息
                        List<MessageExt> msgs = this.processQueue.takeMessags(consumeBatchSize);
                        // 如果是retry topic，则恢复原来的topic，同时删除topic中可能存在的namespace前缀
                        defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup());
                        if (!msgs.isEmpty()) {
                            final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue);

                            ConsumeOrderlyStatus status = null;

                            ConsumeMessageContext consumeMessageContext = null;
                            if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {
                                consumeMessageContext = new ConsumeMessageContext();
                                consumeMessageContext
                                    .setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());
                                consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());
                                consumeMessageContext.setMq(messageQueue);
                                consumeMessageContext.setMsgList(msgs);
                                consumeMessageContext.setSuccess(false);
                                // init the consume context type
                                consumeMessageContext.setProps(new HashMap<String, String>());
                                ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);
                            }

                            long beginTimestamp = System.currentTimeMillis();
                            ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;
                            boolean hasException = false;
                            try {
                                // 锁住正在被消费的队列，这个锁的竞争在RebalancePushImpl类的removeUnnecessaryMessageQueue方法，
                                // 通过这个锁，保证了消息正在消费是，队列不会在负载均衡过程中从broker被解锁
                                this.processQueue.getLockConsume().lock();
                                // 队列被取消消费则停止
                                if (this.processQueue.isDropped()) {
                                    log.warn("consumeMessage, the message queue not be able to consume, because it's dropped. {}",
                                        this.messageQueue);
                                    break;
                                }

                                // 调用用户编写的消费者逻辑
                                status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);
                            } catch (Throwable e) {
                                log.warn("consumeMessage exception: {} Group: {} Msgs: {} MQ: {}",
                                    RemotingHelper.exceptionSimpleDesc(e),
                                    ConsumeMessageOrderlyService.this.consumerGroup,
                                    msgs,
                                    messageQueue);
                                hasException = true;
                            } finally {
                                this.processQueue.getLockConsume().unlock();
                            }

                            if (null == status
                                || ConsumeOrderlyStatus.ROLLBACK == status
                                || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {
                                log.warn("consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}",
                                    ConsumeMessageOrderlyService.this.consumerGroup,
                                    msgs,
                                    messageQueue);
                            }

                            long consumeRT = System.currentTimeMillis() - beginTimestamp;
                            if (null == status) {
                                if (hasException) {
                                    returnType = ConsumeReturnType.EXCEPTION; // 消费发送异常
                                } else {
                                    returnType = ConsumeReturnType.RETURNNULL; // 消费结果为null
                                }
                            } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) { // 消费超过60s
                                returnType = ConsumeReturnType.TIME_OUT;
                            } else if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) { // 消费逻辑请求过一段时间再消费
                                returnType = ConsumeReturnType.FAILED;
                            } else if (ConsumeOrderlyStatus.SUCCESS == status) { // 消费成功
                                returnType = ConsumeReturnType.SUCCESS;
                            }

                            // 保存消费结果类型到consumeMessageContext
                            if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {
                                consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());
                            }

                            // 消费结果为空时设置消费结果为下面的值，便于hook调用
                            if (null == status) {
                                status = ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;
                            }

                            if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {
                                consumeMessageContext.setStatus(status.toString());
                                consumeMessageContext
                                    .setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);
                                ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);
                            }

                            ConsumeMessageOrderlyService.this.getConsumerStatsManager()
                                .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);

                            // 处理消费结果，根据结果判断是否再次循环进行消费
                            continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this);
                        } else {
                            continueConsume = false;
                        }
                    }
                } else {
                    if (this.processQueue.isDropped()) {
                        log.warn("the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
                        return;
                    }

                    ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);
                }
            }
        }

    }

}
```

`ConsumeMessageOrderlyService`类的实现从`submitConsumeRequest()`方法开始分析：
```java
@Override
public void submitConsumeRequest(
    final List<MessageExt> msgs,
    final ProcessQueue processQueue,
    final MessageQueue messageQueue,
    final boolean dispathToConsume) {
    // 可以看ProcessQueue类的putMessage方法，dispathToConsume变量在传入的ProcessQueue对象还有待消费消息，并且ProcessQueue对象
    // 中的消息没有其它线程正在消费时为true
    if (dispathToConsume) {
        // 注意这里没有把msgs变量传到ConsumeRequest中，这点和ConsumeMessageConcurrentlyService的实现不一样，ConsumeMessageConcurrentlyService
        // 类会把每次拉取到的消息保存到其内部类ConsumeRequest中进行消费，而ConsumeMessageOrderlyService是每次拉取到消息后创建一个
        // ConsumeRequest对象对队列进行消费
        ConsumeRequest consumeRequest = new ConsumeRequest(processQueue, messageQueue);
        // 注意ConsumeMessageOrderlyService的消费线程池还是能够并发消费的
        this.consumeExecutor.submit(consumeRequest);
    }
}
```

`ConsumeMessageOrderlyService`类的`submitConsumeRequest()`方法在`dispathToConsume`变量为true时才进行消息消费，`dispathToConsume`变量是`ProcessQueue`类的`putMessage()`方法的返回值，该方法在每次拉取到消息后被调用：
```java
public boolean putMessage(final List<MessageExt> msgs) {
    boolean dispatchToConsume = false;
    try {
        this.lockTreeMap.writeLock().lockInterruptibly();
        try {
            int validMsgCnt = 0;
            for (MessageExt msg : msgs) {
                // 以消息位移为key，消息为value
                MessageExt old = msgTreeMap.put(msg.getQueueOffset(), msg);
                // old为空说明消息还没有被拉取过，否则说明消息被当前消费者重复拉取了
                if (null == old) {
                    // 记录非重复的消息数量
                    validMsgCnt++;
                    // 更新拉取到的消息的位移的最大值
                    this.queueOffsetMax = msg.getQueueOffset();
                    // 更新拉取到的消息总大小
                    msgSize.addAndGet(msg.getBody().length);
                }
            }
            // 更新拉取到的消息的总数
            msgCount.addAndGet(validMsgCnt);

            // this.consuming变量表示当前队列是否有消息正在被消费，主要用于ConsumeMessageOrderlyService类，当当前队列有消息正在
            // 被消费时，this.consuming为true，此时dispatchToConsume为false，则ConsumeMessageOrderlyService类的submitConsumeRequest
            // 方法不会再对当前队列创建ConsumeRequest对象执行消费逻辑
            if (!msgTreeMap.isEmpty() && !this.consuming) {
                dispatchToConsume = true;
                this.consuming = true;
            }

            if (!msgs.isEmpty()) {
                MessageExt messageExt = msgs.get(msgs.size() - 1);
                // 获取broker中这次拉取消息请求对应的队列保存的消息的最大位移
                String property = messageExt.getProperty(MessageConst.PROPERTY_MAX_OFFSET);
                if (property != null) {
                    // 计算上面获取到的broker中的位移值和这次拉取到的消息的最大位移值的差，相当于计算还有多少消息位移没有被消费
                    long accTotal = Long.parseLong(property) - messageExt.getQueueOffset();
                    if (accTotal > 0) {
                        this.msgAccCnt = accTotal;
                    }
                }
            }
        } finally {
            this.lockTreeMap.writeLock().unlock();
        }
    } catch (InterruptedException e) {
        log.error("putMessage exception", e);
    }

    return dispatchToConsume;
}
```

`putMessage()`方法在`ProcessQueue`对象中存在等待被消费的消息，并且没有线程对`ProcessQueue`对象的消息进行消费时返回true，而这种情况下`ConsumeMessageOrderlyService`类的`submitConsumeRequest()`方法才会执行下面的逻辑：
```java
// 注意这里没有把msgs变量传到ConsumeRequest中，这点和ConsumeMessageConcurrentlyService的实现不一样，ConsumeMessageConcurrentlyService
// 类会把每次拉取到的消息保存到其内部类ConsumeRequest中进行消费，而ConsumeMessageOrderlyService是每次拉取到消息后创建一个
// ConsumeRequest对象对队列进行消费
ConsumeRequest consumeRequest = new ConsumeRequest(processQueue, messageQueue);
// 注意ConsumeMessageOrderlyService的消费线程池还是能够并发消费的
this.consumeExecutor.submit(consumeRequest);
```

即对一个队列进行消费，`ConsumeRequest`类是`ConsumeMessageOrderlyService`类的内部类，其实现了`Runnable`接口，下面看看该类的实现：
```java
class ConsumeRequest implements Runnable {
    private final ProcessQueue processQueue;
    private final MessageQueue messageQueue;

    public ConsumeRequest(ProcessQueue processQueue, MessageQueue messageQueue) {
        this.processQueue = processQueue;
        this.messageQueue = messageQueue;
    }

    public ProcessQueue getProcessQueue() {
        return processQueue;
    }

    public MessageQueue getMessageQueue() {
        return messageQueue;
    }

    @Override
    public void run() {
        // 队列被取消消费时停止
        if (this.processQueue.isDropped()) {
            log.warn("run, the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
            return;
        }

        // 获取messageQueue对的lock
        final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);
        // 锁住messageQueue对象，DefaultMQPushConsumerImpl的实现不存在锁竞争，DefaultLitePullConsumerImpl中才会竞争这个锁
        synchronized (objLock) {
            // 如果是广播模式则不需要锁，直接消费，因为广播模式就不支持顺序消费。如果processQueue对象正在被锁并且锁没有超时（不一定是当前线程锁住的），也进行消息消费
            if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
                || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {
                // 开始消费的时间
                final long beginTime = System.currentTimeMillis();
                // 不断的循环消费
                for (boolean continueConsume = true; continueConsume; ) {
                    // 检查队列是否被取消消费了
                    if (this.processQueue.isDropped()) {
                        log.warn("the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
                        break;
                    }

                    // 如果是集群模式并且processQueue对象没有被锁，则10毫秒后再尝试消费并停止循环
                    if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
                        && !this.processQueue.isLocked()) {
                        log.warn("the message queue not locked, so consume later, {}", this.messageQueue);
                        ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
                        break;
                    }

                    // 如果是集群模式并且processQueue对象的锁超时了，则10毫秒后再尝试消费并停止循环
                    if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
                        && this.processQueue.isLockExpired()) {
                        log.warn("the message queue lock expired, so consume later, {}", this.messageQueue);
                        ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
                        break;
                    }

                    long interval = System.currentTimeMillis() - beginTime;
                    // 如果循环时间超过60s，则10毫秒后再尝试消费并停止循环
                    if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {
                        ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10);
                        break;
                    }

                    // 获取一次最多能消费的消息数量
                    final int consumeBatchSize =
                        ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();

                    // 从processQueue对象获取还未消费的消息
                    List<MessageExt> msgs = this.processQueue.takeMessags(consumeBatchSize);
                    // 如果是retry topic，则恢复原来的topic，同时删除topic中可能存在的namespace前缀
                    defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup());
                    if (!msgs.isEmpty()) {
                        final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue);

                        ConsumeOrderlyStatus status = null;

                        ConsumeMessageContext consumeMessageContext = null;
                        if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {
                            consumeMessageContext = new ConsumeMessageContext();
                            consumeMessageContext
                                .setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());
                            consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());
                            consumeMessageContext.setMq(messageQueue);
                            consumeMessageContext.setMsgList(msgs);
                            consumeMessageContext.setSuccess(false);
                            // init the consume context type
                            consumeMessageContext.setProps(new HashMap<String, String>());
                            ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);
                        }

                        long beginTimestamp = System.currentTimeMillis();
                        ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;
                        boolean hasException = false;
                        try {
                            // 锁住正在被消费的队列，这个锁的竞争在RebalancePushImpl类的removeUnnecessaryMessageQueue方法，
                            // 通过这个锁，保证了消息正在消费是，队列不会在负载均衡过程中从broker被解锁
                            this.processQueue.getLockConsume().lock();
                            // 队列被取消消费则停止
                            if (this.processQueue.isDropped()) {
                                log.warn("consumeMessage, the message queue not be able to consume, because it's dropped. {}",
                                    this.messageQueue);
                                break;
                            }

                            // 调用用户编写的消费者逻辑
                            status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);
                        } catch (Throwable e) {
                            log.warn("consumeMessage exception: {} Group: {} Msgs: {} MQ: {}",
                                RemotingHelper.exceptionSimpleDesc(e),
                                ConsumeMessageOrderlyService.this.consumerGroup,
                                msgs,
                                messageQueue);
                            hasException = true;
                        } finally {
                            this.processQueue.getLockConsume().unlock();
                        }

                        if (null == status
                            || ConsumeOrderlyStatus.ROLLBACK == status
                            || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {
                            log.warn("consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}",
                                ConsumeMessageOrderlyService.this.consumerGroup,
                                msgs,
                                messageQueue);
                        }

                        long consumeRT = System.currentTimeMillis() - beginTimestamp;
                        if (null == status) {
                            if (hasException) {
                                returnType = ConsumeReturnType.EXCEPTION; // 消费发送异常
                            } else {
                                returnType = ConsumeReturnType.RETURNNULL; // 消费结果为null
                            }
                        } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) { // 消费超过60s
                            returnType = ConsumeReturnType.TIME_OUT;
                        } else if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) { // 消费逻辑请求过一段时间再消费
                            returnType = ConsumeReturnType.FAILED;
                        } else if (ConsumeOrderlyStatus.SUCCESS == status) { // 消费成功
                            returnType = ConsumeReturnType.SUCCESS;
                        }

                        // 保存消费结果类型到consumeMessageContext
                        if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {
                            consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());
                        }

                        // 消费结果为空时设置消费结果为下面的值，便于hook调用
                        if (null == status) {
                            status = ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;
                        }

                        if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {
                            consumeMessageContext.setStatus(status.toString());
                            consumeMessageContext
                                .setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);
                            ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);
                        }

                        ConsumeMessageOrderlyService.this.getConsumerStatsManager()
                            .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);

                        // 处理消费结果，根据结果判断是否再次循环进行消费
                        continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this);
                    } else {
                        continueConsume = false;
                    }
                }
            } else {
                if (this.processQueue.isDropped()) {
                    log.warn("the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
                    return;
                }

                ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);
            }
        }
    }

}
```

`ConsumeRequest`类的任务是对一个队列进行消费，其消费的逻辑是，开启一个循环，每次循环时调用`ProcessQueue`类的`takeMessags()`方法获取需要被消费的消息，之后获取`ProcessQueue`对象的`lockConsume`这个lock，再执行`MessageListenerOrderly`对象的`consumeMessage()`方法，即用户编写的消费消息逻辑。在消息消费完成后，调用`processConsumeResult()`方法处理消费结果：
```java
public boolean processConsumeResult(
    final List<MessageExt> msgs,
    final ConsumeOrderlyStatus status,
    final ConsumeOrderlyContext context,
    final ConsumeRequest consumeRequest
) {
    boolean continueConsume = true;
    long commitOffset = -1L;

    // 默认为true
    if (context.isAutoCommit()) {
        switch (status) {
            case COMMIT:
            case ROLLBACK:
                log.warn("the message queue consume result is illegal, we think you want to ack these message {}",
                    consumeRequest.getMessageQueue());
            case SUCCESS:
                // commit方法返回消费结果对应的队列中正在被消费的消息的最大位移值 + 1
                commitOffset = consumeRequest.getProcessQueue().commit();
                // 记录统计信息
                this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
                break;
            case SUSPEND_CURRENT_QUEUE_A_MOMENT: // 如果消息需要过一段时间再消费
                this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
                // 更新消息的消费次数
                if (checkReconsumeTimes(msgs)) {
                    // 将消息重新保存到ProcessQueue对象，这样消息就能够重新被消费
                    consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);
                    // 默认1s后再次消费消息
                    this.submitConsumeRequestLater(
                        consumeRequest.getProcessQueue(),
                        consumeRequest.getMessageQueue(),
                        context.getSuspendCurrentQueueTimeMillis());
                    continueConsume = false;
                } else {
                    commitOffset = consumeRequest.getProcessQueue().commit();
                }
                break;
            default:
                break;
        }
    } else {
        // 如果不自动提交消息位移
        switch (status) {
            case SUCCESS:
                // 只更新统计信息，不更新commitOffset的值
                this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
                break;
            case COMMIT:
                // 说明消费结果要求提交消息位移
                commitOffset = consumeRequest.getProcessQueue().commit();
                break;
            case ROLLBACK:
                // rollback方法重新消费所有正在消费的消息
                consumeRequest.getProcessQueue().rollback();
                this.submitConsumeRequestLater(
                    consumeRequest.getProcessQueue(),
                    consumeRequest.getMessageQueue(),
                    context.getSuspendCurrentQueueTimeMillis());
                continueConsume = false;
                break;
            case SUSPEND_CURRENT_QUEUE_A_MOMENT:
                this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
                if (checkReconsumeTimes(msgs)) {
                    consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);
                    this.submitConsumeRequestLater(
                        consumeRequest.getProcessQueue(),
                        consumeRequest.getMessageQueue(),
                        context.getSuspendCurrentQueueTimeMillis());
                    continueConsume = false;
                }
                break;
            default:
                break;
        }
    }

    // 提交消息位移
    if (commitOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
        this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false);
    }

    return continueConsume;
}
```

上面的实现并不复杂，消费成功时提交消息位移并返回true表示应该继续消费消息，消费失败时会重新保存消息到`ProcessQueue`类并提交定时任务，在1s后重新消费消息，再返回false终止当前的消费过程。

上面的分析中涉及到的一些方法没有展开说，不过方法中已经有了相关注释，这里不再赘述。关于顺序消息的实现，总结一下就是`ConsumeMessageOrderlyService`类会初始化一个多线程的线程池执行消息消费逻辑，所以`ConsumeMessageOrderlyService`类还是有并发能力的，只不过该类保证了一个队列只会被一个线程消费，保证这一点的实现是在`DefaultMQPushConsumerImpl`类的`pullMessage()`方法拉取到消息后，会调用`ProcessQueue`类的`putMessage()`方法保存拉取到的消息到指定队列，该方法通过`consuming`属性判断该队列的消息是否正在被某个线程消费，如果是的话则拉取到的消息只会被保存到`ProcessQueue`对象而不会创建新的进行消费，同时`ConsumeMessageOrderlyService`类的`ConsumeRequest`类在执行消费逻辑时，还会获取其正在消费的`ProcessQueue`对象的`lockConsume`这个lock，这个lock就是前面说的负载均衡过程中解锁队列时需要获取的锁，对应的方法是`RebalancePushImpl`类的`removeUnnecessaryMessageQueue()`方法：
```java
@Override
public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {
    // 持久化即将被移除的MessageQueue的消费位移，对于RemoteBrokerOffsetStore的实现，就是将消费位移提交到broker
    this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);
    // 清除offsetStore中MessageQueue的数据
    this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);
    // 如果是顺序消息并且是集群模式
    if (this.defaultMQPushConsumerImpl.isConsumeOrderly()
        && MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
        try {
            // 尝试获取锁，最多等待1秒
            if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) {
                try {
                    // 发送解锁consumeQueue的请求到broker
                    return this.unlockDelay(mq, pq);
                } finally {
                    pq.getLockConsume().unlock();
                }
            } else {
                log.warn("[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}",
                    mq,
                    pq.getTryUnlockTimes());

                // 如果加锁失败，说明当前MessageQueue的消息还在被消费中，此时记录加锁失败的次数，不做其他操作
                // 获取锁时已经尝试等待1秒了，所以通常不会发生这种情况，如果发生了，只能等下次负载均衡时再来一遍
                // 解锁逻辑
                pq.incTryUnlockTimes();
            }
        } catch (Exception e) {
            log.error("removeUnnecessaryMessageQueue Exception", e);
        }

        return false;
    }
    return true;
}
```

通过`lockConsume`这个lock，保证了消息正在消费时，对应的队列不会被解锁，这就保证了只会有一个消费者对一个队列进行消费。

以上是顺序消息的实现。