顺序消息能够保证消息被有序的消费，消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的，RocketMQ可以严格的保证消息有序。

实现顺序消息，rocketmq需要解决三个问题：
#### 异步发送消息可能会导致消息最终保存在Broker的时间不一致，后发送的消息可能先被保存到broker，使得消息存储顺序和发送顺序不一致
解决方案：采取同步发送的方式按照顺序发送消息

#### 默认消息的发送是同步的，但是默认是轮询队列的方式发送消息，使得消息会存储到不同的队列中，这就无法保证消息被消费的顺序
解决方案：同步发送消息 + `MessageQueueSelector`实现一个业务的消息被存储在一个队列中

#### 消费者负载均衡20s执行一次，消费者A从队列X拉取到5条消息后，由于消费者A的负载过高，不能及时消费这些消息，消费堆积在内存中，此时重新更新了负载策略，队列X分给了消费者B，消费者B拉取到了第6到10条消息，并且消费者B负载低，直接消费编号6到10的消息，而编号1-5的消息还堆积在消费者A的内存中，此时消息的顺序就乱了
解决方案：通过分布式锁锁住队列，并且每次消费者变更消费的队列时，必须确保消息全部被消费完了，才可以释放锁

上面是在rocketmq中顺序消息的实现，下面来分析这些点。

## 按照顺序同步发送消息
只需要生产者按照如下代码发送消息即可：
```java
String[] tags = new String[] {"TagA", "TagB", "TagC", "TagD", "TagE"};
for (int i = 0; i < 100; i++) {
    // 模拟业务ID
    int orderId = i % 10;
    // 创建消息
    Message msg =
        new Message("TopicTestjjj", tags[i % tags.length], "KEY" + i,
            ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
    // 同步发送消息，使用MessageQueueSelector对象进行队列的选择，选择的依据是业务ID
    SendResult sendResult = producer.send(msg, new MessageQueueSelector() {
        @Override
        public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
            // 这里的arg实际上就是orderId
            Integer id = (Integer) arg;
            int index = id % mqs.size();
            return mqs.get(index);
        }
    }, orderId);

    System.out.printf("%s%n", sendResult);
}
```

这种发送方式和普通的消息发送区别只在于添加了一个`MessageQueueSelector`接口的实现类，实现了选择队列的逻辑，保证同一个业务下的消息被发到同一个队列，而普通的发送方式默认轮训选择队列，关于消息发送的过程可以看笔记[如何实现消息发送](如何实现消息发送.md)。

## 消费者锁住队列
消费者执行负载均衡时会按照负载均衡策略判断其应该消费的队列，根据笔记[如何实现负载均衡](如何实现负载均衡.md)可知，负载均衡的队列选择对应的代码在`RebalanceImpl`类的`rebalanceByTopic()`方法：
```java
private void rebalanceByTopic(final String topic, final boolean isOrder) {
    switch (messageModel) {
        case BROADCASTING: {
            // 略...
        }
        case CLUSTERING: {
            // 略

            if (mqSet != null && cidAll != null) {
                // 略

                // allocateResultSet保存了所有根据负载均衡策略分配到的MessageQueue对象
                boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);
                // 如果这次的负载均衡和上次的结果有变化（新增或移除了需要消费的MessageQueue）
                if (changed) {
                    // 记录下这次负载均衡的结果
                    log.info(
                        "rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}",
                        strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),
                        allocateResultSet.size(), allocateResultSet);
                    // messageQueueChanged方法会根据这次负载均衡的结果更新流控的配置，并发送心跳给broker
                    this.messageQueueChanged(topic, mqSet, allocateResultSet);
                }
            }
            break;
        }
        default:
            break;
    }
}
```

在根据`AllocateMessageQueueStrategy`选择到当前消费者负责的队列后，还需要调用`updateProcessQueueTableInRebalance()`方法对选择的队列进行处理，而`updateProcessQueueTableInRebalance()`方法中的`isOrder`参数用于判断当前消费者是否是顺序消费消息，判断的依据很简单：
```java
// ConsumeMessageService负责持有和配置消费消息的线程池
if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {
    this.consumeOrderly = true;
    this.consumeMessageService =
        new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
} else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {
    this.consumeOrderly = false;
    this.consumeMessageService =
        new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
}
```

上面的语句在`DefaultMQPushConsumerImpl`类的`start()`方法，其中`this.consumeOrderly`的值就是`updateProcessQueueTableInRebalance()`方法中`isOrder`参数的值，而一个顺序消费的消费者，通常是按照如下模式消费消息的：
```java
consumer.registerMessageListener(new MessageListenerOrderly() {
    @Override
    public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {
        // 略
    }
})
```

所以顺序消费的消息的`isOrder`参数为true，这些内容可以看笔记[如何实现消息消费](如何实现消息消费.md)中看到，下面再看看`updateProcessQueueTableInRebalance()`方法中的处理：
```java
private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet,
    final boolean isOrder) {
    boolean changed = false;

    // 略...

    List<PullRequest> pullRequestList = new ArrayList<PullRequest>();
    // mqSet保存在这次负载均衡分配到的所有MessageQueue对象
    for (MessageQueue mq : mqSet) {
        // 如果上一次负载均衡后当前的MessageQueue对象没有分配给当前RebalanceImpl对象所在的DefaultMQPushConsumerImpl对象
        // 则在下面创建这次新分配到的MessageQueue对象对应的PullRequest
        if (!this.processQueueTable.containsKey(mq)) {
            // 顺序消息锁住当前的MessageQueue，也就是对应的Broker中的consumeQueue，从上面removeUnnecessaryMessageQueue方法
            // 的实现可以看出，锁是可能加不上的，此时记录日志，跳过这个分配到的MessageQueue
            if (isOrder && !this.lock(mq)) {
                log.warn("doRebalance, {}, add a new mq failed, {}, because lock failed", consumerGroup, mq);
                continue;
            }

            // 清除OffsetStore中保存的MessageQueue的消费位移，确保新分配的MessageQueue不会被旧数据影响
            this.removeDirtyOffset(mq);
            // ProcessQueue表示当前MessageQueue对象在当前消费者的消费情况，通过ProcessQueue对象能够判断是否需要触发消费者
            // 流控
            ProcessQueue pq = new ProcessQueue();
            // 根据DefaultMQPushConsumer对象的ConsumeFromWhere配置获取消费位移
            long nextOffset = this.computePullFromWhere(mq);
            if (nextOffset >= 0) {
                ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);
                if (pre != null) {
                    log.info("doRebalance, {}, mq already exists, {}", consumerGroup, mq);
                } else {
                    log.info("doRebalance, {}, add a new mq, {}", consumerGroup, mq);
                    // 创建当前MessageQueue对应的PullRequest
                    PullRequest pullRequest = new PullRequest();
                    pullRequest.setConsumerGroup(consumerGroup);
                    pullRequest.setNextOffset(nextOffset);
                    pullRequest.setMessageQueue(mq);
                    pullRequest.setProcessQueue(pq);
                    pullRequestList.add(pullRequest);
                    changed = true;
                }
            } else {
                log.warn("doRebalance, {}, add new mq failed, {}", consumerGroup, mq);
            }
        }
    }

    // pullRequestList保存了这次负载均衡新分配到的所有MessageQueue对应的PullRequest（不包括已经分配到的MessageQueue）
    // 这里开始针对这些PullRequest执行拉取消息操作
    this.dispatchPullRequest(pullRequestList);

    return changed;
}
```

`updateProcessQueueTableInRebalance()`方法会为新分配的队列执行`lock()`方法，该方法会向broker发送锁住队列的请求，代码：
```java
public boolean lock(final MessageQueue mq) {
    // 获取指定brokerName的master broker
    FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);
    if (findBrokerResult != null) {
        LockBatchRequestBody requestBody = new LockBatchRequestBody();
        requestBody.setConsumerGroup(this.consumerGroup);
        requestBody.setClientId(this.mQClientFactory.getClientId());
        requestBody.getMqSet().add(mq);

        try {
            // 向broker发送锁住队列的请求
            Set<MessageQueue> lockedMq =
                this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);
            for (MessageQueue mmqq : lockedMq) {
                ProcessQueue processQueue = this.processQueueTable.get(mmqq);
                if (processQueue != null) {
                    processQueue.setLocked(true);
                    processQueue.setLastLockTimestamp(System.currentTimeMillis());
                }
            }

            boolean lockOK = lockedMq.contains(mq);
            log.info("the message queue lock {}, {} {}",
                lockOK ? "OK" : "Failed",
                this.consumerGroup,
                mq);
            return lockOK;
        } catch (Exception e) {
            log.error("lockBatchMQ exception, " + mq, e);
        }
    }

    return false;
}
```

`lock()`方法将当前队列添加到请求中，并通过`lockBatchMQ()`方法发送`RequestCode.LOCK_BATCH_MQ`请求，对于该请求，broker端的处理在`AdminBrokerProcessor`类的`lockBatchMQ()`方法：
```java
private RemotingCommand lockBatchMQ(ChannelHandlerContext ctx,
    RemotingCommand request) throws RemotingCommandException {
    final RemotingCommand response = RemotingCommand.createResponseCommand(null);
    LockBatchRequestBody requestBody = LockBatchRequestBody.decode(request.getBody(), LockBatchRequestBody.class);

    Set<MessageQueue> lockOKMQSet = this.brokerController.getRebalanceLockManager().tryLockBatch(
        requestBody.getConsumerGroup(),
        requestBody.getMqSet(),
        requestBody.getClientId());

    LockBatchResponseBody responseBody = new LockBatchResponseBody();
    responseBody.setLockOKMQSet(lockOKMQSet);

    response.setBody(responseBody.encode());
    response.setCode(ResponseCode.SUCCESS);
    response.setRemark(null);
    return response;
}
```

执行锁队列逻辑的是`RebalanceLockManager`类的`tryLockBatch()`方法：
```java
public Set<MessageQueue> tryLockBatch(final String group, final Set<MessageQueue> mqs,
    final String clientId) {
    Set<MessageQueue> lockedMqs = new HashSet<MessageQueue>(mqs.size());
    Set<MessageQueue> notLockedMqs = new HashSet<MessageQueue>(mqs.size());

    // 遍历消费者请求需要锁住的队列
    for (MessageQueue mq : mqs) {
        // 判断当前消费者是否已经持有了队列的锁
        if (this.isLocked(group, mq, clientId)) {
            lockedMqs.add(mq);
        } else {
            // 没有则添加到notLockedMqs等待后续处理
            notLockedMqs.add(mq);
        }
    }

    // notLockedMqs为没有被当前消费者锁的队列
    if (!notLockedMqs.isEmpty()) {
        try {
            this.lock.lockInterruptibly();
            try {
                // mqLockTable保存了所有消费者组的队列锁状态，key为队列，value的LockEntry对象保存了持有队列锁的消费者id
                ConcurrentHashMap<MessageQueue, LockEntry> groupValue = this.mqLockTable.get(group);
                if (null == groupValue) {
                    groupValue = new ConcurrentHashMap<>(32);
                    this.mqLockTable.put(group, groupValue);
                }

                for (MessageQueue mq : notLockedMqs) {
                    LockEntry lockEntry = groupValue.get(mq);
                    // 如果lockEntry为null说明该队列还没有被锁
                    if (null == lockEntry) {
                        lockEntry = new LockEntry();
                        // 设置当前队列被当前消费者持有锁
                        lockEntry.setClientId(clientId);
                        groupValue.put(mq, lockEntry);
                        log.info(
                            "tryLockBatch, message queue not locked, I got it. Group: {} NewClientId: {} {}",
                            group,
                            clientId,
                            mq);
                    }

                    // 如果该队列已经被当前消费者锁住了，更新锁的时间，通过LockEntry类的isLocked方法可以发现，队列的锁是有有
                    // 效期的，默认60s，而消费者端的ConsumeMessageOrderlyService类每隔20s也会申请锁住所有其所在消费者分配到的
                    // 队列，以此更新broker中锁的有效期（消费者负载均衡是，新分配到的队列也会发起锁队列请求）
                    if (lockEntry.isLocked(clientId)) {
                        lockEntry.setLastUpdateTimestamp(System.currentTimeMillis());
                        // 保存成功锁住的队列
                        lockedMqs.add(mq);
                        continue;
                    }

                    // 获取原来持有当前队列的锁的消费者id
                    String oldClientId = lockEntry.getClientId();

                    // 如果原来的消费者持有的锁过期了，更新锁为当前消费者持有
                    if (lockEntry.isExpired()) {
                        lockEntry.setClientId(clientId);
                        lockEntry.setLastUpdateTimestamp(System.currentTimeMillis());
                        log.warn(
                            "tryLockBatch, message queue lock expired, I got it. Group: {} OldClientId: {} NewClientId: {} {}",
                            group,
                            oldClientId,
                            clientId,
                            mq);
                        // 保存成功锁住的队列
                        lockedMqs.add(mq);
                        continue;
                    }

                    log.warn(
                        "tryLockBatch, message queue locked by other client. Group: {} OtherClientId: {} NewClientId: {} {}",
                        group,
                        oldClientId,
                        clientId,
                        mq);
                }
            } finally {
                this.lock.unlock();
            }
        } catch (InterruptedException e) {
            log.error("putMessage exception", e);
        }
    }

    // 返回成功锁住的队列
    return lockedMqs;
}
```

`tryLockBatch()`方法遍历需要锁住的队列，在队列没有被其它消费者锁住，或者锁过期的情况下，设置当前消费者为新的锁的持有者，并返回成功加锁的队列。回到`RebalanceImpl`类的`updateProcessQueueTableInRebalance()`方法，只有成功加锁的情况下，`updateProcessQueueTableInRebalance()`方法才会针对队列创建`PullRequest`对象，执行拉取消息逻辑，关于`PullRequest`对象和执行拉取消息逻辑，可以看笔记[如何实现消息消费](如何实现消息消费.md)。

以上是消息对队列加锁的实现，保证了顺序消费的情况下，一个队列在被某个消费者锁住的情况下，其它消费者在负载均衡时也不会消费该队列。下面再看看顺序消费的情况下，是如何释放锁的。对应的解锁过程发生在`RebalanceImpl`类的`updateProcessQueueTableInRebalance()`方法：
```java
private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet,
    final boolean isOrder) {
    boolean changed = false;

    // processQueueTable保存了上一次负载均衡后分配到的MessageQueue及对应的ProcessQueue
    Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<MessageQueue, ProcessQueue> next = it.next();
        MessageQueue mq = next.getKey();
        ProcessQueue pq = next.getValue();

        if (mq.getTopic().equals(topic)) {
            // 如果这次负载均衡没有分配到该MessageQueue
            if (!mqSet.contains(mq)) {
                // 标记ProcessQueue的dropped属性为true
                pq.setDropped(true);
                // removeUnnecessaryMessageQueue方法会提交并清除消费位移，对于顺序消费，会向broker发送解锁consumeQueue的请求
                if (this.removeUnnecessaryMessageQueue(mq, pq)) {
                    // 解锁成功则从processQueueTable中移除该MessageQueue
                    it.remove();
                    changed = true;
                    log.info("doRebalance, {}, remove unnecessary mq, {}", consumerGroup, mq);
                }
                // 当前MessageQueue在上次负载均衡时也被分配到了当前消费者，并且当前MessageQueue的上次拉取消息时间到当前时间的
                // 时间差超过了阈值（默认2分钟）
            } else if (pq.isPullExpired()) {
                switch (this.consumeType()) {
                    case CONSUME_ACTIVELY: // CONSUME_ACTIVELY表示消费者的拉取策略是pull
                        break;
                    case CONSUME_PASSIVELY: // CONSUME_PASSIVELY表示消费者的拉取策略是push
                        // 拉取消息超时了就标记ProcessQueue的dropped属性为true，表示当前消费者不再消费该ProcessQueue对应的
                        // MessageQueue（也就是broker中对应的consumeQueue）
                        pq.setDropped(true);
                        // 既然放弃消费当前MessageQueue，就要提交并移除消费位移，同时对于顺序消费的情况，尝试释放锁
                        if (this.removeUnnecessaryMessageQueue(mq, pq)) {
                            it.remove();
                            changed = true;
                            log.error("[BUG]doRebalance, {}, remove unnecessary mq, {}, because pull is pause, so try to fixed it",
                                consumerGroup, mq);
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    }

    // 略...
}
```

`updateProcessQueueTableInRebalance()`方法的参数`mqSet`为一次负载均衡时根据负载均衡策略分配到的队列集合，`updateProcessQueueTableInRebalance()`方法对比分配结果和当前其正在消费的队列，如果发现有个正在消费的队列不在`mqSet`中，或者拉取消息超时了，则会调用`removeUnnecessaryMessageQueue()`方法取消消费队列，`removeUnnecessaryMessageQueue()`方法代码：
```java
@Override
public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {
    // 持久化即将被移除的MessageQueue的消费位移，对于RemoteBrokerOffsetStore的实现，就是将消费位移提交到broker
    this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);
    // 清除offsetStore中MessageQueue的数据
    this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);
    // 如果是顺序消息并且是集群模式
    if (this.defaultMQPushConsumerImpl.isConsumeOrderly()
        && MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
        try {
            // 尝试获取锁，最多等待1秒
            if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) {
                try {
                    // 发送解锁consumeQueue的请求到broker
                    return this.unlockDelay(mq, pq);
                } finally {
                    pq.getLockConsume().unlock();
                }
            } else {
                log.warn("[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}",
                    mq,
                    pq.getTryUnlockTimes());

                // 如果加锁失败，说明当前MessageQueue的消息还在被消费中，此时记录加锁失败的次数，不做其他操作
                // 获取锁时已经尝试等待1秒了，所以通常不会发生这种情况，如果发生了，只能等下次负载均衡时再来一遍
                // 解锁逻辑
                pq.incTryUnlockTimes();
            }
        } catch (Exception e) {
            log.error("removeUnnecessaryMessageQueue Exception", e);
        }

        return false;
    }
    return true;
}
```

`removeUnnecessaryMessageQueue()`方法的实现已经在注释中说明了，需要注意的是，`removeUnnecessaryMessageQueue()`方法在释放队列锁时会先回去`ProcessQueue`对象的锁，在获取成功之后才会调用`unlockDelay()`方法向broker取消锁定队列，`ProcessQueue`对象表示一个`MessageQueue`对象（也就是某个队列）在当前消费者的消费情况，比如通过`ProcessQueue`对象能够判断是否需要触发消费者流控，`ProcessQueue`对象的创建可以看笔记[如何实现消息消费](如何实现消息消费.md)。这里先看看`unlockDelay()`方法的实现：
```java
private boolean unlockDelay(final MessageQueue mq, final ProcessQueue pq) {

    // 判断当前ProcessQueue对象中是否还有从broker拉取下来后还没有消费完的消息
    if (pq.hasTempMessage()) {
        log.info("[{}]unlockDelay, begin {} ", mq.hashCode(), mq);
        // 如果有还没消费完的消息就20秒后执行unlock，在执行unlockDelay方法之前ProcessQueue对象的dropped属性已经被设置为true了，
        // 所以正在被ConsumeMessageOrderlyService消费的消息没法取消（正在被用户编写的consumeMessage方法消费），但是剩余的在
        // ProcessQueue中的消息不会再被消费了，此时只需要隔一段时间重新解锁即可，没必要重试。当然当前正在被消费的消息可能消费成功
        // 也可能消费失败，如果消费成功的话需要提交消费位移，否则消息顺序还是没法保证。所以ConsumeMessageOrderlyService必须要
        // 在dropped属性是否为true的情况下也要提交位移，而ConsumeMessageOrderlyService类的实现也确实这么做了（这点不同于
        // ConsumeMessageConcurrentlyService的实现，ConsumeMessageConcurrentlyService类在提交位移之前会判断dropped属性是否
        // 为false），同时在ConsumeMessageOrderlyService提交消费位移之前不会释放队列锁（20秒内不会），这就保证了消息的顺序
        this.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(new Runnable() {
            @Override
            public void run() {
                log.info("[{}]unlockDelay, execute at once {}", mq.hashCode(), mq);
                RebalancePushImpl.this.unlock(mq, true);
            }
        }, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS);
    } else {
        // 否则直接执行unlock
        this.unlock(mq, true);
    }
    return true;
}
```

`unlockDelay()`方法在还存在没有消费完成的消息时会隔20秒再解锁队列，这么做的目的是确保消息的顺序，如果直接发送解锁请求，则可能会出现短暂的两个消费者同时消费一个队列的情况，导致消息消费的顺序可能无法保证。

下面再看看解锁请求的发送，即`unlock()`方法：
```java
public void unlock(final MessageQueue mq, final boolean oneway) {
    FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);
    if (findBrokerResult != null) {
        UnlockBatchRequestBody requestBody = new UnlockBatchRequestBody();
        requestBody.setConsumerGroup(this.consumerGroup);
        requestBody.setClientId(this.mQClientFactory.getClientId());
        requestBody.getMqSet().add(mq);

        try {
            this.mQClientFactory.getMQClientAPIImpl().unlockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000, oneway);
            log.warn("unlock messageQueue. group:{}, clientId:{}, mq:{}",
                this.consumerGroup,
                this.mQClientFactory.getClientId(),
                mq);
        } catch (Exception e) {
            log.error("unlockBatchMQ exception, " + mq, e);
        }
    }
}
```

最终调用的`unlockBatchMQ()`方法会发送`RequestCode.UNLOCK_BATCH_MQ`请求到broker，broker端对应的处理方法是`AdminBrokerProcessor`类的`unlockBatchMQ()`方法：
```java
private RemotingCommand unlockBatchMQ(ChannelHandlerContext ctx,
    RemotingCommand request) throws RemotingCommandException {
    final RemotingCommand response = RemotingCommand.createResponseCommand(null);
    UnlockBatchRequestBody requestBody = UnlockBatchRequestBody.decode(request.getBody(), UnlockBatchRequestBody.class);

    this.brokerController.getRebalanceLockManager().unlockBatch(
        requestBody.getConsumerGroup(),
        requestBody.getMqSet(),
        requestBody.getClientId());

    response.setCode(ResponseCode.SUCCESS);
    response.setRemark(null);
    return response;
}
```

解锁逻辑实现在`RebalanceLockManager`类的`unlockBatch()`方法：
```java
public void unlockBatch(final String group, final Set<MessageQueue> mqs, final String clientId) {
    try {
        this.lock.lockInterruptibly();
        try {
            ConcurrentHashMap<MessageQueue, LockEntry> groupValue = this.mqLockTable.get(group);
            if (null != groupValue) {
                for (MessageQueue mq : mqs) {
                    LockEntry lockEntry = groupValue.get(mq);
                    if (null != lockEntry) {
                        if (lockEntry.getClientId().equals(clientId)) {
                            groupValue.remove(mq);
                            log.info("unlockBatch, Group: {} {} {}",
                                group,
                                mq,
                                clientId);
                        } else {
                            log.warn("unlockBatch, but mq locked by other client: {}, Group: {} {} {}",
                                lockEntry.getClientId(),
                                group,
                                mq,
                                clientId);
                        }
                    } else {
                        log.warn("unlockBatch, but mq not locked, Group: {} {} {}",
                            group,
                            mq,
                            clientId);
                    }
                }
            } else {
                log.warn("unlockBatch, group not exist, Group: {} {}",
                    group,
                    clientId);
            }
        } finally {
            this.lock.unlock();
        }
    } catch (InterruptedException e) {
        log.error("putMessage exception", e);
    }
}
```

`unlockBatch()`方法没啥好分析的，就是从`mqLockTable`中删除队列对应的记录。

以上是解锁过程，解锁过程中有一点还没分析，就是解锁时获取`ProcessQueue`对象的锁，下面来分析`ConsumeMessageOrderlyService`类是如何顺序消费消息的，分析完后就能理解解锁队列时为什么要加`ProcessQueue`对象的锁了。